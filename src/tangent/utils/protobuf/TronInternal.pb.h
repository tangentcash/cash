// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TronInternal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TronInternal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TronInternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TronInternal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TronInternal_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TronInternal_2eproto;
namespace protocol {
class AccountBalanceRequest;
struct AccountBalanceRequestDefaultTypeInternal;
extern AccountBalanceRequestDefaultTypeInternal _AccountBalanceRequest_default_instance_;
class AccountBalanceResponse;
struct AccountBalanceResponseDefaultTypeInternal;
extern AccountBalanceResponseDefaultTypeInternal _AccountBalanceResponse_default_instance_;
class AccountCreateContract;
struct AccountCreateContractDefaultTypeInternal;
extern AccountCreateContractDefaultTypeInternal _AccountCreateContract_default_instance_;
class AccountId;
struct AccountIdDefaultTypeInternal;
extern AccountIdDefaultTypeInternal _AccountId_default_instance_;
class AccountIdentifier;
struct AccountIdentifierDefaultTypeInternal;
extern AccountIdentifierDefaultTypeInternal _AccountIdentifier_default_instance_;
class AccountPermissionUpdateContract;
struct AccountPermissionUpdateContractDefaultTypeInternal;
extern AccountPermissionUpdateContractDefaultTypeInternal _AccountPermissionUpdateContract_default_instance_;
class AccountTrace;
struct AccountTraceDefaultTypeInternal;
extern AccountTraceDefaultTypeInternal _AccountTrace_default_instance_;
class AccountUpdateContract;
struct AccountUpdateContractDefaultTypeInternal;
extern AccountUpdateContractDefaultTypeInternal _AccountUpdateContract_default_instance_;
class AssetIssueContract;
struct AssetIssueContractDefaultTypeInternal;
extern AssetIssueContractDefaultTypeInternal _AssetIssueContract_default_instance_;
class AssetIssueContract_FrozenSupply;
struct AssetIssueContract_FrozenSupplyDefaultTypeInternal;
extern AssetIssueContract_FrozenSupplyDefaultTypeInternal _AssetIssueContract_FrozenSupply_default_instance_;
class AuthenticationPath;
struct AuthenticationPathDefaultTypeInternal;
extern AuthenticationPathDefaultTypeInternal _AuthenticationPath_default_instance_;
class BlockBalanceTrace;
struct BlockBalanceTraceDefaultTypeInternal;
extern BlockBalanceTraceDefaultTypeInternal _BlockBalanceTrace_default_instance_;
class BlockBalanceTrace_BlockIdentifier;
struct BlockBalanceTrace_BlockIdentifierDefaultTypeInternal;
extern BlockBalanceTrace_BlockIdentifierDefaultTypeInternal _BlockBalanceTrace_BlockIdentifier_default_instance_;
class BlockHeader;
struct BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeader_raw;
struct BlockHeader_rawDefaultTypeInternal;
extern BlockHeader_rawDefaultTypeInternal _BlockHeader_raw_default_instance_;
class BuyStorageBytesContract;
struct BuyStorageBytesContractDefaultTypeInternal;
extern BuyStorageBytesContractDefaultTypeInternal _BuyStorageBytesContract_default_instance_;
class BuyStorageContract;
struct BuyStorageContractDefaultTypeInternal;
extern BuyStorageContractDefaultTypeInternal _BuyStorageContract_default_instance_;
class CancelAllUnfreezeV2Contract;
struct CancelAllUnfreezeV2ContractDefaultTypeInternal;
extern CancelAllUnfreezeV2ContractDefaultTypeInternal _CancelAllUnfreezeV2Contract_default_instance_;
class ClearABIContract;
struct ClearABIContractDefaultTypeInternal;
extern ClearABIContractDefaultTypeInternal _ClearABIContract_default_instance_;
class ContractState;
struct ContractStateDefaultTypeInternal;
extern ContractStateDefaultTypeInternal _ContractState_default_instance_;
class CreateSmartContract;
struct CreateSmartContractDefaultTypeInternal;
extern CreateSmartContractDefaultTypeInternal _CreateSmartContract_default_instance_;
class DelegateResourceContract;
struct DelegateResourceContractDefaultTypeInternal;
extern DelegateResourceContractDefaultTypeInternal _DelegateResourceContract_default_instance_;
class ExchangeCreateContract;
struct ExchangeCreateContractDefaultTypeInternal;
extern ExchangeCreateContractDefaultTypeInternal _ExchangeCreateContract_default_instance_;
class ExchangeInjectContract;
struct ExchangeInjectContractDefaultTypeInternal;
extern ExchangeInjectContractDefaultTypeInternal _ExchangeInjectContract_default_instance_;
class ExchangeTransactionContract;
struct ExchangeTransactionContractDefaultTypeInternal;
extern ExchangeTransactionContractDefaultTypeInternal _ExchangeTransactionContract_default_instance_;
class ExchangeWithdrawContract;
struct ExchangeWithdrawContractDefaultTypeInternal;
extern ExchangeWithdrawContractDefaultTypeInternal _ExchangeWithdrawContract_default_instance_;
class FreezeBalanceContract;
struct FreezeBalanceContractDefaultTypeInternal;
extern FreezeBalanceContractDefaultTypeInternal _FreezeBalanceContract_default_instance_;
class FreezeBalanceV2Contract;
struct FreezeBalanceV2ContractDefaultTypeInternal;
extern FreezeBalanceV2ContractDefaultTypeInternal _FreezeBalanceV2Contract_default_instance_;
class IncrementalMerkleTree;
struct IncrementalMerkleTreeDefaultTypeInternal;
extern IncrementalMerkleTreeDefaultTypeInternal _IncrementalMerkleTree_default_instance_;
class IncrementalMerkleVoucher;
struct IncrementalMerkleVoucherDefaultTypeInternal;
extern IncrementalMerkleVoucherDefaultTypeInternal _IncrementalMerkleVoucher_default_instance_;
class IncrementalMerkleVoucherInfo;
struct IncrementalMerkleVoucherInfoDefaultTypeInternal;
extern IncrementalMerkleVoucherInfoDefaultTypeInternal _IncrementalMerkleVoucherInfo_default_instance_;
class Key;
struct KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class MarketCancelOrderContract;
struct MarketCancelOrderContractDefaultTypeInternal;
extern MarketCancelOrderContractDefaultTypeInternal _MarketCancelOrderContract_default_instance_;
class MarketOrderDetail;
struct MarketOrderDetailDefaultTypeInternal;
extern MarketOrderDetailDefaultTypeInternal _MarketOrderDetail_default_instance_;
class MarketSellAssetContract;
struct MarketSellAssetContractDefaultTypeInternal;
extern MarketSellAssetContractDefaultTypeInternal _MarketSellAssetContract_default_instance_;
class MerklePath;
struct MerklePathDefaultTypeInternal;
extern MerklePathDefaultTypeInternal _MerklePath_default_instance_;
class OutputPoint;
struct OutputPointDefaultTypeInternal;
extern OutputPointDefaultTypeInternal _OutputPoint_default_instance_;
class OutputPointInfo;
struct OutputPointInfoDefaultTypeInternal;
extern OutputPointInfoDefaultTypeInternal _OutputPointInfo_default_instance_;
class ParticipateAssetIssueContract;
struct ParticipateAssetIssueContractDefaultTypeInternal;
extern ParticipateAssetIssueContractDefaultTypeInternal _ParticipateAssetIssueContract_default_instance_;
class PedersenHash;
struct PedersenHashDefaultTypeInternal;
extern PedersenHashDefaultTypeInternal _PedersenHash_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class ProposalApproveContract;
struct ProposalApproveContractDefaultTypeInternal;
extern ProposalApproveContractDefaultTypeInternal _ProposalApproveContract_default_instance_;
class ProposalCreateContract;
struct ProposalCreateContractDefaultTypeInternal;
extern ProposalCreateContractDefaultTypeInternal _ProposalCreateContract_default_instance_;
class ProposalCreateContract_ParametersEntry_DoNotUse;
struct ProposalCreateContract_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ProposalCreateContract_ParametersEntry_DoNotUseDefaultTypeInternal _ProposalCreateContract_ParametersEntry_DoNotUse_default_instance_;
class ProposalDeleteContract;
struct ProposalDeleteContractDefaultTypeInternal;
extern ProposalDeleteContractDefaultTypeInternal _ProposalDeleteContract_default_instance_;
class ReceiveDescription;
struct ReceiveDescriptionDefaultTypeInternal;
extern ReceiveDescriptionDefaultTypeInternal _ReceiveDescription_default_instance_;
class SellStorageContract;
struct SellStorageContractDefaultTypeInternal;
extern SellStorageContractDefaultTypeInternal _SellStorageContract_default_instance_;
class SetAccountIdContract;
struct SetAccountIdContractDefaultTypeInternal;
extern SetAccountIdContractDefaultTypeInternal _SetAccountIdContract_default_instance_;
class ShieldedTransferContract;
struct ShieldedTransferContractDefaultTypeInternal;
extern ShieldedTransferContractDefaultTypeInternal _ShieldedTransferContract_default_instance_;
class SmartContract;
struct SmartContractDefaultTypeInternal;
extern SmartContractDefaultTypeInternal _SmartContract_default_instance_;
class SmartContractDataWrapper;
struct SmartContractDataWrapperDefaultTypeInternal;
extern SmartContractDataWrapperDefaultTypeInternal _SmartContractDataWrapper_default_instance_;
class SmartContract_ABI;
struct SmartContract_ABIDefaultTypeInternal;
extern SmartContract_ABIDefaultTypeInternal _SmartContract_ABI_default_instance_;
class SmartContract_ABI_Entry;
struct SmartContract_ABI_EntryDefaultTypeInternal;
extern SmartContract_ABI_EntryDefaultTypeInternal _SmartContract_ABI_Entry_default_instance_;
class SmartContract_ABI_Entry_Param;
struct SmartContract_ABI_Entry_ParamDefaultTypeInternal;
extern SmartContract_ABI_Entry_ParamDefaultTypeInternal _SmartContract_ABI_Entry_Param_default_instance_;
class SpendDescription;
struct SpendDescriptionDefaultTypeInternal;
extern SpendDescriptionDefaultTypeInternal _SpendDescription_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionBalanceTrace;
struct TransactionBalanceTraceDefaultTypeInternal;
extern TransactionBalanceTraceDefaultTypeInternal _TransactionBalanceTrace_default_instance_;
class TransactionBalanceTrace_Operation;
struct TransactionBalanceTrace_OperationDefaultTypeInternal;
extern TransactionBalanceTrace_OperationDefaultTypeInternal _TransactionBalanceTrace_Operation_default_instance_;
class Transaction_Contract;
struct Transaction_ContractDefaultTypeInternal;
extern Transaction_ContractDefaultTypeInternal _Transaction_Contract_default_instance_;
class Transaction_Result;
struct Transaction_ResultDefaultTypeInternal;
extern Transaction_ResultDefaultTypeInternal _Transaction_Result_default_instance_;
class Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse;
struct Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUseDefaultTypeInternal;
extern Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUseDefaultTypeInternal _Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse_default_instance_;
class Transaction_raw;
struct Transaction_rawDefaultTypeInternal;
extern Transaction_rawDefaultTypeInternal _Transaction_raw_default_instance_;
class TransferAssetContract;
struct TransferAssetContractDefaultTypeInternal;
extern TransferAssetContractDefaultTypeInternal _TransferAssetContract_default_instance_;
class TransferContract;
struct TransferContractDefaultTypeInternal;
extern TransferContractDefaultTypeInternal _TransferContract_default_instance_;
class TriggerSmartContract;
struct TriggerSmartContractDefaultTypeInternal;
extern TriggerSmartContractDefaultTypeInternal _TriggerSmartContract_default_instance_;
class UnDelegateResourceContract;
struct UnDelegateResourceContractDefaultTypeInternal;
extern UnDelegateResourceContractDefaultTypeInternal _UnDelegateResourceContract_default_instance_;
class UnfreezeAssetContract;
struct UnfreezeAssetContractDefaultTypeInternal;
extern UnfreezeAssetContractDefaultTypeInternal _UnfreezeAssetContract_default_instance_;
class UnfreezeBalanceContract;
struct UnfreezeBalanceContractDefaultTypeInternal;
extern UnfreezeBalanceContractDefaultTypeInternal _UnfreezeBalanceContract_default_instance_;
class UnfreezeBalanceV2Contract;
struct UnfreezeBalanceV2ContractDefaultTypeInternal;
extern UnfreezeBalanceV2ContractDefaultTypeInternal _UnfreezeBalanceV2Contract_default_instance_;
class UpdateAssetContract;
struct UpdateAssetContractDefaultTypeInternal;
extern UpdateAssetContractDefaultTypeInternal _UpdateAssetContract_default_instance_;
class UpdateBrokerageContract;
struct UpdateBrokerageContractDefaultTypeInternal;
extern UpdateBrokerageContractDefaultTypeInternal _UpdateBrokerageContract_default_instance_;
class UpdateEnergyLimitContract;
struct UpdateEnergyLimitContractDefaultTypeInternal;
extern UpdateEnergyLimitContractDefaultTypeInternal _UpdateEnergyLimitContract_default_instance_;
class UpdateSettingContract;
struct UpdateSettingContractDefaultTypeInternal;
extern UpdateSettingContractDefaultTypeInternal _UpdateSettingContract_default_instance_;
class VoteAssetContract;
struct VoteAssetContractDefaultTypeInternal;
extern VoteAssetContractDefaultTypeInternal _VoteAssetContract_default_instance_;
class VoteWitnessContract;
struct VoteWitnessContractDefaultTypeInternal;
extern VoteWitnessContractDefaultTypeInternal _VoteWitnessContract_default_instance_;
class VoteWitnessContract_Vote;
struct VoteWitnessContract_VoteDefaultTypeInternal;
extern VoteWitnessContract_VoteDefaultTypeInternal _VoteWitnessContract_Vote_default_instance_;
class WithdrawBalanceContract;
struct WithdrawBalanceContractDefaultTypeInternal;
extern WithdrawBalanceContractDefaultTypeInternal _WithdrawBalanceContract_default_instance_;
class WithdrawExpireUnfreezeContract;
struct WithdrawExpireUnfreezeContractDefaultTypeInternal;
extern WithdrawExpireUnfreezeContractDefaultTypeInternal _WithdrawExpireUnfreezeContract_default_instance_;
class WitnessCreateContract;
struct WitnessCreateContractDefaultTypeInternal;
extern WitnessCreateContractDefaultTypeInternal _WitnessCreateContract_default_instance_;
class WitnessUpdateContract;
struct WitnessUpdateContractDefaultTypeInternal;
extern WitnessUpdateContractDefaultTypeInternal _WitnessUpdateContract_default_instance_;
class authority;
struct authorityDefaultTypeInternal;
extern authorityDefaultTypeInternal _authority_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::AccountBalanceRequest* Arena::CreateMaybeMessage<::protocol::AccountBalanceRequest>(Arena*);
template<> ::protocol::AccountBalanceResponse* Arena::CreateMaybeMessage<::protocol::AccountBalanceResponse>(Arena*);
template<> ::protocol::AccountCreateContract* Arena::CreateMaybeMessage<::protocol::AccountCreateContract>(Arena*);
template<> ::protocol::AccountId* Arena::CreateMaybeMessage<::protocol::AccountId>(Arena*);
template<> ::protocol::AccountIdentifier* Arena::CreateMaybeMessage<::protocol::AccountIdentifier>(Arena*);
template<> ::protocol::AccountPermissionUpdateContract* Arena::CreateMaybeMessage<::protocol::AccountPermissionUpdateContract>(Arena*);
template<> ::protocol::AccountTrace* Arena::CreateMaybeMessage<::protocol::AccountTrace>(Arena*);
template<> ::protocol::AccountUpdateContract* Arena::CreateMaybeMessage<::protocol::AccountUpdateContract>(Arena*);
template<> ::protocol::AssetIssueContract* Arena::CreateMaybeMessage<::protocol::AssetIssueContract>(Arena*);
template<> ::protocol::AssetIssueContract_FrozenSupply* Arena::CreateMaybeMessage<::protocol::AssetIssueContract_FrozenSupply>(Arena*);
template<> ::protocol::AuthenticationPath* Arena::CreateMaybeMessage<::protocol::AuthenticationPath>(Arena*);
template<> ::protocol::BlockBalanceTrace* Arena::CreateMaybeMessage<::protocol::BlockBalanceTrace>(Arena*);
template<> ::protocol::BlockBalanceTrace_BlockIdentifier* Arena::CreateMaybeMessage<::protocol::BlockBalanceTrace_BlockIdentifier>(Arena*);
template<> ::protocol::BlockHeader* Arena::CreateMaybeMessage<::protocol::BlockHeader>(Arena*);
template<> ::protocol::BlockHeader_raw* Arena::CreateMaybeMessage<::protocol::BlockHeader_raw>(Arena*);
template<> ::protocol::BuyStorageBytesContract* Arena::CreateMaybeMessage<::protocol::BuyStorageBytesContract>(Arena*);
template<> ::protocol::BuyStorageContract* Arena::CreateMaybeMessage<::protocol::BuyStorageContract>(Arena*);
template<> ::protocol::CancelAllUnfreezeV2Contract* Arena::CreateMaybeMessage<::protocol::CancelAllUnfreezeV2Contract>(Arena*);
template<> ::protocol::ClearABIContract* Arena::CreateMaybeMessage<::protocol::ClearABIContract>(Arena*);
template<> ::protocol::ContractState* Arena::CreateMaybeMessage<::protocol::ContractState>(Arena*);
template<> ::protocol::CreateSmartContract* Arena::CreateMaybeMessage<::protocol::CreateSmartContract>(Arena*);
template<> ::protocol::DelegateResourceContract* Arena::CreateMaybeMessage<::protocol::DelegateResourceContract>(Arena*);
template<> ::protocol::ExchangeCreateContract* Arena::CreateMaybeMessage<::protocol::ExchangeCreateContract>(Arena*);
template<> ::protocol::ExchangeInjectContract* Arena::CreateMaybeMessage<::protocol::ExchangeInjectContract>(Arena*);
template<> ::protocol::ExchangeTransactionContract* Arena::CreateMaybeMessage<::protocol::ExchangeTransactionContract>(Arena*);
template<> ::protocol::ExchangeWithdrawContract* Arena::CreateMaybeMessage<::protocol::ExchangeWithdrawContract>(Arena*);
template<> ::protocol::FreezeBalanceContract* Arena::CreateMaybeMessage<::protocol::FreezeBalanceContract>(Arena*);
template<> ::protocol::FreezeBalanceV2Contract* Arena::CreateMaybeMessage<::protocol::FreezeBalanceV2Contract>(Arena*);
template<> ::protocol::IncrementalMerkleTree* Arena::CreateMaybeMessage<::protocol::IncrementalMerkleTree>(Arena*);
template<> ::protocol::IncrementalMerkleVoucher* Arena::CreateMaybeMessage<::protocol::IncrementalMerkleVoucher>(Arena*);
template<> ::protocol::IncrementalMerkleVoucherInfo* Arena::CreateMaybeMessage<::protocol::IncrementalMerkleVoucherInfo>(Arena*);
template<> ::protocol::Key* Arena::CreateMaybeMessage<::protocol::Key>(Arena*);
template<> ::protocol::MarketCancelOrderContract* Arena::CreateMaybeMessage<::protocol::MarketCancelOrderContract>(Arena*);
template<> ::protocol::MarketOrderDetail* Arena::CreateMaybeMessage<::protocol::MarketOrderDetail>(Arena*);
template<> ::protocol::MarketSellAssetContract* Arena::CreateMaybeMessage<::protocol::MarketSellAssetContract>(Arena*);
template<> ::protocol::MerklePath* Arena::CreateMaybeMessage<::protocol::MerklePath>(Arena*);
template<> ::protocol::OutputPoint* Arena::CreateMaybeMessage<::protocol::OutputPoint>(Arena*);
template<> ::protocol::OutputPointInfo* Arena::CreateMaybeMessage<::protocol::OutputPointInfo>(Arena*);
template<> ::protocol::ParticipateAssetIssueContract* Arena::CreateMaybeMessage<::protocol::ParticipateAssetIssueContract>(Arena*);
template<> ::protocol::PedersenHash* Arena::CreateMaybeMessage<::protocol::PedersenHash>(Arena*);
template<> ::protocol::Permission* Arena::CreateMaybeMessage<::protocol::Permission>(Arena*);
template<> ::protocol::ProposalApproveContract* Arena::CreateMaybeMessage<::protocol::ProposalApproveContract>(Arena*);
template<> ::protocol::ProposalCreateContract* Arena::CreateMaybeMessage<::protocol::ProposalCreateContract>(Arena*);
template<> ::protocol::ProposalCreateContract_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::ProposalCreateContract_ParametersEntry_DoNotUse>(Arena*);
template<> ::protocol::ProposalDeleteContract* Arena::CreateMaybeMessage<::protocol::ProposalDeleteContract>(Arena*);
template<> ::protocol::ReceiveDescription* Arena::CreateMaybeMessage<::protocol::ReceiveDescription>(Arena*);
template<> ::protocol::SellStorageContract* Arena::CreateMaybeMessage<::protocol::SellStorageContract>(Arena*);
template<> ::protocol::SetAccountIdContract* Arena::CreateMaybeMessage<::protocol::SetAccountIdContract>(Arena*);
template<> ::protocol::ShieldedTransferContract* Arena::CreateMaybeMessage<::protocol::ShieldedTransferContract>(Arena*);
template<> ::protocol::SmartContract* Arena::CreateMaybeMessage<::protocol::SmartContract>(Arena*);
template<> ::protocol::SmartContractDataWrapper* Arena::CreateMaybeMessage<::protocol::SmartContractDataWrapper>(Arena*);
template<> ::protocol::SmartContract_ABI* Arena::CreateMaybeMessage<::protocol::SmartContract_ABI>(Arena*);
template<> ::protocol::SmartContract_ABI_Entry* Arena::CreateMaybeMessage<::protocol::SmartContract_ABI_Entry>(Arena*);
template<> ::protocol::SmartContract_ABI_Entry_Param* Arena::CreateMaybeMessage<::protocol::SmartContract_ABI_Entry_Param>(Arena*);
template<> ::protocol::SpendDescription* Arena::CreateMaybeMessage<::protocol::SpendDescription>(Arena*);
template<> ::protocol::Transaction* Arena::CreateMaybeMessage<::protocol::Transaction>(Arena*);
template<> ::protocol::TransactionBalanceTrace* Arena::CreateMaybeMessage<::protocol::TransactionBalanceTrace>(Arena*);
template<> ::protocol::TransactionBalanceTrace_Operation* Arena::CreateMaybeMessage<::protocol::TransactionBalanceTrace_Operation>(Arena*);
template<> ::protocol::Transaction_Contract* Arena::CreateMaybeMessage<::protocol::Transaction_Contract>(Arena*);
template<> ::protocol::Transaction_Result* Arena::CreateMaybeMessage<::protocol::Transaction_Result>(Arena*);
template<> ::protocol::Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse>(Arena*);
template<> ::protocol::Transaction_raw* Arena::CreateMaybeMessage<::protocol::Transaction_raw>(Arena*);
template<> ::protocol::TransferAssetContract* Arena::CreateMaybeMessage<::protocol::TransferAssetContract>(Arena*);
template<> ::protocol::TransferContract* Arena::CreateMaybeMessage<::protocol::TransferContract>(Arena*);
template<> ::protocol::TriggerSmartContract* Arena::CreateMaybeMessage<::protocol::TriggerSmartContract>(Arena*);
template<> ::protocol::UnDelegateResourceContract* Arena::CreateMaybeMessage<::protocol::UnDelegateResourceContract>(Arena*);
template<> ::protocol::UnfreezeAssetContract* Arena::CreateMaybeMessage<::protocol::UnfreezeAssetContract>(Arena*);
template<> ::protocol::UnfreezeBalanceContract* Arena::CreateMaybeMessage<::protocol::UnfreezeBalanceContract>(Arena*);
template<> ::protocol::UnfreezeBalanceV2Contract* Arena::CreateMaybeMessage<::protocol::UnfreezeBalanceV2Contract>(Arena*);
template<> ::protocol::UpdateAssetContract* Arena::CreateMaybeMessage<::protocol::UpdateAssetContract>(Arena*);
template<> ::protocol::UpdateBrokerageContract* Arena::CreateMaybeMessage<::protocol::UpdateBrokerageContract>(Arena*);
template<> ::protocol::UpdateEnergyLimitContract* Arena::CreateMaybeMessage<::protocol::UpdateEnergyLimitContract>(Arena*);
template<> ::protocol::UpdateSettingContract* Arena::CreateMaybeMessage<::protocol::UpdateSettingContract>(Arena*);
template<> ::protocol::VoteAssetContract* Arena::CreateMaybeMessage<::protocol::VoteAssetContract>(Arena*);
template<> ::protocol::VoteWitnessContract* Arena::CreateMaybeMessage<::protocol::VoteWitnessContract>(Arena*);
template<> ::protocol::VoteWitnessContract_Vote* Arena::CreateMaybeMessage<::protocol::VoteWitnessContract_Vote>(Arena*);
template<> ::protocol::WithdrawBalanceContract* Arena::CreateMaybeMessage<::protocol::WithdrawBalanceContract>(Arena*);
template<> ::protocol::WithdrawExpireUnfreezeContract* Arena::CreateMaybeMessage<::protocol::WithdrawExpireUnfreezeContract>(Arena*);
template<> ::protocol::WitnessCreateContract* Arena::CreateMaybeMessage<::protocol::WitnessCreateContract>(Arena*);
template<> ::protocol::WitnessUpdateContract* Arena::CreateMaybeMessage<::protocol::WitnessUpdateContract>(Arena*);
template<> ::protocol::authority* Arena::CreateMaybeMessage<::protocol::authority>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum Permission_PermissionType : int {
  Permission_PermissionType_Owner = 0,
  Permission_PermissionType_Witness = 1,
  Permission_PermissionType_Active = 2,
  Permission_PermissionType_Permission_PermissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Permission_PermissionType_Permission_PermissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Permission_PermissionType_IsValid(int value);
constexpr Permission_PermissionType Permission_PermissionType_PermissionType_MIN = Permission_PermissionType_Owner;
constexpr Permission_PermissionType Permission_PermissionType_PermissionType_MAX = Permission_PermissionType_Active;
constexpr int Permission_PermissionType_PermissionType_ARRAYSIZE = Permission_PermissionType_PermissionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_PermissionType_descriptor();
template<typename T>
inline const std::string& Permission_PermissionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_PermissionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_PermissionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_PermissionType_descriptor(), enum_t_value);
}
inline bool Permission_PermissionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Permission_PermissionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_PermissionType>(
    Permission_PermissionType_descriptor(), name, value);
}
enum Transaction_Contract_ContractType : int {
  Transaction_Contract_ContractType_AccountCreateContract = 0,
  Transaction_Contract_ContractType_TransferContract = 1,
  Transaction_Contract_ContractType_TransferAssetContract = 2,
  Transaction_Contract_ContractType_VoteAssetContract = 3,
  Transaction_Contract_ContractType_VoteWitnessContract = 4,
  Transaction_Contract_ContractType_WitnessCreateContract = 5,
  Transaction_Contract_ContractType_AssetIssueContract = 6,
  Transaction_Contract_ContractType_WitnessUpdateContract = 8,
  Transaction_Contract_ContractType_ParticipateAssetIssueContract = 9,
  Transaction_Contract_ContractType_AccountUpdateContract = 10,
  Transaction_Contract_ContractType_FreezeBalanceContract = 11,
  Transaction_Contract_ContractType_UnfreezeBalanceContract = 12,
  Transaction_Contract_ContractType_WithdrawBalanceContract = 13,
  Transaction_Contract_ContractType_UnfreezeAssetContract = 14,
  Transaction_Contract_ContractType_UpdateAssetContract = 15,
  Transaction_Contract_ContractType_ProposalCreateContract = 16,
  Transaction_Contract_ContractType_ProposalApproveContract = 17,
  Transaction_Contract_ContractType_ProposalDeleteContract = 18,
  Transaction_Contract_ContractType_SetAccountIdContract = 19,
  Transaction_Contract_ContractType_CustomContract = 20,
  Transaction_Contract_ContractType_CreateSmartContract = 30,
  Transaction_Contract_ContractType_TriggerSmartContract = 31,
  Transaction_Contract_ContractType_GetContract = 32,
  Transaction_Contract_ContractType_UpdateSettingContract = 33,
  Transaction_Contract_ContractType_ExchangeCreateContract = 41,
  Transaction_Contract_ContractType_ExchangeInjectContract = 42,
  Transaction_Contract_ContractType_ExchangeWithdrawContract = 43,
  Transaction_Contract_ContractType_ExchangeTransactionContract = 44,
  Transaction_Contract_ContractType_UpdateEnergyLimitContract = 45,
  Transaction_Contract_ContractType_AccountPermissionUpdateContract = 46,
  Transaction_Contract_ContractType_ClearABIContract = 48,
  Transaction_Contract_ContractType_UpdateBrokerageContract = 49,
  Transaction_Contract_ContractType_ShieldedTransferContract = 51,
  Transaction_Contract_ContractType_MarketSellAssetContract = 52,
  Transaction_Contract_ContractType_MarketCancelOrderContract = 53,
  Transaction_Contract_ContractType_FreezeBalanceV2Contract = 54,
  Transaction_Contract_ContractType_UnfreezeBalanceV2Contract = 55,
  Transaction_Contract_ContractType_WithdrawExpireUnfreezeContract = 56,
  Transaction_Contract_ContractType_DelegateResourceContract = 57,
  Transaction_Contract_ContractType_UnDelegateResourceContract = 58,
  Transaction_Contract_ContractType_CancelAllUnfreezeV2Contract = 59,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Contract_ContractType_IsValid(int value);
constexpr Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MIN = Transaction_Contract_ContractType_AccountCreateContract;
constexpr Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MAX = Transaction_Contract_ContractType_CancelAllUnfreezeV2Contract;
constexpr int Transaction_Contract_ContractType_ContractType_ARRAYSIZE = Transaction_Contract_ContractType_ContractType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Contract_ContractType_descriptor();
template<typename T>
inline const std::string& Transaction_Contract_ContractType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Contract_ContractType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Contract_ContractType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Contract_ContractType_descriptor(), enum_t_value);
}
inline bool Transaction_Contract_ContractType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Contract_ContractType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Contract_ContractType>(
    Transaction_Contract_ContractType_descriptor(), name, value);
}
enum Transaction_Result_code : int {
  Transaction_Result_code_SUCESS = 0,
  Transaction_Result_code_FAILED = 1,
  Transaction_Result_code_Transaction_Result_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Result_code_Transaction_Result_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Result_code_IsValid(int value);
constexpr Transaction_Result_code Transaction_Result_code_code_MIN = Transaction_Result_code_SUCESS;
constexpr Transaction_Result_code Transaction_Result_code_code_MAX = Transaction_Result_code_FAILED;
constexpr int Transaction_Result_code_code_ARRAYSIZE = Transaction_Result_code_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Result_code_descriptor();
template<typename T>
inline const std::string& Transaction_Result_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Result_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Result_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Result_code_descriptor(), enum_t_value);
}
inline bool Transaction_Result_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Result_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Result_code>(
    Transaction_Result_code_descriptor(), name, value);
}
enum Transaction_Result_contractResult : int {
  Transaction_Result_contractResult_DEFAULT = 0,
  Transaction_Result_contractResult_SUCCESS = 1,
  Transaction_Result_contractResult_REVERT = 2,
  Transaction_Result_contractResult_BAD_JUMP_DESTINATION = 3,
  Transaction_Result_contractResult_OUT_OF_MEMORY = 4,
  Transaction_Result_contractResult_PRECOMPILED_CONTRACT = 5,
  Transaction_Result_contractResult_STACK_TOO_SMALL = 6,
  Transaction_Result_contractResult_STACK_TOO_LARGE = 7,
  Transaction_Result_contractResult_ILLEGAL_OPERATION = 8,
  Transaction_Result_contractResult_STACK_OVERFLOW = 9,
  Transaction_Result_contractResult_OUT_OF_ENERGY = 10,
  Transaction_Result_contractResult_OUT_OF_TIME = 11,
  Transaction_Result_contractResult_JVM_STACK_OVER_FLOW = 12,
  Transaction_Result_contractResult_UNKNOWN = 13,
  Transaction_Result_contractResult_TRANSFER_FAILED = 14,
  Transaction_Result_contractResult_INVALID_CODE = 15,
  Transaction_Result_contractResult_Transaction_Result_contractResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Result_contractResult_Transaction_Result_contractResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Result_contractResult_IsValid(int value);
constexpr Transaction_Result_contractResult Transaction_Result_contractResult_contractResult_MIN = Transaction_Result_contractResult_DEFAULT;
constexpr Transaction_Result_contractResult Transaction_Result_contractResult_contractResult_MAX = Transaction_Result_contractResult_INVALID_CODE;
constexpr int Transaction_Result_contractResult_contractResult_ARRAYSIZE = Transaction_Result_contractResult_contractResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Result_contractResult_descriptor();
template<typename T>
inline const std::string& Transaction_Result_contractResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Result_contractResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Result_contractResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Result_contractResult_descriptor(), enum_t_value);
}
inline bool Transaction_Result_contractResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Result_contractResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Result_contractResult>(
    Transaction_Result_contractResult_descriptor(), name, value);
}
enum SmartContract_ABI_Entry_EntryType : int {
  SmartContract_ABI_Entry_EntryType_UnknownEntryType = 0,
  SmartContract_ABI_Entry_EntryType_Constructor = 1,
  SmartContract_ABI_Entry_EntryType_Function = 2,
  SmartContract_ABI_Entry_EntryType_Event = 3,
  SmartContract_ABI_Entry_EntryType_Fallback = 4,
  SmartContract_ABI_Entry_EntryType_Receive = 5,
  SmartContract_ABI_Entry_EntryType_Error = 6,
  SmartContract_ABI_Entry_EntryType_SmartContract_ABI_Entry_EntryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SmartContract_ABI_Entry_EntryType_SmartContract_ABI_Entry_EntryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SmartContract_ABI_Entry_EntryType_IsValid(int value);
constexpr SmartContract_ABI_Entry_EntryType SmartContract_ABI_Entry_EntryType_EntryType_MIN = SmartContract_ABI_Entry_EntryType_UnknownEntryType;
constexpr SmartContract_ABI_Entry_EntryType SmartContract_ABI_Entry_EntryType_EntryType_MAX = SmartContract_ABI_Entry_EntryType_Error;
constexpr int SmartContract_ABI_Entry_EntryType_EntryType_ARRAYSIZE = SmartContract_ABI_Entry_EntryType_EntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmartContract_ABI_Entry_EntryType_descriptor();
template<typename T>
inline const std::string& SmartContract_ABI_Entry_EntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SmartContract_ABI_Entry_EntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SmartContract_ABI_Entry_EntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SmartContract_ABI_Entry_EntryType_descriptor(), enum_t_value);
}
inline bool SmartContract_ABI_Entry_EntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SmartContract_ABI_Entry_EntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SmartContract_ABI_Entry_EntryType>(
    SmartContract_ABI_Entry_EntryType_descriptor(), name, value);
}
enum SmartContract_ABI_Entry_StateMutabilityType : int {
  SmartContract_ABI_Entry_StateMutabilityType_UnknownMutabilityType = 0,
  SmartContract_ABI_Entry_StateMutabilityType_Pure = 1,
  SmartContract_ABI_Entry_StateMutabilityType_View = 2,
  SmartContract_ABI_Entry_StateMutabilityType_Nonpayable = 3,
  SmartContract_ABI_Entry_StateMutabilityType_Payable = 4,
  SmartContract_ABI_Entry_StateMutabilityType_SmartContract_ABI_Entry_StateMutabilityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SmartContract_ABI_Entry_StateMutabilityType_SmartContract_ABI_Entry_StateMutabilityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SmartContract_ABI_Entry_StateMutabilityType_IsValid(int value);
constexpr SmartContract_ABI_Entry_StateMutabilityType SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_MIN = SmartContract_ABI_Entry_StateMutabilityType_UnknownMutabilityType;
constexpr SmartContract_ABI_Entry_StateMutabilityType SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_MAX = SmartContract_ABI_Entry_StateMutabilityType_Payable;
constexpr int SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_ARRAYSIZE = SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmartContract_ABI_Entry_StateMutabilityType_descriptor();
template<typename T>
inline const std::string& SmartContract_ABI_Entry_StateMutabilityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SmartContract_ABI_Entry_StateMutabilityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SmartContract_ABI_Entry_StateMutabilityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SmartContract_ABI_Entry_StateMutabilityType_descriptor(), enum_t_value);
}
inline bool SmartContract_ABI_Entry_StateMutabilityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SmartContract_ABI_Entry_StateMutabilityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SmartContract_ABI_Entry_StateMutabilityType>(
    SmartContract_ABI_Entry_StateMutabilityType_descriptor(), name, value);
}
enum ResourceCode : int {
  BANDWIDTH = 0,
  ENERGY = 1,
  TRON_POWER = 2,
  ResourceCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResourceCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResourceCode_IsValid(int value);
constexpr ResourceCode ResourceCode_MIN = BANDWIDTH;
constexpr ResourceCode ResourceCode_MAX = TRON_POWER;
constexpr int ResourceCode_ARRAYSIZE = ResourceCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourceCode_descriptor();
template<typename T>
inline const std::string& ResourceCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourceCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourceCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourceCode_descriptor(), enum_t_value);
}
inline bool ResourceCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourceCode>(
    ResourceCode_descriptor(), name, value);
}
enum AccountType : int {
  Normal = 0,
  AssetIssue = 1,
  Contract = 2,
  AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccountType_IsValid(int value);
constexpr AccountType AccountType_MIN = Normal;
constexpr AccountType AccountType_MAX = Contract;
constexpr int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountType_descriptor();
template<typename T>
inline const std::string& AccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountType_descriptor(), enum_t_value);
}
inline bool AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccountType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
// ===================================================================

class AccountId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountId) */ {
 public:
  inline AccountId() : AccountId(nullptr) {}
  ~AccountId() override;
  explicit PROTOBUF_CONSTEXPR AccountId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountId(const AccountId& from);
  AccountId(AccountId&& from) noexcept
    : AccountId() {
    *this = ::std::move(from);
  }

  inline AccountId& operator=(const AccountId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountId& operator=(AccountId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountId* internal_default_instance() {
    return reinterpret_cast<const AccountId*>(
               &_AccountId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AccountId& a, AccountId& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountId>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountId";
  }
  protected:
  explicit AccountId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class authority final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.authority) */ {
 public:
  inline authority() : authority(nullptr) {}
  ~authority() override;
  explicit PROTOBUF_CONSTEXPR authority(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  authority(const authority& from);
  authority(authority&& from) noexcept
    : authority() {
    *this = ::std::move(from);
  }

  inline authority& operator=(const authority& from) {
    CopyFrom(from);
    return *this;
  }
  inline authority& operator=(authority&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authority& default_instance() {
    return *internal_default_instance();
  }
  static inline const authority* internal_default_instance() {
    return reinterpret_cast<const authority*>(
               &_authority_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(authority& a, authority& b) {
    a.Swap(&b);
  }
  inline void Swap(authority* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authority* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authority* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authority>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(authority* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.authority";
  }
  protected:
  explicit authority(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionNameFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // bytes permission_name = 2;
  void clear_permission_name();
  const std::string& permission_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_name();
  PROTOBUF_NODISCARD std::string* release_permission_name();
  void set_allocated_permission_name(std::string* permission_name);
  private:
  const std::string& _internal_permission_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_name(const std::string& value);
  std::string* _internal_mutable_permission_name();
  public:

  // .protocol.AccountId account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::protocol::AccountId& account() const;
  PROTOBUF_NODISCARD ::protocol::AccountId* release_account();
  ::protocol::AccountId* mutable_account();
  void set_allocated_account(::protocol::AccountId* account);
  private:
  const ::protocol::AccountId& _internal_account() const;
  ::protocol::AccountId* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::protocol::AccountId* account);
  ::protocol::AccountId* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:protocol.authority)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_name_;
    ::protocol::AccountId* account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit PROTOBUF_CONSTEXPR Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Permission_PermissionType PermissionType;
  static constexpr PermissionType Owner =
    Permission_PermissionType_Owner;
  static constexpr PermissionType Witness =
    Permission_PermissionType_Witness;
  static constexpr PermissionType Active =
    Permission_PermissionType_Active;
  static inline bool PermissionType_IsValid(int value) {
    return Permission_PermissionType_IsValid(value);
  }
  static constexpr PermissionType PermissionType_MIN =
    Permission_PermissionType_PermissionType_MIN;
  static constexpr PermissionType PermissionType_MAX =
    Permission_PermissionType_PermissionType_MAX;
  static constexpr int PermissionType_ARRAYSIZE =
    Permission_PermissionType_PermissionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PermissionType_descriptor() {
    return Permission_PermissionType_descriptor();
  }
  template<typename T>
  static inline const std::string& PermissionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PermissionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PermissionType_Name.");
    return Permission_PermissionType_Name(enum_t_value);
  }
  static inline bool PermissionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PermissionType* value) {
    return Permission_PermissionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 7,
    kPermissionNameFieldNumber = 3,
    kOperationsFieldNumber = 6,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kThresholdFieldNumber = 4,
    kParentIdFieldNumber = 5,
  };
  // repeated .protocol.Key keys = 7;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::protocol::Key* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >*
      mutable_keys();
  private:
  const ::protocol::Key& _internal_keys(int index) const;
  ::protocol::Key* _internal_add_keys();
  public:
  const ::protocol::Key& keys(int index) const;
  ::protocol::Key* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >&
      keys() const;

  // string permission_name = 3;
  void clear_permission_name();
  const std::string& permission_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_name();
  PROTOBUF_NODISCARD std::string* release_permission_name();
  void set_allocated_permission_name(std::string* permission_name);
  private:
  const std::string& _internal_permission_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_name(const std::string& value);
  std::string* _internal_mutable_permission_name();
  public:

  // bytes operations = 6;
  void clear_operations();
  const std::string& operations() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operations(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operations();
  PROTOBUF_NODISCARD std::string* release_operations();
  void set_allocated_operations(std::string* operations);
  private:
  const std::string& _internal_operations() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operations(const std::string& value);
  std::string* _internal_mutable_operations();
  public:

  // .protocol.Permission.PermissionType type = 1;
  void clear_type();
  ::protocol::Permission_PermissionType type() const;
  void set_type(::protocol::Permission_PermissionType value);
  private:
  ::protocol::Permission_PermissionType _internal_type() const;
  void _internal_set_type(::protocol::Permission_PermissionType value);
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int64 threshold = 4;
  void clear_threshold();
  int64_t threshold() const;
  void set_threshold(int64_t value);
  private:
  int64_t _internal_threshold() const;
  void _internal_set_threshold(int64_t value);
  public:

  // int32 parent_id = 5;
  void clear_parent_id();
  int32_t parent_id() const;
  void set_parent_id(int32_t value);
  private:
  int32_t _internal_parent_id() const;
  void _internal_set_parent_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Permission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key > keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operations_;
    int type_;
    int32_t id_;
    int64_t threshold_;
    int32_t parent_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderDetail) */ {
 public:
  inline MarketOrderDetail() : MarketOrderDetail(nullptr) {}
  ~MarketOrderDetail() override;
  explicit PROTOBUF_CONSTEXPR MarketOrderDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderDetail(const MarketOrderDetail& from);
  MarketOrderDetail(MarketOrderDetail&& from) noexcept
    : MarketOrderDetail() {
    *this = ::std::move(from);
  }

  inline MarketOrderDetail& operator=(const MarketOrderDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderDetail& operator=(MarketOrderDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderDetail* internal_default_instance() {
    return reinterpret_cast<const MarketOrderDetail*>(
               &_MarketOrderDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MarketOrderDetail& a, MarketOrderDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderDetail>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderDetail";
  }
  protected:
  explicit MarketOrderDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerOrderIdFieldNumber = 1,
    kTakerOrderIdFieldNumber = 2,
    kFillSellQuantityFieldNumber = 3,
    kFillBuyQuantityFieldNumber = 4,
  };
  // bytes makerOrderId = 1;
  void clear_makerorderid();
  const std::string& makerorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_makerorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_makerorderid();
  PROTOBUF_NODISCARD std::string* release_makerorderid();
  void set_allocated_makerorderid(std::string* makerorderid);
  private:
  const std::string& _internal_makerorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_makerorderid(const std::string& value);
  std::string* _internal_mutable_makerorderid();
  public:

  // bytes takerOrderId = 2;
  void clear_takerorderid();
  const std::string& takerorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_takerorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_takerorderid();
  PROTOBUF_NODISCARD std::string* release_takerorderid();
  void set_allocated_takerorderid(std::string* takerorderid);
  private:
  const std::string& _internal_takerorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_takerorderid(const std::string& value);
  std::string* _internal_mutable_takerorderid();
  public:

  // int64 fillSellQuantity = 3;
  void clear_fillsellquantity();
  int64_t fillsellquantity() const;
  void set_fillsellquantity(int64_t value);
  private:
  int64_t _internal_fillsellquantity() const;
  void _internal_set_fillsellquantity(int64_t value);
  public:

  // int64 fillBuyQuantity = 4;
  void clear_fillbuyquantity();
  int64_t fillbuyquantity() const;
  void set_fillbuyquantity(int64_t value);
  private:
  int64_t _internal_fillbuyquantity() const;
  void _internal_set_fillbuyquantity(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr makerorderid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr takerorderid_;
    int64_t fillsellquantity_;
    int64_t fillbuyquantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Key final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Key) */ {
 public:
  inline Key() : Key(nullptr) {}
  ~Key() override;
  explicit PROTOBUF_CONSTEXPR Key(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Key(const Key& from);
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  inline Key& operator=(Key&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Key& default_instance() {
    return *internal_default_instance();
  }
  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }
  inline void Swap(Key* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Key";
  }
  protected:
  explicit Key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int64 weight = 2;
  void clear_weight();
  int64_t weight() const;
  void set_weight(int64_t value);
  private:
  int64_t _internal_weight() const;
  void _internal_set_weight(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Key)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int64_t weight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction_Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Contract) */ {
 public:
  inline Transaction_Contract() : Transaction_Contract(nullptr) {}
  ~Transaction_Contract() override;
  explicit PROTOBUF_CONSTEXPR Transaction_Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_Contract(const Transaction_Contract& from);
  Transaction_Contract(Transaction_Contract&& from) noexcept
    : Transaction_Contract() {
    *this = ::std::move(from);
  }

  inline Transaction_Contract& operator=(const Transaction_Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_Contract& operator=(Transaction_Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_Contract* internal_default_instance() {
    return reinterpret_cast<const Transaction_Contract*>(
               &_Transaction_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Transaction_Contract& a, Transaction_Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_Contract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.Contract";
  }
  protected:
  explicit Transaction_Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract_ContractType ContractType;
  static constexpr ContractType AccountCreateContract =
    Transaction_Contract_ContractType_AccountCreateContract;
  static constexpr ContractType TransferContract =
    Transaction_Contract_ContractType_TransferContract;
  static constexpr ContractType TransferAssetContract =
    Transaction_Contract_ContractType_TransferAssetContract;
  static constexpr ContractType VoteAssetContract =
    Transaction_Contract_ContractType_VoteAssetContract;
  static constexpr ContractType VoteWitnessContract =
    Transaction_Contract_ContractType_VoteWitnessContract;
  static constexpr ContractType WitnessCreateContract =
    Transaction_Contract_ContractType_WitnessCreateContract;
  static constexpr ContractType AssetIssueContract =
    Transaction_Contract_ContractType_AssetIssueContract;
  static constexpr ContractType WitnessUpdateContract =
    Transaction_Contract_ContractType_WitnessUpdateContract;
  static constexpr ContractType ParticipateAssetIssueContract =
    Transaction_Contract_ContractType_ParticipateAssetIssueContract;
  static constexpr ContractType AccountUpdateContract =
    Transaction_Contract_ContractType_AccountUpdateContract;
  static constexpr ContractType FreezeBalanceContract =
    Transaction_Contract_ContractType_FreezeBalanceContract;
  static constexpr ContractType UnfreezeBalanceContract =
    Transaction_Contract_ContractType_UnfreezeBalanceContract;
  static constexpr ContractType WithdrawBalanceContract =
    Transaction_Contract_ContractType_WithdrawBalanceContract;
  static constexpr ContractType UnfreezeAssetContract =
    Transaction_Contract_ContractType_UnfreezeAssetContract;
  static constexpr ContractType UpdateAssetContract =
    Transaction_Contract_ContractType_UpdateAssetContract;
  static constexpr ContractType ProposalCreateContract =
    Transaction_Contract_ContractType_ProposalCreateContract;
  static constexpr ContractType ProposalApproveContract =
    Transaction_Contract_ContractType_ProposalApproveContract;
  static constexpr ContractType ProposalDeleteContract =
    Transaction_Contract_ContractType_ProposalDeleteContract;
  static constexpr ContractType SetAccountIdContract =
    Transaction_Contract_ContractType_SetAccountIdContract;
  static constexpr ContractType CustomContract =
    Transaction_Contract_ContractType_CustomContract;
  static constexpr ContractType CreateSmartContract =
    Transaction_Contract_ContractType_CreateSmartContract;
  static constexpr ContractType TriggerSmartContract =
    Transaction_Contract_ContractType_TriggerSmartContract;
  static constexpr ContractType GetContract =
    Transaction_Contract_ContractType_GetContract;
  static constexpr ContractType UpdateSettingContract =
    Transaction_Contract_ContractType_UpdateSettingContract;
  static constexpr ContractType ExchangeCreateContract =
    Transaction_Contract_ContractType_ExchangeCreateContract;
  static constexpr ContractType ExchangeInjectContract =
    Transaction_Contract_ContractType_ExchangeInjectContract;
  static constexpr ContractType ExchangeWithdrawContract =
    Transaction_Contract_ContractType_ExchangeWithdrawContract;
  static constexpr ContractType ExchangeTransactionContract =
    Transaction_Contract_ContractType_ExchangeTransactionContract;
  static constexpr ContractType UpdateEnergyLimitContract =
    Transaction_Contract_ContractType_UpdateEnergyLimitContract;
  static constexpr ContractType AccountPermissionUpdateContract =
    Transaction_Contract_ContractType_AccountPermissionUpdateContract;
  static constexpr ContractType ClearABIContract =
    Transaction_Contract_ContractType_ClearABIContract;
  static constexpr ContractType UpdateBrokerageContract =
    Transaction_Contract_ContractType_UpdateBrokerageContract;
  static constexpr ContractType ShieldedTransferContract =
    Transaction_Contract_ContractType_ShieldedTransferContract;
  static constexpr ContractType MarketSellAssetContract =
    Transaction_Contract_ContractType_MarketSellAssetContract;
  static constexpr ContractType MarketCancelOrderContract =
    Transaction_Contract_ContractType_MarketCancelOrderContract;
  static constexpr ContractType FreezeBalanceV2Contract =
    Transaction_Contract_ContractType_FreezeBalanceV2Contract;
  static constexpr ContractType UnfreezeBalanceV2Contract =
    Transaction_Contract_ContractType_UnfreezeBalanceV2Contract;
  static constexpr ContractType WithdrawExpireUnfreezeContract =
    Transaction_Contract_ContractType_WithdrawExpireUnfreezeContract;
  static constexpr ContractType DelegateResourceContract =
    Transaction_Contract_ContractType_DelegateResourceContract;
  static constexpr ContractType UnDelegateResourceContract =
    Transaction_Contract_ContractType_UnDelegateResourceContract;
  static constexpr ContractType CancelAllUnfreezeV2Contract =
    Transaction_Contract_ContractType_CancelAllUnfreezeV2Contract;
  static inline bool ContractType_IsValid(int value) {
    return Transaction_Contract_ContractType_IsValid(value);
  }
  static constexpr ContractType ContractType_MIN =
    Transaction_Contract_ContractType_ContractType_MIN;
  static constexpr ContractType ContractType_MAX =
    Transaction_Contract_ContractType_ContractType_MAX;
  static constexpr int ContractType_ARRAYSIZE =
    Transaction_Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContractType_descriptor() {
    return Transaction_Contract_ContractType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContractType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContractType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContractType_Name.");
    return Transaction_Contract_ContractType_Name(enum_t_value);
  }
  static inline bool ContractType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContractType* value) {
    return Transaction_Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProviderFieldNumber = 3,
    kContractNameFieldNumber = 4,
    kParameterFieldNumber = 2,
    kTypeFieldNumber = 1,
    kPermissionIdFieldNumber = 5,
  };
  // bytes provider = 3;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // bytes ContractName = 4;
  void clear_contractname();
  const std::string& contractname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractname();
  PROTOBUF_NODISCARD std::string* release_contractname();
  void set_allocated_contractname(std::string* contractname);
  private:
  const std::string& _internal_contractname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractname(const std::string& value);
  std::string* _internal_mutable_contractname();
  public:

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  const ::PROTOBUF_NAMESPACE_ID::Any& parameter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_parameter();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_parameter();
  void set_allocated_parameter(::PROTOBUF_NAMESPACE_ID::Any* parameter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_parameter() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_parameter();
  public:
  void unsafe_arena_set_allocated_parameter(
      ::PROTOBUF_NAMESPACE_ID::Any* parameter);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_parameter();

  // .protocol.Transaction.Contract.ContractType type = 1;
  void clear_type();
  ::protocol::Transaction_Contract_ContractType type() const;
  void set_type(::protocol::Transaction_Contract_ContractType value);
  private:
  ::protocol::Transaction_Contract_ContractType _internal_type() const;
  void _internal_set_type(::protocol::Transaction_Contract_ContractType value);
  public:

  // int32 Permission_id = 5;
  void clear_permission_id();
  int32_t permission_id() const;
  void set_permission_id(int32_t value);
  private:
  int32_t _internal_permission_id() const;
  void _internal_set_permission_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractname_;
    ::PROTOBUF_NAMESPACE_ID::Any* parameter_;
    int type_;
    int32_t permission_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse& other);
  static const Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse*>(&_Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Transaction.Result.CancelUnfreezeV2AmountEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_TronInternal_2eproto;
};

// -------------------------------------------------------------------

class Transaction_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Result) */ {
 public:
  inline Transaction_Result() : Transaction_Result(nullptr) {}
  ~Transaction_Result() override;
  explicit PROTOBUF_CONSTEXPR Transaction_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_Result(const Transaction_Result& from);
  Transaction_Result(Transaction_Result&& from) noexcept
    : Transaction_Result() {
    *this = ::std::move(from);
  }

  inline Transaction_Result& operator=(const Transaction_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_Result& operator=(Transaction_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_Result* internal_default_instance() {
    return reinterpret_cast<const Transaction_Result*>(
               &_Transaction_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Transaction_Result& a, Transaction_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_Result>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.Result";
  }
  protected:
  explicit Transaction_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Transaction_Result_code code;
  static constexpr code SUCESS =
    Transaction_Result_code_SUCESS;
  static constexpr code FAILED =
    Transaction_Result_code_FAILED;
  static inline bool code_IsValid(int value) {
    return Transaction_Result_code_IsValid(value);
  }
  static constexpr code code_MIN =
    Transaction_Result_code_code_MIN;
  static constexpr code code_MAX =
    Transaction_Result_code_code_MAX;
  static constexpr int code_ARRAYSIZE =
    Transaction_Result_code_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  code_descriptor() {
    return Transaction_Result_code_descriptor();
  }
  template<typename T>
  static inline const std::string& code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function code_Name.");
    return Transaction_Result_code_Name(enum_t_value);
  }
  static inline bool code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      code* value) {
    return Transaction_Result_code_Parse(name, value);
  }

  typedef Transaction_Result_contractResult contractResult;
  static constexpr contractResult DEFAULT =
    Transaction_Result_contractResult_DEFAULT;
  static constexpr contractResult SUCCESS =
    Transaction_Result_contractResult_SUCCESS;
  static constexpr contractResult REVERT =
    Transaction_Result_contractResult_REVERT;
  static constexpr contractResult BAD_JUMP_DESTINATION =
    Transaction_Result_contractResult_BAD_JUMP_DESTINATION;
  static constexpr contractResult OUT_OF_MEMORY =
    Transaction_Result_contractResult_OUT_OF_MEMORY;
  static constexpr contractResult PRECOMPILED_CONTRACT =
    Transaction_Result_contractResult_PRECOMPILED_CONTRACT;
  static constexpr contractResult STACK_TOO_SMALL =
    Transaction_Result_contractResult_STACK_TOO_SMALL;
  static constexpr contractResult STACK_TOO_LARGE =
    Transaction_Result_contractResult_STACK_TOO_LARGE;
  static constexpr contractResult ILLEGAL_OPERATION =
    Transaction_Result_contractResult_ILLEGAL_OPERATION;
  static constexpr contractResult STACK_OVERFLOW =
    Transaction_Result_contractResult_STACK_OVERFLOW;
  static constexpr contractResult OUT_OF_ENERGY =
    Transaction_Result_contractResult_OUT_OF_ENERGY;
  static constexpr contractResult OUT_OF_TIME =
    Transaction_Result_contractResult_OUT_OF_TIME;
  static constexpr contractResult JVM_STACK_OVER_FLOW =
    Transaction_Result_contractResult_JVM_STACK_OVER_FLOW;
  static constexpr contractResult UNKNOWN =
    Transaction_Result_contractResult_UNKNOWN;
  static constexpr contractResult TRANSFER_FAILED =
    Transaction_Result_contractResult_TRANSFER_FAILED;
  static constexpr contractResult INVALID_CODE =
    Transaction_Result_contractResult_INVALID_CODE;
  static inline bool contractResult_IsValid(int value) {
    return Transaction_Result_contractResult_IsValid(value);
  }
  static constexpr contractResult contractResult_MIN =
    Transaction_Result_contractResult_contractResult_MIN;
  static constexpr contractResult contractResult_MAX =
    Transaction_Result_contractResult_contractResult_MAX;
  static constexpr int contractResult_ARRAYSIZE =
    Transaction_Result_contractResult_contractResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  contractResult_descriptor() {
    return Transaction_Result_contractResult_descriptor();
  }
  template<typename T>
  static inline const std::string& contractResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, contractResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function contractResult_Name.");
    return Transaction_Result_contractResult_Name(enum_t_value);
  }
  static inline bool contractResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      contractResult* value) {
    return Transaction_Result_contractResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrderDetailsFieldNumber = 26,
    kCancelUnfreezeV2AmountFieldNumber = 28,
    kAssetIssueIDFieldNumber = 14,
    kOrderIdFieldNumber = 25,
    kFeeFieldNumber = 1,
    kRetFieldNumber = 2,
    kContractRetFieldNumber = 3,
    kWithdrawAmountFieldNumber = 15,
    kUnfreezeAmountFieldNumber = 16,
    kExchangeReceivedAmountFieldNumber = 18,
    kExchangeInjectAnotherAmountFieldNumber = 19,
    kExchangeWithdrawAnotherAmountFieldNumber = 20,
    kExchangeIdFieldNumber = 21,
    kShieldedTransactionFeeFieldNumber = 22,
    kWithdrawExpireAmountFieldNumber = 27,
  };
  // repeated .protocol.MarketOrderDetail orderDetails = 26;
  int orderdetails_size() const;
  private:
  int _internal_orderdetails_size() const;
  public:
  void clear_orderdetails();
  ::protocol::MarketOrderDetail* mutable_orderdetails(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
      mutable_orderdetails();
  private:
  const ::protocol::MarketOrderDetail& _internal_orderdetails(int index) const;
  ::protocol::MarketOrderDetail* _internal_add_orderdetails();
  public:
  const ::protocol::MarketOrderDetail& orderdetails(int index) const;
  ::protocol::MarketOrderDetail* add_orderdetails();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
      orderdetails() const;

  // map<string, int64> cancel_unfreezeV2_amount = 28;
  int cancel_unfreezev2_amount_size() const;
  private:
  int _internal_cancel_unfreezev2_amount_size() const;
  public:
  void clear_cancel_unfreezev2_amount();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_cancel_unfreezev2_amount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_cancel_unfreezev2_amount();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      cancel_unfreezev2_amount() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_cancel_unfreezev2_amount();

  // string assetIssueID = 14;
  void clear_assetissueid();
  const std::string& assetissueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetissueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetissueid();
  PROTOBUF_NODISCARD std::string* release_assetissueid();
  void set_allocated_assetissueid(std::string* assetissueid);
  private:
  const std::string& _internal_assetissueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetissueid(const std::string& value);
  std::string* _internal_mutable_assetissueid();
  public:

  // bytes orderId = 25;
  void clear_orderid();
  const std::string& orderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_orderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_orderid();
  PROTOBUF_NODISCARD std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // int64 fee = 1;
  void clear_fee();
  int64_t fee() const;
  void set_fee(int64_t value);
  private:
  int64_t _internal_fee() const;
  void _internal_set_fee(int64_t value);
  public:

  // .protocol.Transaction.Result.code ret = 2;
  void clear_ret();
  ::protocol::Transaction_Result_code ret() const;
  void set_ret(::protocol::Transaction_Result_code value);
  private:
  ::protocol::Transaction_Result_code _internal_ret() const;
  void _internal_set_ret(::protocol::Transaction_Result_code value);
  public:

  // .protocol.Transaction.Result.contractResult contractRet = 3;
  void clear_contractret();
  ::protocol::Transaction_Result_contractResult contractret() const;
  void set_contractret(::protocol::Transaction_Result_contractResult value);
  private:
  ::protocol::Transaction_Result_contractResult _internal_contractret() const;
  void _internal_set_contractret(::protocol::Transaction_Result_contractResult value);
  public:

  // int64 withdraw_amount = 15;
  void clear_withdraw_amount();
  int64_t withdraw_amount() const;
  void set_withdraw_amount(int64_t value);
  private:
  int64_t _internal_withdraw_amount() const;
  void _internal_set_withdraw_amount(int64_t value);
  public:

  // int64 unfreeze_amount = 16;
  void clear_unfreeze_amount();
  int64_t unfreeze_amount() const;
  void set_unfreeze_amount(int64_t value);
  private:
  int64_t _internal_unfreeze_amount() const;
  void _internal_set_unfreeze_amount(int64_t value);
  public:

  // int64 exchange_received_amount = 18;
  void clear_exchange_received_amount();
  int64_t exchange_received_amount() const;
  void set_exchange_received_amount(int64_t value);
  private:
  int64_t _internal_exchange_received_amount() const;
  void _internal_set_exchange_received_amount(int64_t value);
  public:

  // int64 exchange_inject_another_amount = 19;
  void clear_exchange_inject_another_amount();
  int64_t exchange_inject_another_amount() const;
  void set_exchange_inject_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_inject_another_amount() const;
  void _internal_set_exchange_inject_another_amount(int64_t value);
  public:

  // int64 exchange_withdraw_another_amount = 20;
  void clear_exchange_withdraw_another_amount();
  int64_t exchange_withdraw_another_amount() const;
  void set_exchange_withdraw_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_withdraw_another_amount() const;
  void _internal_set_exchange_withdraw_another_amount(int64_t value);
  public:

  // int64 exchange_id = 21;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 shielded_transaction_fee = 22;
  void clear_shielded_transaction_fee();
  int64_t shielded_transaction_fee() const;
  void set_shielded_transaction_fee(int64_t value);
  private:
  int64_t _internal_shielded_transaction_fee() const;
  void _internal_set_shielded_transaction_fee(int64_t value);
  public:

  // int64 withdraw_expire_amount = 27;
  void clear_withdraw_expire_amount();
  int64_t withdraw_expire_amount() const;
  void set_withdraw_expire_amount(int64_t value);
  private:
  int64_t _internal_withdraw_expire_amount() const;
  void _internal_set_withdraw_expire_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail > orderdetails_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Transaction_Result_CancelUnfreezeV2AmountEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> cancel_unfreezev2_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetissueid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
    int64_t fee_;
    int ret_;
    int contractret_;
    int64_t withdraw_amount_;
    int64_t unfreeze_amount_;
    int64_t exchange_received_amount_;
    int64_t exchange_inject_another_amount_;
    int64_t exchange_withdraw_another_amount_;
    int64_t exchange_id_;
    int64_t shielded_transaction_fee_;
    int64_t withdraw_expire_amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction_raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.raw) */ {
 public:
  inline Transaction_raw() : Transaction_raw(nullptr) {}
  ~Transaction_raw() override;
  explicit PROTOBUF_CONSTEXPR Transaction_raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_raw(const Transaction_raw& from);
  Transaction_raw(Transaction_raw&& from) noexcept
    : Transaction_raw() {
    *this = ::std::move(from);
  }

  inline Transaction_raw& operator=(const Transaction_raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_raw& operator=(Transaction_raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_raw* internal_default_instance() {
    return reinterpret_cast<const Transaction_raw*>(
               &_Transaction_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Transaction_raw& a, Transaction_raw& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_raw>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.raw";
  }
  protected:
  explicit Transaction_raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthsFieldNumber = 9,
    kContractFieldNumber = 11,
    kRefBlockBytesFieldNumber = 1,
    kRefBlockHashFieldNumber = 4,
    kDataFieldNumber = 10,
    kScriptsFieldNumber = 12,
    kRefBlockNumFieldNumber = 3,
    kExpirationFieldNumber = 8,
    kTimestampFieldNumber = 14,
    kFeeLimitFieldNumber = 18,
  };
  // repeated .protocol.authority auths = 9;
  int auths_size() const;
  private:
  int _internal_auths_size() const;
  public:
  void clear_auths();
  ::protocol::authority* mutable_auths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >*
      mutable_auths();
  private:
  const ::protocol::authority& _internal_auths(int index) const;
  ::protocol::authority* _internal_add_auths();
  public:
  const ::protocol::authority& auths(int index) const;
  ::protocol::authority* add_auths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >&
      auths() const;

  // repeated .protocol.Transaction.Contract contract = 11;
  int contract_size() const;
  private:
  int _internal_contract_size() const;
  public:
  void clear_contract();
  ::protocol::Transaction_Contract* mutable_contract(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >*
      mutable_contract();
  private:
  const ::protocol::Transaction_Contract& _internal_contract(int index) const;
  ::protocol::Transaction_Contract* _internal_add_contract();
  public:
  const ::protocol::Transaction_Contract& contract(int index) const;
  ::protocol::Transaction_Contract* add_contract();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >&
      contract() const;

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  const std::string& ref_block_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_bytes();
  PROTOBUF_NODISCARD std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(std::string* ref_block_bytes);
  private:
  const std::string& _internal_ref_block_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_bytes(const std::string& value);
  std::string* _internal_mutable_ref_block_bytes();
  public:

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  const std::string& ref_block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_hash();
  PROTOBUF_NODISCARD std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(std::string* ref_block_hash);
  private:
  const std::string& _internal_ref_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_hash(const std::string& value);
  std::string* _internal_mutable_ref_block_hash();
  public:

  // bytes data = 10;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes scripts = 12;
  void clear_scripts();
  const std::string& scripts() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scripts(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scripts();
  PROTOBUF_NODISCARD std::string* release_scripts();
  void set_allocated_scripts(std::string* scripts);
  private:
  const std::string& _internal_scripts() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scripts(const std::string& value);
  std::string* _internal_mutable_scripts();
  public:

  // int64 ref_block_num = 3;
  void clear_ref_block_num();
  int64_t ref_block_num() const;
  void set_ref_block_num(int64_t value);
  private:
  int64_t _internal_ref_block_num() const;
  void _internal_set_ref_block_num(int64_t value);
  public:

  // int64 expiration = 8;
  void clear_expiration();
  int64_t expiration() const;
  void set_expiration(int64_t value);
  private:
  int64_t _internal_expiration() const;
  void _internal_set_expiration(int64_t value);
  public:

  // int64 timestamp = 14;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 fee_limit = 18;
  void clear_fee_limit();
  int64_t fee_limit() const;
  void set_fee_limit(int64_t value);
  private:
  int64_t _internal_fee_limit() const;
  void _internal_set_fee_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority > auths_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract > contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scripts_;
    int64_t ref_block_num_;
    int64_t expiration_;
    int64_t timestamp_;
    int64_t fee_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit PROTOBUF_CONSTEXPR Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract Contract;
  typedef Transaction_Result Result;
  typedef Transaction_raw raw;

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kRetFieldNumber = 5,
    kRawDataFieldNumber = 1,
  };
  // repeated bytes signature = 2;
  int signature_size() const;
  private:
  int _internal_signature_size() const;
  public:
  void clear_signature();
  const std::string& signature(int index) const;
  std::string* mutable_signature(int index);
  void set_signature(int index, const std::string& value);
  void set_signature(int index, std::string&& value);
  void set_signature(int index, const char* value);
  void set_signature(int index, const void* value, size_t size);
  std::string* add_signature();
  void add_signature(const std::string& value);
  void add_signature(std::string&& value);
  void add_signature(const char* value);
  void add_signature(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signature();
  private:
  const std::string& _internal_signature(int index) const;
  std::string* _internal_add_signature();
  public:

  // repeated .protocol.Transaction.Result ret = 5;
  int ret_size() const;
  private:
  int _internal_ret_size() const;
  public:
  void clear_ret();
  ::protocol::Transaction_Result* mutable_ret(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >*
      mutable_ret();
  private:
  const ::protocol::Transaction_Result& _internal_ret(int index) const;
  ::protocol::Transaction_Result* _internal_add_ret();
  public:
  const ::protocol::Transaction_Result& ret(int index) const;
  ::protocol::Transaction_Result* add_ret();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >&
      ret() const;

  // .protocol.Transaction.raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::Transaction_raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::Transaction_raw* release_raw_data();
  ::protocol::Transaction_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::Transaction_raw* raw_data);
  private:
  const ::protocol::Transaction_raw& _internal_raw_data() const;
  ::protocol::Transaction_raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::Transaction_raw* raw_data);
  ::protocol::Transaction_raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signature_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result > ret_;
    ::protocol::Transaction_raw* raw_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader_raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader.raw) */ {
 public:
  inline BlockHeader_raw() : BlockHeader_raw(nullptr) {}
  ~BlockHeader_raw() override;
  explicit PROTOBUF_CONSTEXPR BlockHeader_raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader_raw(const BlockHeader_raw& from);
  BlockHeader_raw(BlockHeader_raw&& from) noexcept
    : BlockHeader_raw() {
    *this = ::std::move(from);
  }

  inline BlockHeader_raw& operator=(const BlockHeader_raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader_raw& operator=(BlockHeader_raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader_raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader_raw* internal_default_instance() {
    return reinterpret_cast<const BlockHeader_raw*>(
               &_BlockHeader_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BlockHeader_raw& a, BlockHeader_raw& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader_raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader_raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader_raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHeader_raw>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader_raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockHeader.raw";
  }
  protected:
  explicit BlockHeader_raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxTrieRootFieldNumber = 2,
    kParentHashFieldNumber = 3,
    kNonceFieldNumber = 5,
    kDifficultyFieldNumber = 6,
    kWitnessAddressFieldNumber = 9,
    kAccountStateRootFieldNumber = 11,
    kTimestampFieldNumber = 1,
    kNumberFieldNumber = 7,
    kWitnessIdFieldNumber = 8,
    kVersionFieldNumber = 10,
  };
  // bytes txTrieRoot = 2;
  void clear_txtrieroot();
  const std::string& txtrieroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txtrieroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txtrieroot();
  PROTOBUF_NODISCARD std::string* release_txtrieroot();
  void set_allocated_txtrieroot(std::string* txtrieroot);
  private:
  const std::string& _internal_txtrieroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txtrieroot(const std::string& value);
  std::string* _internal_mutable_txtrieroot();
  public:

  // bytes parentHash = 3;
  void clear_parenthash();
  const std::string& parenthash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parenthash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parenthash();
  PROTOBUF_NODISCARD std::string* release_parenthash();
  void set_allocated_parenthash(std::string* parenthash);
  private:
  const std::string& _internal_parenthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parenthash(const std::string& value);
  std::string* _internal_mutable_parenthash();
  public:

  // bytes nonce = 5;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // bytes difficulty = 6;
  void clear_difficulty();
  const std::string& difficulty() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_difficulty(ArgT0&& arg0, ArgT... args);
  std::string* mutable_difficulty();
  PROTOBUF_NODISCARD std::string* release_difficulty();
  void set_allocated_difficulty(std::string* difficulty);
  private:
  const std::string& _internal_difficulty() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_difficulty(const std::string& value);
  std::string* _internal_mutable_difficulty();
  public:

  // bytes witness_address = 9;
  void clear_witness_address();
  const std::string& witness_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness_address();
  PROTOBUF_NODISCARD std::string* release_witness_address();
  void set_allocated_witness_address(std::string* witness_address);
  private:
  const std::string& _internal_witness_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_address(const std::string& value);
  std::string* _internal_mutable_witness_address();
  public:

  // bytes accountStateRoot = 11;
  void clear_accountstateroot();
  const std::string& accountstateroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountstateroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountstateroot();
  PROTOBUF_NODISCARD std::string* release_accountstateroot();
  void set_allocated_accountstateroot(std::string* accountstateroot);
  private:
  const std::string& _internal_accountstateroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountstateroot(const std::string& value);
  std::string* _internal_mutable_accountstateroot();
  public:

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 number = 7;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // int64 witness_id = 8;
  void clear_witness_id();
  int64_t witness_id() const;
  void set_witness_id(int64_t value);
  private:
  int64_t _internal_witness_id() const;
  void _internal_set_witness_id(int64_t value);
  public:

  // int32 version = 10;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader.raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txtrieroot_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parenthash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr difficulty_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountstateroot_;
    int64_t timestamp_;
    int64_t number_;
    int64_t witness_id_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {}
  ~BlockHeader() override;
  explicit PROTOBUF_CONSTEXPR BlockHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockHeader_raw raw;

  // accessors -------------------------------------------------------

  enum : int {
    kWitnessSignatureFieldNumber = 2,
    kRawDataFieldNumber = 1,
  };
  // bytes witness_signature = 2;
  void clear_witness_signature();
  const std::string& witness_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness_signature();
  PROTOBUF_NODISCARD std::string* release_witness_signature();
  void set_allocated_witness_signature(std::string* witness_signature);
  private:
  const std::string& _internal_witness_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_signature(const std::string& value);
  std::string* _internal_mutable_witness_signature();
  public:

  // .protocol.BlockHeader.raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::BlockHeader_raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::BlockHeader_raw* release_raw_data();
  ::protocol::BlockHeader_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data);
  private:
  const ::protocol::BlockHeader_raw& _internal_raw_data() const;
  ::protocol::BlockHeader_raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::BlockHeader_raw* raw_data);
  ::protocol::BlockHeader_raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_signature_;
    ::protocol::BlockHeader_raw* raw_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountCreateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountCreateContract) */ {
 public:
  inline AccountCreateContract() : AccountCreateContract(nullptr) {}
  ~AccountCreateContract() override;
  explicit PROTOBUF_CONSTEXPR AccountCreateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountCreateContract(const AccountCreateContract& from);
  AccountCreateContract(AccountCreateContract&& from) noexcept
    : AccountCreateContract() {
    *this = ::std::move(from);
  }

  inline AccountCreateContract& operator=(const AccountCreateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountCreateContract& operator=(AccountCreateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountCreateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountCreateContract* internal_default_instance() {
    return reinterpret_cast<const AccountCreateContract*>(
               &_AccountCreateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AccountCreateContract& a, AccountCreateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountCreateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountCreateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountCreateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountCreateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountCreateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountCreateContract";
  }
  protected:
  explicit AccountCreateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kAccountAddressFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes account_address = 2;
  void clear_account_address();
  const std::string& account_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* account_address);
  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(const std::string& value);
  std::string* _internal_mutable_account_address();
  public:

  // .protocol.AccountType type = 3;
  void clear_type();
  ::protocol::AccountType type() const;
  void set_type(::protocol::AccountType value);
  private:
  ::protocol::AccountType _internal_type() const;
  void _internal_set_type(::protocol::AccountType value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountCreateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountUpdateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountUpdateContract) */ {
 public:
  inline AccountUpdateContract() : AccountUpdateContract(nullptr) {}
  ~AccountUpdateContract() override;
  explicit PROTOBUF_CONSTEXPR AccountUpdateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountUpdateContract(const AccountUpdateContract& from);
  AccountUpdateContract(AccountUpdateContract&& from) noexcept
    : AccountUpdateContract() {
    *this = ::std::move(from);
  }

  inline AccountUpdateContract& operator=(const AccountUpdateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountUpdateContract& operator=(AccountUpdateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountUpdateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountUpdateContract* internal_default_instance() {
    return reinterpret_cast<const AccountUpdateContract*>(
               &_AccountUpdateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AccountUpdateContract& a, AccountUpdateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountUpdateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountUpdateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountUpdateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountUpdateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountUpdateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountUpdateContract";
  }
  protected:
  explicit AccountUpdateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
  };
  // bytes account_name = 1;
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // bytes owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountUpdateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SetAccountIdContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SetAccountIdContract) */ {
 public:
  inline SetAccountIdContract() : SetAccountIdContract(nullptr) {}
  ~SetAccountIdContract() override;
  explicit PROTOBUF_CONSTEXPR SetAccountIdContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAccountIdContract(const SetAccountIdContract& from);
  SetAccountIdContract(SetAccountIdContract&& from) noexcept
    : SetAccountIdContract() {
    *this = ::std::move(from);
  }

  inline SetAccountIdContract& operator=(const SetAccountIdContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAccountIdContract& operator=(SetAccountIdContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAccountIdContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAccountIdContract* internal_default_instance() {
    return reinterpret_cast<const SetAccountIdContract*>(
               &_SetAccountIdContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetAccountIdContract& a, SetAccountIdContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAccountIdContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAccountIdContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAccountIdContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAccountIdContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAccountIdContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SetAccountIdContract";
  }
  protected:
  explicit SetAccountIdContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
  };
  // bytes account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // bytes owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.SetAccountIdContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountPermissionUpdateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountPermissionUpdateContract) */ {
 public:
  inline AccountPermissionUpdateContract() : AccountPermissionUpdateContract(nullptr) {}
  ~AccountPermissionUpdateContract() override;
  explicit PROTOBUF_CONSTEXPR AccountPermissionUpdateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountPermissionUpdateContract(const AccountPermissionUpdateContract& from);
  AccountPermissionUpdateContract(AccountPermissionUpdateContract&& from) noexcept
    : AccountPermissionUpdateContract() {
    *this = ::std::move(from);
  }

  inline AccountPermissionUpdateContract& operator=(const AccountPermissionUpdateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountPermissionUpdateContract& operator=(AccountPermissionUpdateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountPermissionUpdateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountPermissionUpdateContract* internal_default_instance() {
    return reinterpret_cast<const AccountPermissionUpdateContract*>(
               &_AccountPermissionUpdateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AccountPermissionUpdateContract& a, AccountPermissionUpdateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountPermissionUpdateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountPermissionUpdateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountPermissionUpdateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountPermissionUpdateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountPermissionUpdateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountPermissionUpdateContract";
  }
  protected:
  explicit AccountPermissionUpdateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivesFieldNumber = 4,
    kOwnerAddressFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kWitnessFieldNumber = 3,
  };
  // repeated .protocol.Permission actives = 4;
  int actives_size() const;
  private:
  int _internal_actives_size() const;
  public:
  void clear_actives();
  ::protocol::Permission* mutable_actives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >*
      mutable_actives();
  private:
  const ::protocol::Permission& _internal_actives(int index) const;
  ::protocol::Permission* _internal_add_actives();
  public:
  const ::protocol::Permission& actives(int index) const;
  ::protocol::Permission* add_actives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >&
      actives() const;

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // .protocol.Permission owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::protocol::Permission& owner() const;
  PROTOBUF_NODISCARD ::protocol::Permission* release_owner();
  ::protocol::Permission* mutable_owner();
  void set_allocated_owner(::protocol::Permission* owner);
  private:
  const ::protocol::Permission& _internal_owner() const;
  ::protocol::Permission* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::protocol::Permission* owner);
  ::protocol::Permission* unsafe_arena_release_owner();

  // .protocol.Permission witness = 3;
  bool has_witness() const;
  private:
  bool _internal_has_witness() const;
  public:
  void clear_witness();
  const ::protocol::Permission& witness() const;
  PROTOBUF_NODISCARD ::protocol::Permission* release_witness();
  ::protocol::Permission* mutable_witness();
  void set_allocated_witness(::protocol::Permission* witness);
  private:
  const ::protocol::Permission& _internal_witness() const;
  ::protocol::Permission* _internal_mutable_witness();
  public:
  void unsafe_arena_set_allocated_witness(
      ::protocol::Permission* witness);
  ::protocol::Permission* unsafe_arena_release_witness();

  // @@protoc_insertion_point(class_scope:protocol.AccountPermissionUpdateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission > actives_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::protocol::Permission* owner_;
    ::protocol::Permission* witness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AssetIssueContract_FrozenSupply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AssetIssueContract.FrozenSupply) */ {
 public:
  inline AssetIssueContract_FrozenSupply() : AssetIssueContract_FrozenSupply(nullptr) {}
  ~AssetIssueContract_FrozenSupply() override;
  explicit PROTOBUF_CONSTEXPR AssetIssueContract_FrozenSupply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetIssueContract_FrozenSupply(const AssetIssueContract_FrozenSupply& from);
  AssetIssueContract_FrozenSupply(AssetIssueContract_FrozenSupply&& from) noexcept
    : AssetIssueContract_FrozenSupply() {
    *this = ::std::move(from);
  }

  inline AssetIssueContract_FrozenSupply& operator=(const AssetIssueContract_FrozenSupply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetIssueContract_FrozenSupply& operator=(AssetIssueContract_FrozenSupply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetIssueContract_FrozenSupply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetIssueContract_FrozenSupply* internal_default_instance() {
    return reinterpret_cast<const AssetIssueContract_FrozenSupply*>(
               &_AssetIssueContract_FrozenSupply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AssetIssueContract_FrozenSupply& a, AssetIssueContract_FrozenSupply& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetIssueContract_FrozenSupply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetIssueContract_FrozenSupply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetIssueContract_FrozenSupply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetIssueContract_FrozenSupply>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetIssueContract_FrozenSupply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AssetIssueContract.FrozenSupply";
  }
  protected:
  explicit AssetIssueContract_FrozenSupply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrozenAmountFieldNumber = 1,
    kFrozenDaysFieldNumber = 2,
  };
  // int64 frozen_amount = 1;
  void clear_frozen_amount();
  int64_t frozen_amount() const;
  void set_frozen_amount(int64_t value);
  private:
  int64_t _internal_frozen_amount() const;
  void _internal_set_frozen_amount(int64_t value);
  public:

  // int64 frozen_days = 2;
  void clear_frozen_days();
  int64_t frozen_days() const;
  void set_frozen_days(int64_t value);
  private:
  int64_t _internal_frozen_days() const;
  void _internal_set_frozen_days(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AssetIssueContract.FrozenSupply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t frozen_amount_;
    int64_t frozen_days_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AssetIssueContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AssetIssueContract) */ {
 public:
  inline AssetIssueContract() : AssetIssueContract(nullptr) {}
  ~AssetIssueContract() override;
  explicit PROTOBUF_CONSTEXPR AssetIssueContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetIssueContract(const AssetIssueContract& from);
  AssetIssueContract(AssetIssueContract&& from) noexcept
    : AssetIssueContract() {
    *this = ::std::move(from);
  }

  inline AssetIssueContract& operator=(const AssetIssueContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetIssueContract& operator=(AssetIssueContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetIssueContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetIssueContract* internal_default_instance() {
    return reinterpret_cast<const AssetIssueContract*>(
               &_AssetIssueContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AssetIssueContract& a, AssetIssueContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetIssueContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetIssueContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetIssueContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetIssueContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetIssueContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AssetIssueContract";
  }
  protected:
  explicit AssetIssueContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AssetIssueContract_FrozenSupply FrozenSupply;

  // accessors -------------------------------------------------------

  enum : int {
    kFrozenSupplyFieldNumber = 5,
    kOwnerAddressFieldNumber = 1,
    kNameFieldNumber = 2,
    kAbbrFieldNumber = 3,
    kDescriptionFieldNumber = 20,
    kUrlFieldNumber = 21,
    kIdFieldNumber = 41,
    kTotalSupplyFieldNumber = 4,
    kTrxNumFieldNumber = 6,
    kPrecisionFieldNumber = 7,
    kStartTimeFieldNumber = 9,
    kEndTimeFieldNumber = 10,
    kOrderFieldNumber = 11,
    kNumFieldNumber = 8,
    kVoteScoreFieldNumber = 16,
    kFreeAssetNetLimitFieldNumber = 22,
    kPublicFreeAssetNetLimitFieldNumber = 23,
    kPublicFreeAssetNetUsageFieldNumber = 24,
    kPublicLatestFreeNetTimeFieldNumber = 25,
  };
  // repeated .protocol.AssetIssueContract.FrozenSupply frozen_supply = 5;
  int frozen_supply_size() const;
  private:
  int _internal_frozen_supply_size() const;
  public:
  void clear_frozen_supply();
  ::protocol::AssetIssueContract_FrozenSupply* mutable_frozen_supply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract_FrozenSupply >*
      mutable_frozen_supply();
  private:
  const ::protocol::AssetIssueContract_FrozenSupply& _internal_frozen_supply(int index) const;
  ::protocol::AssetIssueContract_FrozenSupply* _internal_add_frozen_supply();
  public:
  const ::protocol::AssetIssueContract_FrozenSupply& frozen_supply(int index) const;
  ::protocol::AssetIssueContract_FrozenSupply* add_frozen_supply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract_FrozenSupply >&
      frozen_supply() const;

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes abbr = 3;
  void clear_abbr();
  const std::string& abbr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abbr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abbr();
  PROTOBUF_NODISCARD std::string* release_abbr();
  void set_allocated_abbr(std::string* abbr);
  private:
  const std::string& _internal_abbr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abbr(const std::string& value);
  std::string* _internal_mutable_abbr();
  public:

  // bytes description = 20;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes url = 21;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string id = 41;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int64 total_supply = 4;
  void clear_total_supply();
  int64_t total_supply() const;
  void set_total_supply(int64_t value);
  private:
  int64_t _internal_total_supply() const;
  void _internal_set_total_supply(int64_t value);
  public:

  // int32 trx_num = 6;
  void clear_trx_num();
  int32_t trx_num() const;
  void set_trx_num(int32_t value);
  private:
  int32_t _internal_trx_num() const;
  void _internal_set_trx_num(int32_t value);
  public:

  // int32 precision = 7;
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int64 start_time = 9;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int64 end_time = 10;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // int64 order = 11;
  void clear_order();
  int64_t order() const;
  void set_order(int64_t value);
  private:
  int64_t _internal_order() const;
  void _internal_set_order(int64_t value);
  public:

  // int32 num = 8;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // int32 vote_score = 16;
  void clear_vote_score();
  int32_t vote_score() const;
  void set_vote_score(int32_t value);
  private:
  int32_t _internal_vote_score() const;
  void _internal_set_vote_score(int32_t value);
  public:

  // int64 free_asset_net_limit = 22;
  void clear_free_asset_net_limit();
  int64_t free_asset_net_limit() const;
  void set_free_asset_net_limit(int64_t value);
  private:
  int64_t _internal_free_asset_net_limit() const;
  void _internal_set_free_asset_net_limit(int64_t value);
  public:

  // int64 public_free_asset_net_limit = 23;
  void clear_public_free_asset_net_limit();
  int64_t public_free_asset_net_limit() const;
  void set_public_free_asset_net_limit(int64_t value);
  private:
  int64_t _internal_public_free_asset_net_limit() const;
  void _internal_set_public_free_asset_net_limit(int64_t value);
  public:

  // int64 public_free_asset_net_usage = 24;
  void clear_public_free_asset_net_usage();
  int64_t public_free_asset_net_usage() const;
  void set_public_free_asset_net_usage(int64_t value);
  private:
  int64_t _internal_public_free_asset_net_usage() const;
  void _internal_set_public_free_asset_net_usage(int64_t value);
  public:

  // int64 public_latest_free_net_time = 25;
  void clear_public_latest_free_net_time();
  int64_t public_latest_free_net_time() const;
  void set_public_latest_free_net_time(int64_t value);
  private:
  int64_t _internal_public_latest_free_net_time() const;
  void _internal_set_public_latest_free_net_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AssetIssueContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract_FrozenSupply > frozen_supply_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abbr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int64_t total_supply_;
    int32_t trx_num_;
    int32_t precision_;
    int64_t start_time_;
    int64_t end_time_;
    int64_t order_;
    int32_t num_;
    int32_t vote_score_;
    int64_t free_asset_net_limit_;
    int64_t public_free_asset_net_limit_;
    int64_t public_free_asset_net_usage_;
    int64_t public_latest_free_net_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransferAssetContract) */ {
 public:
  inline TransferAssetContract() : TransferAssetContract(nullptr) {}
  ~TransferAssetContract() override;
  explicit PROTOBUF_CONSTEXPR TransferAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferAssetContract(const TransferAssetContract& from);
  TransferAssetContract(TransferAssetContract&& from) noexcept
    : TransferAssetContract() {
    *this = ::std::move(from);
  }

  inline TransferAssetContract& operator=(const TransferAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferAssetContract& operator=(TransferAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferAssetContract* internal_default_instance() {
    return reinterpret_cast<const TransferAssetContract*>(
               &_TransferAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TransferAssetContract& a, TransferAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferAssetContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransferAssetContract";
  }
  protected:
  explicit TransferAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetNameFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
    kToAddressFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // bytes asset_name = 1;
  void clear_asset_name();
  const std::string& asset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name();
  PROTOBUF_NODISCARD std::string* release_asset_name();
  void set_allocated_asset_name(std::string* asset_name);
  private:
  const std::string& _internal_asset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name(const std::string& value);
  std::string* _internal_mutable_asset_name();
  public:

  // bytes owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes to_address = 3;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // int64 amount = 4;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransferAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnfreezeAssetContract) */ {
 public:
  inline UnfreezeAssetContract() : UnfreezeAssetContract(nullptr) {}
  ~UnfreezeAssetContract() override;
  explicit PROTOBUF_CONSTEXPR UnfreezeAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeAssetContract(const UnfreezeAssetContract& from);
  UnfreezeAssetContract(UnfreezeAssetContract&& from) noexcept
    : UnfreezeAssetContract() {
    *this = ::std::move(from);
  }

  inline UnfreezeAssetContract& operator=(const UnfreezeAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeAssetContract& operator=(UnfreezeAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeAssetContract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeAssetContract*>(
               &_UnfreezeAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UnfreezeAssetContract& a, UnfreezeAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeAssetContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnfreezeAssetContract";
  }
  protected:
  explicit UnfreezeAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnfreezeAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UpdateAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UpdateAssetContract) */ {
 public:
  inline UpdateAssetContract() : UpdateAssetContract(nullptr) {}
  ~UpdateAssetContract() override;
  explicit PROTOBUF_CONSTEXPR UpdateAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAssetContract(const UpdateAssetContract& from);
  UpdateAssetContract(UpdateAssetContract&& from) noexcept
    : UpdateAssetContract() {
    *this = ::std::move(from);
  }

  inline UpdateAssetContract& operator=(const UpdateAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAssetContract& operator=(UpdateAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAssetContract* internal_default_instance() {
    return reinterpret_cast<const UpdateAssetContract*>(
               &_UpdateAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateAssetContract& a, UpdateAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAssetContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UpdateAssetContract";
  }
  protected:
  explicit UpdateAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kUrlFieldNumber = 3,
    kNewLimitFieldNumber = 4,
    kNewPublicLimitFieldNumber = 5,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 new_limit = 4;
  void clear_new_limit();
  int64_t new_limit() const;
  void set_new_limit(int64_t value);
  private:
  int64_t _internal_new_limit() const;
  void _internal_set_new_limit(int64_t value);
  public:

  // int64 new_public_limit = 5;
  void clear_new_public_limit();
  int64_t new_public_limit() const;
  void set_new_public_limit(int64_t value);
  private:
  int64_t _internal_new_public_limit() const;
  void _internal_set_new_public_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UpdateAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    int64_t new_limit_;
    int64_t new_public_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ParticipateAssetIssueContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ParticipateAssetIssueContract) */ {
 public:
  inline ParticipateAssetIssueContract() : ParticipateAssetIssueContract(nullptr) {}
  ~ParticipateAssetIssueContract() override;
  explicit PROTOBUF_CONSTEXPR ParticipateAssetIssueContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipateAssetIssueContract(const ParticipateAssetIssueContract& from);
  ParticipateAssetIssueContract(ParticipateAssetIssueContract&& from) noexcept
    : ParticipateAssetIssueContract() {
    *this = ::std::move(from);
  }

  inline ParticipateAssetIssueContract& operator=(const ParticipateAssetIssueContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipateAssetIssueContract& operator=(ParticipateAssetIssueContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipateAssetIssueContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipateAssetIssueContract* internal_default_instance() {
    return reinterpret_cast<const ParticipateAssetIssueContract*>(
               &_ParticipateAssetIssueContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ParticipateAssetIssueContract& a, ParticipateAssetIssueContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipateAssetIssueContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipateAssetIssueContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipateAssetIssueContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipateAssetIssueContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipateAssetIssueContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ParticipateAssetIssueContract";
  }
  protected:
  explicit ParticipateAssetIssueContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAssetNameFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes to_address = 2;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // bytes asset_name = 3;
  void clear_asset_name();
  const std::string& asset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name();
  PROTOBUF_NODISCARD std::string* release_asset_name();
  void set_allocated_asset_name(std::string* asset_name);
  private:
  const std::string& _internal_asset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name(const std::string& value);
  std::string* _internal_mutable_asset_name();
  public:

  // int64 amount = 4;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ParticipateAssetIssueContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class FreezeBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.FreezeBalanceContract) */ {
 public:
  inline FreezeBalanceContract() : FreezeBalanceContract(nullptr) {}
  ~FreezeBalanceContract() override;
  explicit PROTOBUF_CONSTEXPR FreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeBalanceContract(const FreezeBalanceContract& from);
  FreezeBalanceContract(FreezeBalanceContract&& from) noexcept
    : FreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline FreezeBalanceContract& operator=(const FreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeBalanceContract& operator=(FreezeBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const FreezeBalanceContract*>(
               &_FreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FreezeBalanceContract& a, FreezeBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeBalanceContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreezeBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.FreezeBalanceContract";
  }
  protected:
  explicit FreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kReceiverAddressFieldNumber = 15,
    kFrozenBalanceFieldNumber = 2,
    kFrozenDurationFieldNumber = 3,
    kResourceFieldNumber = 10,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes receiver_address = 15;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 frozen_balance = 2;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // int64 frozen_duration = 3;
  void clear_frozen_duration();
  int64_t frozen_duration() const;
  void set_frozen_duration(int64_t value);
  private:
  int64_t _internal_frozen_duration() const;
  void _internal_set_frozen_duration(int64_t value);
  public:

  // .protocol.ResourceCode resource = 10;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.FreezeBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
    int64_t frozen_balance_;
    int64_t frozen_duration_;
    int resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnfreezeBalanceContract) */ {
 public:
  inline UnfreezeBalanceContract() : UnfreezeBalanceContract(nullptr) {}
  ~UnfreezeBalanceContract() override;
  explicit PROTOBUF_CONSTEXPR UnfreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeBalanceContract(const UnfreezeBalanceContract& from);
  UnfreezeBalanceContract(UnfreezeBalanceContract&& from) noexcept
    : UnfreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline UnfreezeBalanceContract& operator=(const UnfreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeBalanceContract& operator=(UnfreezeBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeBalanceContract*>(
               &_UnfreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UnfreezeBalanceContract& a, UnfreezeBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeBalanceContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnfreezeBalanceContract";
  }
  protected:
  explicit UnfreezeBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kReceiverAddressFieldNumber = 15,
    kResourceFieldNumber = 10,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes receiver_address = 15;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // .protocol.ResourceCode resource = 10;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnfreezeBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
    int resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class WithdrawBalanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.WithdrawBalanceContract) */ {
 public:
  inline WithdrawBalanceContract() : WithdrawBalanceContract(nullptr) {}
  ~WithdrawBalanceContract() override;
  explicit PROTOBUF_CONSTEXPR WithdrawBalanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WithdrawBalanceContract(const WithdrawBalanceContract& from);
  WithdrawBalanceContract(WithdrawBalanceContract&& from) noexcept
    : WithdrawBalanceContract() {
    *this = ::std::move(from);
  }

  inline WithdrawBalanceContract& operator=(const WithdrawBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithdrawBalanceContract& operator=(WithdrawBalanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithdrawBalanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WithdrawBalanceContract* internal_default_instance() {
    return reinterpret_cast<const WithdrawBalanceContract*>(
               &_WithdrawBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WithdrawBalanceContract& a, WithdrawBalanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WithdrawBalanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithdrawBalanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithdrawBalanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WithdrawBalanceContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WithdrawBalanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.WithdrawBalanceContract";
  }
  protected:
  explicit WithdrawBalanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.WithdrawBalanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransferContract) */ {
 public:
  inline TransferContract() : TransferContract(nullptr) {}
  ~TransferContract() override;
  explicit PROTOBUF_CONSTEXPR TransferContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferContract(const TransferContract& from);
  TransferContract(TransferContract&& from) noexcept
    : TransferContract() {
    *this = ::std::move(from);
  }

  inline TransferContract& operator=(const TransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferContract& operator=(TransferContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferContract* internal_default_instance() {
    return reinterpret_cast<const TransferContract*>(
               &_TransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TransferContract& a, TransferContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransferContract";
  }
  protected:
  explicit TransferContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes to_address = 2;
  void clear_to_address();
  const std::string& to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* to_address);
  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(const std::string& value);
  std::string* _internal_mutable_to_address();
  public:

  // int64 amount = 3;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransferContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransactionBalanceTrace_Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionBalanceTrace.Operation) */ {
 public:
  inline TransactionBalanceTrace_Operation() : TransactionBalanceTrace_Operation(nullptr) {}
  ~TransactionBalanceTrace_Operation() override;
  explicit PROTOBUF_CONSTEXPR TransactionBalanceTrace_Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionBalanceTrace_Operation(const TransactionBalanceTrace_Operation& from);
  TransactionBalanceTrace_Operation(TransactionBalanceTrace_Operation&& from) noexcept
    : TransactionBalanceTrace_Operation() {
    *this = ::std::move(from);
  }

  inline TransactionBalanceTrace_Operation& operator=(const TransactionBalanceTrace_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionBalanceTrace_Operation& operator=(TransactionBalanceTrace_Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionBalanceTrace_Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionBalanceTrace_Operation* internal_default_instance() {
    return reinterpret_cast<const TransactionBalanceTrace_Operation*>(
               &_TransactionBalanceTrace_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TransactionBalanceTrace_Operation& a, TransactionBalanceTrace_Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionBalanceTrace_Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionBalanceTrace_Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionBalanceTrace_Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionBalanceTrace_Operation>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionBalanceTrace_Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionBalanceTrace.Operation";
  }
  protected:
  explicit TransactionBalanceTrace_Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kOperationIdentifierFieldNumber = 1,
    kAmountFieldNumber = 3,
  };
  // bytes address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int64 operation_identifier = 1;
  void clear_operation_identifier();
  int64_t operation_identifier() const;
  void set_operation_identifier(int64_t value);
  private:
  int64_t _internal_operation_identifier() const;
  void _internal_set_operation_identifier(int64_t value);
  public:

  // int64 amount = 3;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionBalanceTrace.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int64_t operation_identifier_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransactionBalanceTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionBalanceTrace) */ {
 public:
  inline TransactionBalanceTrace() : TransactionBalanceTrace(nullptr) {}
  ~TransactionBalanceTrace() override;
  explicit PROTOBUF_CONSTEXPR TransactionBalanceTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionBalanceTrace(const TransactionBalanceTrace& from);
  TransactionBalanceTrace(TransactionBalanceTrace&& from) noexcept
    : TransactionBalanceTrace() {
    *this = ::std::move(from);
  }

  inline TransactionBalanceTrace& operator=(const TransactionBalanceTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionBalanceTrace& operator=(TransactionBalanceTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionBalanceTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionBalanceTrace* internal_default_instance() {
    return reinterpret_cast<const TransactionBalanceTrace*>(
               &_TransactionBalanceTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TransactionBalanceTrace& a, TransactionBalanceTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionBalanceTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionBalanceTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionBalanceTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionBalanceTrace>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionBalanceTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionBalanceTrace";
  }
  protected:
  explicit TransactionBalanceTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionBalanceTrace_Operation Operation;

  // accessors -------------------------------------------------------

  enum : int {
    kOperationFieldNumber = 2,
    kTransactionIdentifierFieldNumber = 1,
    kTypeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // repeated .protocol.TransactionBalanceTrace.Operation operation = 2;
  int operation_size() const;
  private:
  int _internal_operation_size() const;
  public:
  void clear_operation();
  ::protocol::TransactionBalanceTrace_Operation* mutable_operation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace_Operation >*
      mutable_operation();
  private:
  const ::protocol::TransactionBalanceTrace_Operation& _internal_operation(int index) const;
  ::protocol::TransactionBalanceTrace_Operation* _internal_add_operation();
  public:
  const ::protocol::TransactionBalanceTrace_Operation& operation(int index) const;
  ::protocol::TransactionBalanceTrace_Operation* add_operation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace_Operation >&
      operation() const;

  // bytes transaction_identifier = 1;
  void clear_transaction_identifier();
  const std::string& transaction_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_identifier();
  PROTOBUF_NODISCARD std::string* release_transaction_identifier();
  void set_allocated_transaction_identifier(std::string* transaction_identifier);
  private:
  const std::string& _internal_transaction_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_identifier(const std::string& value);
  std::string* _internal_mutable_transaction_identifier();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string status = 4;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionBalanceTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace_Operation > operation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_identifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockBalanceTrace_BlockIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockBalanceTrace.BlockIdentifier) */ {
 public:
  inline BlockBalanceTrace_BlockIdentifier() : BlockBalanceTrace_BlockIdentifier(nullptr) {}
  ~BlockBalanceTrace_BlockIdentifier() override;
  explicit PROTOBUF_CONSTEXPR BlockBalanceTrace_BlockIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBalanceTrace_BlockIdentifier(const BlockBalanceTrace_BlockIdentifier& from);
  BlockBalanceTrace_BlockIdentifier(BlockBalanceTrace_BlockIdentifier&& from) noexcept
    : BlockBalanceTrace_BlockIdentifier() {
    *this = ::std::move(from);
  }

  inline BlockBalanceTrace_BlockIdentifier& operator=(const BlockBalanceTrace_BlockIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBalanceTrace_BlockIdentifier& operator=(BlockBalanceTrace_BlockIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBalanceTrace_BlockIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBalanceTrace_BlockIdentifier* internal_default_instance() {
    return reinterpret_cast<const BlockBalanceTrace_BlockIdentifier*>(
               &_BlockBalanceTrace_BlockIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(BlockBalanceTrace_BlockIdentifier& a, BlockBalanceTrace_BlockIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBalanceTrace_BlockIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBalanceTrace_BlockIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBalanceTrace_BlockIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBalanceTrace_BlockIdentifier>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBalanceTrace_BlockIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockBalanceTrace.BlockIdentifier";
  }
  protected:
  explicit BlockBalanceTrace_BlockIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 number = 2;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockBalanceTrace.BlockIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    int64_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockBalanceTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockBalanceTrace) */ {
 public:
  inline BlockBalanceTrace() : BlockBalanceTrace(nullptr) {}
  ~BlockBalanceTrace() override;
  explicit PROTOBUF_CONSTEXPR BlockBalanceTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBalanceTrace(const BlockBalanceTrace& from);
  BlockBalanceTrace(BlockBalanceTrace&& from) noexcept
    : BlockBalanceTrace() {
    *this = ::std::move(from);
  }

  inline BlockBalanceTrace& operator=(const BlockBalanceTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBalanceTrace& operator=(BlockBalanceTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBalanceTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBalanceTrace* internal_default_instance() {
    return reinterpret_cast<const BlockBalanceTrace*>(
               &_BlockBalanceTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(BlockBalanceTrace& a, BlockBalanceTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBalanceTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBalanceTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBalanceTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBalanceTrace>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBalanceTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockBalanceTrace";
  }
  protected:
  explicit BlockBalanceTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockBalanceTrace_BlockIdentifier BlockIdentifier;

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionBalanceTraceFieldNumber = 3,
    kBlockIdentifierFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .protocol.TransactionBalanceTrace transaction_balance_trace = 3;
  int transaction_balance_trace_size() const;
  private:
  int _internal_transaction_balance_trace_size() const;
  public:
  void clear_transaction_balance_trace();
  ::protocol::TransactionBalanceTrace* mutable_transaction_balance_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace >*
      mutable_transaction_balance_trace();
  private:
  const ::protocol::TransactionBalanceTrace& _internal_transaction_balance_trace(int index) const;
  ::protocol::TransactionBalanceTrace* _internal_add_transaction_balance_trace();
  public:
  const ::protocol::TransactionBalanceTrace& transaction_balance_trace(int index) const;
  ::protocol::TransactionBalanceTrace* add_transaction_balance_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace >&
      transaction_balance_trace() const;

  // .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 1;
  bool has_block_identifier() const;
  private:
  bool _internal_has_block_identifier() const;
  public:
  void clear_block_identifier();
  const ::protocol::BlockBalanceTrace_BlockIdentifier& block_identifier() const;
  PROTOBUF_NODISCARD ::protocol::BlockBalanceTrace_BlockIdentifier* release_block_identifier();
  ::protocol::BlockBalanceTrace_BlockIdentifier* mutable_block_identifier();
  void set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  private:
  const ::protocol::BlockBalanceTrace_BlockIdentifier& _internal_block_identifier() const;
  ::protocol::BlockBalanceTrace_BlockIdentifier* _internal_mutable_block_identifier();
  public:
  void unsafe_arena_set_allocated_block_identifier(
      ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  ::protocol::BlockBalanceTrace_BlockIdentifier* unsafe_arena_release_block_identifier();

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockBalanceTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace > transaction_balance_trace_;
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountTrace) */ {
 public:
  inline AccountTrace() : AccountTrace(nullptr) {}
  ~AccountTrace() override;
  explicit PROTOBUF_CONSTEXPR AccountTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountTrace(const AccountTrace& from);
  AccountTrace(AccountTrace&& from) noexcept
    : AccountTrace() {
    *this = ::std::move(from);
  }

  inline AccountTrace& operator=(const AccountTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountTrace& operator=(AccountTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountTrace* internal_default_instance() {
    return reinterpret_cast<const AccountTrace*>(
               &_AccountTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AccountTrace& a, AccountTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountTrace>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountTrace";
  }
  protected:
  explicit AccountTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 1,
    kPlaceholderFieldNumber = 99,
  };
  // int64 balance = 1;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // int64 placeholder = 99;
  void clear_placeholder();
  int64_t placeholder() const;
  void set_placeholder(int64_t value);
  private:
  int64_t _internal_placeholder() const;
  void _internal_set_placeholder(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t balance_;
    int64_t placeholder_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountIdentifier) */ {
 public:
  inline AccountIdentifier() : AccountIdentifier(nullptr) {}
  ~AccountIdentifier() override;
  explicit PROTOBUF_CONSTEXPR AccountIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountIdentifier(const AccountIdentifier& from);
  AccountIdentifier(AccountIdentifier&& from) noexcept
    : AccountIdentifier() {
    *this = ::std::move(from);
  }

  inline AccountIdentifier& operator=(const AccountIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountIdentifier& operator=(AccountIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountIdentifier* internal_default_instance() {
    return reinterpret_cast<const AccountIdentifier*>(
               &_AccountIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AccountIdentifier& a, AccountIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountIdentifier>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountIdentifier";
  }
  protected:
  explicit AccountIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountBalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountBalanceRequest) */ {
 public:
  inline AccountBalanceRequest() : AccountBalanceRequest(nullptr) {}
  ~AccountBalanceRequest() override;
  explicit PROTOBUF_CONSTEXPR AccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountBalanceRequest(const AccountBalanceRequest& from);
  AccountBalanceRequest(AccountBalanceRequest&& from) noexcept
    : AccountBalanceRequest() {
    *this = ::std::move(from);
  }

  inline AccountBalanceRequest& operator=(const AccountBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountBalanceRequest& operator=(AccountBalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountBalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const AccountBalanceRequest*>(
               &_AccountBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AccountBalanceRequest& a, AccountBalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountBalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountBalanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountBalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountBalanceRequest>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountBalanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountBalanceRequest";
  }
  protected:
  explicit AccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdentifierFieldNumber = 1,
    kBlockIdentifierFieldNumber = 2,
  };
  // .protocol.AccountIdentifier account_identifier = 1;
  bool has_account_identifier() const;
  private:
  bool _internal_has_account_identifier() const;
  public:
  void clear_account_identifier();
  const ::protocol::AccountIdentifier& account_identifier() const;
  PROTOBUF_NODISCARD ::protocol::AccountIdentifier* release_account_identifier();
  ::protocol::AccountIdentifier* mutable_account_identifier();
  void set_allocated_account_identifier(::protocol::AccountIdentifier* account_identifier);
  private:
  const ::protocol::AccountIdentifier& _internal_account_identifier() const;
  ::protocol::AccountIdentifier* _internal_mutable_account_identifier();
  public:
  void unsafe_arena_set_allocated_account_identifier(
      ::protocol::AccountIdentifier* account_identifier);
  ::protocol::AccountIdentifier* unsafe_arena_release_account_identifier();

  // .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 2;
  bool has_block_identifier() const;
  private:
  bool _internal_has_block_identifier() const;
  public:
  void clear_block_identifier();
  const ::protocol::BlockBalanceTrace_BlockIdentifier& block_identifier() const;
  PROTOBUF_NODISCARD ::protocol::BlockBalanceTrace_BlockIdentifier* release_block_identifier();
  ::protocol::BlockBalanceTrace_BlockIdentifier* mutable_block_identifier();
  void set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  private:
  const ::protocol::BlockBalanceTrace_BlockIdentifier& _internal_block_identifier() const;
  ::protocol::BlockBalanceTrace_BlockIdentifier* _internal_mutable_block_identifier();
  public:
  void unsafe_arena_set_allocated_block_identifier(
      ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  ::protocol::BlockBalanceTrace_BlockIdentifier* unsafe_arena_release_block_identifier();

  // @@protoc_insertion_point(class_scope:protocol.AccountBalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::protocol::AccountIdentifier* account_identifier_;
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AccountBalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountBalanceResponse) */ {
 public:
  inline AccountBalanceResponse() : AccountBalanceResponse(nullptr) {}
  ~AccountBalanceResponse() override;
  explicit PROTOBUF_CONSTEXPR AccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountBalanceResponse(const AccountBalanceResponse& from);
  AccountBalanceResponse(AccountBalanceResponse&& from) noexcept
    : AccountBalanceResponse() {
    *this = ::std::move(from);
  }

  inline AccountBalanceResponse& operator=(const AccountBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountBalanceResponse& operator=(AccountBalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountBalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const AccountBalanceResponse*>(
               &_AccountBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AccountBalanceResponse& a, AccountBalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountBalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountBalanceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountBalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountBalanceResponse>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountBalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountBalanceResponse";
  }
  protected:
  explicit AccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdentifierFieldNumber = 2,
    kBalanceFieldNumber = 1,
  };
  // .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 2;
  bool has_block_identifier() const;
  private:
  bool _internal_has_block_identifier() const;
  public:
  void clear_block_identifier();
  const ::protocol::BlockBalanceTrace_BlockIdentifier& block_identifier() const;
  PROTOBUF_NODISCARD ::protocol::BlockBalanceTrace_BlockIdentifier* release_block_identifier();
  ::protocol::BlockBalanceTrace_BlockIdentifier* mutable_block_identifier();
  void set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  private:
  const ::protocol::BlockBalanceTrace_BlockIdentifier& _internal_block_identifier() const;
  ::protocol::BlockBalanceTrace_BlockIdentifier* _internal_mutable_block_identifier();
  public:
  void unsafe_arena_set_allocated_block_identifier(
      ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier);
  ::protocol::BlockBalanceTrace_BlockIdentifier* unsafe_arena_release_block_identifier();

  // int64 balance = 1;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountBalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier_;
    int64_t balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class FreezeBalanceV2Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.FreezeBalanceV2Contract) */ {
 public:
  inline FreezeBalanceV2Contract() : FreezeBalanceV2Contract(nullptr) {}
  ~FreezeBalanceV2Contract() override;
  explicit PROTOBUF_CONSTEXPR FreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreezeBalanceV2Contract(const FreezeBalanceV2Contract& from);
  FreezeBalanceV2Contract(FreezeBalanceV2Contract&& from) noexcept
    : FreezeBalanceV2Contract() {
    *this = ::std::move(from);
  }

  inline FreezeBalanceV2Contract& operator=(const FreezeBalanceV2Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreezeBalanceV2Contract& operator=(FreezeBalanceV2Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreezeBalanceV2Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreezeBalanceV2Contract* internal_default_instance() {
    return reinterpret_cast<const FreezeBalanceV2Contract*>(
               &_FreezeBalanceV2Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FreezeBalanceV2Contract& a, FreezeBalanceV2Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(FreezeBalanceV2Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreezeBalanceV2Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreezeBalanceV2Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreezeBalanceV2Contract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreezeBalanceV2Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.FreezeBalanceV2Contract";
  }
  protected:
  explicit FreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kFrozenBalanceFieldNumber = 2,
    kResourceFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 frozen_balance = 2;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // .protocol.ResourceCode resource = 3;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.FreezeBalanceV2Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t frozen_balance_;
    int resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UnfreezeBalanceV2Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnfreezeBalanceV2Contract) */ {
 public:
  inline UnfreezeBalanceV2Contract() : UnfreezeBalanceV2Contract(nullptr) {}
  ~UnfreezeBalanceV2Contract() override;
  explicit PROTOBUF_CONSTEXPR UnfreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnfreezeBalanceV2Contract(const UnfreezeBalanceV2Contract& from);
  UnfreezeBalanceV2Contract(UnfreezeBalanceV2Contract&& from) noexcept
    : UnfreezeBalanceV2Contract() {
    *this = ::std::move(from);
  }

  inline UnfreezeBalanceV2Contract& operator=(const UnfreezeBalanceV2Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnfreezeBalanceV2Contract& operator=(UnfreezeBalanceV2Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnfreezeBalanceV2Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnfreezeBalanceV2Contract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeBalanceV2Contract*>(
               &_UnfreezeBalanceV2Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UnfreezeBalanceV2Contract& a, UnfreezeBalanceV2Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnfreezeBalanceV2Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnfreezeBalanceV2Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnfreezeBalanceV2Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnfreezeBalanceV2Contract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeBalanceV2Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnfreezeBalanceV2Contract";
  }
  protected:
  explicit UnfreezeBalanceV2Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kUnfreezeBalanceFieldNumber = 2,
    kResourceFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 unfreeze_balance = 2;
  void clear_unfreeze_balance();
  int64_t unfreeze_balance() const;
  void set_unfreeze_balance(int64_t value);
  private:
  int64_t _internal_unfreeze_balance() const;
  void _internal_set_unfreeze_balance(int64_t value);
  public:

  // .protocol.ResourceCode resource = 3;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnfreezeBalanceV2Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t unfreeze_balance_;
    int resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class WithdrawExpireUnfreezeContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.WithdrawExpireUnfreezeContract) */ {
 public:
  inline WithdrawExpireUnfreezeContract() : WithdrawExpireUnfreezeContract(nullptr) {}
  ~WithdrawExpireUnfreezeContract() override;
  explicit PROTOBUF_CONSTEXPR WithdrawExpireUnfreezeContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WithdrawExpireUnfreezeContract(const WithdrawExpireUnfreezeContract& from);
  WithdrawExpireUnfreezeContract(WithdrawExpireUnfreezeContract&& from) noexcept
    : WithdrawExpireUnfreezeContract() {
    *this = ::std::move(from);
  }

  inline WithdrawExpireUnfreezeContract& operator=(const WithdrawExpireUnfreezeContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithdrawExpireUnfreezeContract& operator=(WithdrawExpireUnfreezeContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithdrawExpireUnfreezeContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WithdrawExpireUnfreezeContract* internal_default_instance() {
    return reinterpret_cast<const WithdrawExpireUnfreezeContract*>(
               &_WithdrawExpireUnfreezeContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(WithdrawExpireUnfreezeContract& a, WithdrawExpireUnfreezeContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WithdrawExpireUnfreezeContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithdrawExpireUnfreezeContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithdrawExpireUnfreezeContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WithdrawExpireUnfreezeContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WithdrawExpireUnfreezeContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.WithdrawExpireUnfreezeContract";
  }
  protected:
  explicit WithdrawExpireUnfreezeContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.WithdrawExpireUnfreezeContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class DelegateResourceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DelegateResourceContract) */ {
 public:
  inline DelegateResourceContract() : DelegateResourceContract(nullptr) {}
  ~DelegateResourceContract() override;
  explicit PROTOBUF_CONSTEXPR DelegateResourceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegateResourceContract(const DelegateResourceContract& from);
  DelegateResourceContract(DelegateResourceContract&& from) noexcept
    : DelegateResourceContract() {
    *this = ::std::move(from);
  }

  inline DelegateResourceContract& operator=(const DelegateResourceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegateResourceContract& operator=(DelegateResourceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegateResourceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegateResourceContract* internal_default_instance() {
    return reinterpret_cast<const DelegateResourceContract*>(
               &_DelegateResourceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DelegateResourceContract& a, DelegateResourceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegateResourceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegateResourceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegateResourceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegateResourceContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegateResourceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DelegateResourceContract";
  }
  protected:
  explicit DelegateResourceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kReceiverAddressFieldNumber = 4,
    kBalanceFieldNumber = 3,
    kResourceFieldNumber = 2,
    kLockFieldNumber = 5,
    kLockPeriodFieldNumber = 6,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes receiver_address = 4;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 balance = 3;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // .protocol.ResourceCode resource = 2;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // bool lock = 5;
  void clear_lock();
  bool lock() const;
  void set_lock(bool value);
  private:
  bool _internal_lock() const;
  void _internal_set_lock(bool value);
  public:

  // int64 lock_period = 6;
  void clear_lock_period();
  int64_t lock_period() const;
  void set_lock_period(int64_t value);
  private:
  int64_t _internal_lock_period() const;
  void _internal_set_lock_period(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DelegateResourceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
    int64_t balance_;
    int resource_;
    bool lock_;
    int64_t lock_period_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UnDelegateResourceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnDelegateResourceContract) */ {
 public:
  inline UnDelegateResourceContract() : UnDelegateResourceContract(nullptr) {}
  ~UnDelegateResourceContract() override;
  explicit PROTOBUF_CONSTEXPR UnDelegateResourceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnDelegateResourceContract(const UnDelegateResourceContract& from);
  UnDelegateResourceContract(UnDelegateResourceContract&& from) noexcept
    : UnDelegateResourceContract() {
    *this = ::std::move(from);
  }

  inline UnDelegateResourceContract& operator=(const UnDelegateResourceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnDelegateResourceContract& operator=(UnDelegateResourceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnDelegateResourceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnDelegateResourceContract* internal_default_instance() {
    return reinterpret_cast<const UnDelegateResourceContract*>(
               &_UnDelegateResourceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UnDelegateResourceContract& a, UnDelegateResourceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UnDelegateResourceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnDelegateResourceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnDelegateResourceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnDelegateResourceContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnDelegateResourceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnDelegateResourceContract";
  }
  protected:
  explicit UnDelegateResourceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kReceiverAddressFieldNumber = 4,
    kBalanceFieldNumber = 3,
    kResourceFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes receiver_address = 4;
  void clear_receiver_address();
  const std::string& receiver_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_address();
  PROTOBUF_NODISCARD std::string* release_receiver_address();
  void set_allocated_receiver_address(std::string* receiver_address);
  private:
  const std::string& _internal_receiver_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_address(const std::string& value);
  std::string* _internal_mutable_receiver_address();
  public:

  // int64 balance = 3;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // .protocol.ResourceCode resource = 2;
  void clear_resource();
  ::protocol::ResourceCode resource() const;
  void set_resource(::protocol::ResourceCode value);
  private:
  ::protocol::ResourceCode _internal_resource() const;
  void _internal_set_resource(::protocol::ResourceCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnDelegateResourceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_address_;
    int64_t balance_;
    int resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class CancelAllUnfreezeV2Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CancelAllUnfreezeV2Contract) */ {
 public:
  inline CancelAllUnfreezeV2Contract() : CancelAllUnfreezeV2Contract(nullptr) {}
  ~CancelAllUnfreezeV2Contract() override;
  explicit PROTOBUF_CONSTEXPR CancelAllUnfreezeV2Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelAllUnfreezeV2Contract(const CancelAllUnfreezeV2Contract& from);
  CancelAllUnfreezeV2Contract(CancelAllUnfreezeV2Contract&& from) noexcept
    : CancelAllUnfreezeV2Contract() {
    *this = ::std::move(from);
  }

  inline CancelAllUnfreezeV2Contract& operator=(const CancelAllUnfreezeV2Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAllUnfreezeV2Contract& operator=(CancelAllUnfreezeV2Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelAllUnfreezeV2Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelAllUnfreezeV2Contract* internal_default_instance() {
    return reinterpret_cast<const CancelAllUnfreezeV2Contract*>(
               &_CancelAllUnfreezeV2Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CancelAllUnfreezeV2Contract& a, CancelAllUnfreezeV2Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelAllUnfreezeV2Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelAllUnfreezeV2Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelAllUnfreezeV2Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelAllUnfreezeV2Contract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelAllUnfreezeV2Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CancelAllUnfreezeV2Contract";
  }
  protected:
  explicit CancelAllUnfreezeV2Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.CancelAllUnfreezeV2Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ExchangeCreateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExchangeCreateContract) */ {
 public:
  inline ExchangeCreateContract() : ExchangeCreateContract(nullptr) {}
  ~ExchangeCreateContract() override;
  explicit PROTOBUF_CONSTEXPR ExchangeCreateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeCreateContract(const ExchangeCreateContract& from);
  ExchangeCreateContract(ExchangeCreateContract&& from) noexcept
    : ExchangeCreateContract() {
    *this = ::std::move(from);
  }

  inline ExchangeCreateContract& operator=(const ExchangeCreateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeCreateContract& operator=(ExchangeCreateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeCreateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeCreateContract* internal_default_instance() {
    return reinterpret_cast<const ExchangeCreateContract*>(
               &_ExchangeCreateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ExchangeCreateContract& a, ExchangeCreateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeCreateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeCreateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeCreateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeCreateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeCreateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExchangeCreateContract";
  }
  protected:
  explicit ExchangeCreateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kFirstTokenIdFieldNumber = 2,
    kSecondTokenIdFieldNumber = 4,
    kFirstTokenBalanceFieldNumber = 3,
    kSecondTokenBalanceFieldNumber = 5,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes first_token_id = 2;
  void clear_first_token_id();
  const std::string& first_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_token_id();
  PROTOBUF_NODISCARD std::string* release_first_token_id();
  void set_allocated_first_token_id(std::string* first_token_id);
  private:
  const std::string& _internal_first_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_token_id(const std::string& value);
  std::string* _internal_mutable_first_token_id();
  public:

  // bytes second_token_id = 4;
  void clear_second_token_id();
  const std::string& second_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_second_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_second_token_id();
  PROTOBUF_NODISCARD std::string* release_second_token_id();
  void set_allocated_second_token_id(std::string* second_token_id);
  private:
  const std::string& _internal_second_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_second_token_id(const std::string& value);
  std::string* _internal_mutable_second_token_id();
  public:

  // int64 first_token_balance = 3;
  void clear_first_token_balance();
  int64_t first_token_balance() const;
  void set_first_token_balance(int64_t value);
  private:
  int64_t _internal_first_token_balance() const;
  void _internal_set_first_token_balance(int64_t value);
  public:

  // int64 second_token_balance = 5;
  void clear_second_token_balance();
  int64_t second_token_balance() const;
  void set_second_token_balance(int64_t value);
  private:
  int64_t _internal_second_token_balance() const;
  void _internal_set_second_token_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ExchangeCreateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_token_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr second_token_id_;
    int64_t first_token_balance_;
    int64_t second_token_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ExchangeInjectContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExchangeInjectContract) */ {
 public:
  inline ExchangeInjectContract() : ExchangeInjectContract(nullptr) {}
  ~ExchangeInjectContract() override;
  explicit PROTOBUF_CONSTEXPR ExchangeInjectContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeInjectContract(const ExchangeInjectContract& from);
  ExchangeInjectContract(ExchangeInjectContract&& from) noexcept
    : ExchangeInjectContract() {
    *this = ::std::move(from);
  }

  inline ExchangeInjectContract& operator=(const ExchangeInjectContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeInjectContract& operator=(ExchangeInjectContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeInjectContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeInjectContract* internal_default_instance() {
    return reinterpret_cast<const ExchangeInjectContract*>(
               &_ExchangeInjectContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ExchangeInjectContract& a, ExchangeInjectContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeInjectContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeInjectContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeInjectContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeInjectContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeInjectContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExchangeInjectContract";
  }
  protected:
  explicit ExchangeInjectContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kTokenIdFieldNumber = 3,
    kExchangeIdFieldNumber = 2,
    kQuantFieldNumber = 4,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes token_id = 3;
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // int64 exchange_id = 2;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 quant = 4;
  void clear_quant();
  int64_t quant() const;
  void set_quant(int64_t value);
  private:
  int64_t _internal_quant() const;
  void _internal_set_quant(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ExchangeInjectContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
    int64_t exchange_id_;
    int64_t quant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ExchangeWithdrawContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExchangeWithdrawContract) */ {
 public:
  inline ExchangeWithdrawContract() : ExchangeWithdrawContract(nullptr) {}
  ~ExchangeWithdrawContract() override;
  explicit PROTOBUF_CONSTEXPR ExchangeWithdrawContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeWithdrawContract(const ExchangeWithdrawContract& from);
  ExchangeWithdrawContract(ExchangeWithdrawContract&& from) noexcept
    : ExchangeWithdrawContract() {
    *this = ::std::move(from);
  }

  inline ExchangeWithdrawContract& operator=(const ExchangeWithdrawContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeWithdrawContract& operator=(ExchangeWithdrawContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeWithdrawContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeWithdrawContract* internal_default_instance() {
    return reinterpret_cast<const ExchangeWithdrawContract*>(
               &_ExchangeWithdrawContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ExchangeWithdrawContract& a, ExchangeWithdrawContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeWithdrawContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeWithdrawContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeWithdrawContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeWithdrawContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeWithdrawContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExchangeWithdrawContract";
  }
  protected:
  explicit ExchangeWithdrawContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kTokenIdFieldNumber = 3,
    kExchangeIdFieldNumber = 2,
    kQuantFieldNumber = 4,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes token_id = 3;
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // int64 exchange_id = 2;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 quant = 4;
  void clear_quant();
  int64_t quant() const;
  void set_quant(int64_t value);
  private:
  int64_t _internal_quant() const;
  void _internal_set_quant(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ExchangeWithdrawContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
    int64_t exchange_id_;
    int64_t quant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ExchangeTransactionContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExchangeTransactionContract) */ {
 public:
  inline ExchangeTransactionContract() : ExchangeTransactionContract(nullptr) {}
  ~ExchangeTransactionContract() override;
  explicit PROTOBUF_CONSTEXPR ExchangeTransactionContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeTransactionContract(const ExchangeTransactionContract& from);
  ExchangeTransactionContract(ExchangeTransactionContract&& from) noexcept
    : ExchangeTransactionContract() {
    *this = ::std::move(from);
  }

  inline ExchangeTransactionContract& operator=(const ExchangeTransactionContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeTransactionContract& operator=(ExchangeTransactionContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeTransactionContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeTransactionContract* internal_default_instance() {
    return reinterpret_cast<const ExchangeTransactionContract*>(
               &_ExchangeTransactionContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ExchangeTransactionContract& a, ExchangeTransactionContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeTransactionContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeTransactionContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeTransactionContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeTransactionContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeTransactionContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExchangeTransactionContract";
  }
  protected:
  explicit ExchangeTransactionContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kTokenIdFieldNumber = 3,
    kExchangeIdFieldNumber = 2,
    kQuantFieldNumber = 4,
    kExpectedFieldNumber = 5,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes token_id = 3;
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // int64 exchange_id = 2;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 quant = 4;
  void clear_quant();
  int64_t quant() const;
  void set_quant(int64_t value);
  private:
  int64_t _internal_quant() const;
  void _internal_set_quant(int64_t value);
  public:

  // int64 expected = 5;
  void clear_expected();
  int64_t expected() const;
  void set_expected(int64_t value);
  private:
  int64_t _internal_expected() const;
  void _internal_set_expected(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ExchangeTransactionContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
    int64_t exchange_id_;
    int64_t quant_;
    int64_t expected_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class MarketSellAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketSellAssetContract) */ {
 public:
  inline MarketSellAssetContract() : MarketSellAssetContract(nullptr) {}
  ~MarketSellAssetContract() override;
  explicit PROTOBUF_CONSTEXPR MarketSellAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketSellAssetContract(const MarketSellAssetContract& from);
  MarketSellAssetContract(MarketSellAssetContract&& from) noexcept
    : MarketSellAssetContract() {
    *this = ::std::move(from);
  }

  inline MarketSellAssetContract& operator=(const MarketSellAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketSellAssetContract& operator=(MarketSellAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketSellAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketSellAssetContract* internal_default_instance() {
    return reinterpret_cast<const MarketSellAssetContract*>(
               &_MarketSellAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(MarketSellAssetContract& a, MarketSellAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketSellAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketSellAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketSellAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketSellAssetContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketSellAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketSellAssetContract";
  }
  protected:
  explicit MarketSellAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kSellTokenIdFieldNumber = 2,
    kBuyTokenIdFieldNumber = 4,
    kSellTokenQuantityFieldNumber = 3,
    kBuyTokenQuantityFieldNumber = 5,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes sell_token_id = 2;
  void clear_sell_token_id();
  const std::string& sell_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_token_id();
  PROTOBUF_NODISCARD std::string* release_sell_token_id();
  void set_allocated_sell_token_id(std::string* sell_token_id);
  private:
  const std::string& _internal_sell_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_token_id(const std::string& value);
  std::string* _internal_mutable_sell_token_id();
  public:

  // bytes buy_token_id = 4;
  void clear_buy_token_id();
  const std::string& buy_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_token_id();
  PROTOBUF_NODISCARD std::string* release_buy_token_id();
  void set_allocated_buy_token_id(std::string* buy_token_id);
  private:
  const std::string& _internal_buy_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_token_id(const std::string& value);
  std::string* _internal_mutable_buy_token_id();
  public:

  // int64 sell_token_quantity = 3;
  void clear_sell_token_quantity();
  int64_t sell_token_quantity() const;
  void set_sell_token_quantity(int64_t value);
  private:
  int64_t _internal_sell_token_quantity() const;
  void _internal_set_sell_token_quantity(int64_t value);
  public:

  // int64 buy_token_quantity = 5;
  void clear_buy_token_quantity();
  int64_t buy_token_quantity() const;
  void set_buy_token_quantity(int64_t value);
  private:
  int64_t _internal_buy_token_quantity() const;
  void _internal_set_buy_token_quantity(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketSellAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_token_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_token_id_;
    int64_t sell_token_quantity_;
    int64_t buy_token_quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class MarketCancelOrderContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketCancelOrderContract) */ {
 public:
  inline MarketCancelOrderContract() : MarketCancelOrderContract(nullptr) {}
  ~MarketCancelOrderContract() override;
  explicit PROTOBUF_CONSTEXPR MarketCancelOrderContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketCancelOrderContract(const MarketCancelOrderContract& from);
  MarketCancelOrderContract(MarketCancelOrderContract&& from) noexcept
    : MarketCancelOrderContract() {
    *this = ::std::move(from);
  }

  inline MarketCancelOrderContract& operator=(const MarketCancelOrderContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketCancelOrderContract& operator=(MarketCancelOrderContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketCancelOrderContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketCancelOrderContract* internal_default_instance() {
    return reinterpret_cast<const MarketCancelOrderContract*>(
               &_MarketCancelOrderContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MarketCancelOrderContract& a, MarketCancelOrderContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketCancelOrderContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketCancelOrderContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketCancelOrderContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketCancelOrderContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketCancelOrderContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketCancelOrderContract";
  }
  protected:
  explicit MarketCancelOrderContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kOrderIdFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes order_id = 2;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketCancelOrderContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ProposalApproveContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ProposalApproveContract) */ {
 public:
  inline ProposalApproveContract() : ProposalApproveContract(nullptr) {}
  ~ProposalApproveContract() override;
  explicit PROTOBUF_CONSTEXPR ProposalApproveContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalApproveContract(const ProposalApproveContract& from);
  ProposalApproveContract(ProposalApproveContract&& from) noexcept
    : ProposalApproveContract() {
    *this = ::std::move(from);
  }

  inline ProposalApproveContract& operator=(const ProposalApproveContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalApproveContract& operator=(ProposalApproveContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalApproveContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalApproveContract* internal_default_instance() {
    return reinterpret_cast<const ProposalApproveContract*>(
               &_ProposalApproveContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ProposalApproveContract& a, ProposalApproveContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalApproveContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalApproveContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalApproveContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalApproveContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalApproveContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ProposalApproveContract";
  }
  protected:
  explicit ProposalApproveContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kProposalIdFieldNumber = 2,
    kIsAddApprovalFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 proposal_id = 2;
  void clear_proposal_id();
  int64_t proposal_id() const;
  void set_proposal_id(int64_t value);
  private:
  int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(int64_t value);
  public:

  // bool is_add_approval = 3;
  void clear_is_add_approval();
  bool is_add_approval() const;
  void set_is_add_approval(bool value);
  private:
  bool _internal_is_add_approval() const;
  void _internal_set_is_add_approval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ProposalApproveContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t proposal_id_;
    bool is_add_approval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ProposalCreateContract_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProposalCreateContract_ParametersEntry_DoNotUse, 
    int64_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProposalCreateContract_ParametersEntry_DoNotUse, 
    int64_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  ProposalCreateContract_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProposalCreateContract_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProposalCreateContract_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProposalCreateContract_ParametersEntry_DoNotUse& other);
  static const ProposalCreateContract_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProposalCreateContract_ParametersEntry_DoNotUse*>(&_ProposalCreateContract_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_TronInternal_2eproto;
};

// -------------------------------------------------------------------

class ProposalCreateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ProposalCreateContract) */ {
 public:
  inline ProposalCreateContract() : ProposalCreateContract(nullptr) {}
  ~ProposalCreateContract() override;
  explicit PROTOBUF_CONSTEXPR ProposalCreateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalCreateContract(const ProposalCreateContract& from);
  ProposalCreateContract(ProposalCreateContract&& from) noexcept
    : ProposalCreateContract() {
    *this = ::std::move(from);
  }

  inline ProposalCreateContract& operator=(const ProposalCreateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalCreateContract& operator=(ProposalCreateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalCreateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalCreateContract* internal_default_instance() {
    return reinterpret_cast<const ProposalCreateContract*>(
               &_ProposalCreateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ProposalCreateContract& a, ProposalCreateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalCreateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalCreateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalCreateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalCreateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalCreateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ProposalCreateContract";
  }
  protected:
  explicit ProposalCreateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
  };
  // map<int64, int64> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
      mutable_parameters();

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ProposalCreateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProposalCreateContract_ParametersEntry_DoNotUse,
        int64_t, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ProposalDeleteContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ProposalDeleteContract) */ {
 public:
  inline ProposalDeleteContract() : ProposalDeleteContract(nullptr) {}
  ~ProposalDeleteContract() override;
  explicit PROTOBUF_CONSTEXPR ProposalDeleteContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalDeleteContract(const ProposalDeleteContract& from);
  ProposalDeleteContract(ProposalDeleteContract&& from) noexcept
    : ProposalDeleteContract() {
    *this = ::std::move(from);
  }

  inline ProposalDeleteContract& operator=(const ProposalDeleteContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalDeleteContract& operator=(ProposalDeleteContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalDeleteContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalDeleteContract* internal_default_instance() {
    return reinterpret_cast<const ProposalDeleteContract*>(
               &_ProposalDeleteContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ProposalDeleteContract& a, ProposalDeleteContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalDeleteContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalDeleteContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProposalDeleteContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProposalDeleteContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalDeleteContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ProposalDeleteContract";
  }
  protected:
  explicit ProposalDeleteContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kProposalIdFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 proposal_id = 2;
  void clear_proposal_id();
  int64_t proposal_id() const;
  void set_proposal_id(int64_t value);
  private:
  int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ProposalDeleteContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t proposal_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AuthenticationPath) */ {
 public:
  inline AuthenticationPath() : AuthenticationPath(nullptr) {}
  ~AuthenticationPath() override;
  explicit PROTOBUF_CONSTEXPR AuthenticationPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationPath(const AuthenticationPath& from);
  AuthenticationPath(AuthenticationPath&& from) noexcept
    : AuthenticationPath() {
    *this = ::std::move(from);
  }

  inline AuthenticationPath& operator=(const AuthenticationPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationPath& operator=(AuthenticationPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticationPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationPath* internal_default_instance() {
    return reinterpret_cast<const AuthenticationPath*>(
               &_AuthenticationPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AuthenticationPath& a, AuthenticationPath& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationPath>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticationPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AuthenticationPath";
  }
  protected:
  explicit AuthenticationPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated bool value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  bool _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_value() const;
  void _internal_add_value(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_value();
  public:
  bool value(int index) const;
  void set_value(int index, bool value);
  void add_value(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:protocol.AuthenticationPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class MerklePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MerklePath) */ {
 public:
  inline MerklePath() : MerklePath(nullptr) {}
  ~MerklePath() override;
  explicit PROTOBUF_CONSTEXPR MerklePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MerklePath(const MerklePath& from);
  MerklePath(MerklePath&& from) noexcept
    : MerklePath() {
    *this = ::std::move(from);
  }

  inline MerklePath& operator=(const MerklePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline MerklePath& operator=(MerklePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MerklePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const MerklePath* internal_default_instance() {
    return reinterpret_cast<const MerklePath*>(
               &_MerklePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(MerklePath& a, MerklePath& b) {
    a.Swap(&b);
  }
  inline void Swap(MerklePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MerklePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MerklePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MerklePath>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MerklePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MerklePath";
  }
  protected:
  explicit MerklePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthenticationPathsFieldNumber = 1,
    kIndexFieldNumber = 2,
    kRtFieldNumber = 3,
  };
  // repeated .protocol.AuthenticationPath authentication_paths = 1;
  int authentication_paths_size() const;
  private:
  int _internal_authentication_paths_size() const;
  public:
  void clear_authentication_paths();
  ::protocol::AuthenticationPath* mutable_authentication_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AuthenticationPath >*
      mutable_authentication_paths();
  private:
  const ::protocol::AuthenticationPath& _internal_authentication_paths(int index) const;
  ::protocol::AuthenticationPath* _internal_add_authentication_paths();
  public:
  const ::protocol::AuthenticationPath& authentication_paths(int index) const;
  ::protocol::AuthenticationPath* add_authentication_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AuthenticationPath >&
      authentication_paths() const;

  // repeated bool index = 2;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  bool _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_index() const;
  void _internal_add_index(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_index();
  public:
  bool index(int index) const;
  void set_index(int index, bool value);
  void add_index(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_index();

  // bytes rt = 3;
  void clear_rt();
  const std::string& rt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rt();
  PROTOBUF_NODISCARD std::string* release_rt();
  void set_allocated_rt(std::string* rt);
  private:
  const std::string& _internal_rt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rt(const std::string& value);
  std::string* _internal_mutable_rt();
  public:

  // @@protoc_insertion_point(class_scope:protocol.MerklePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AuthenticationPath > authentication_paths_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class OutputPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.OutputPoint) */ {
 public:
  inline OutputPoint() : OutputPoint(nullptr) {}
  ~OutputPoint() override;
  explicit PROTOBUF_CONSTEXPR OutputPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputPoint(const OutputPoint& from);
  OutputPoint(OutputPoint&& from) noexcept
    : OutputPoint() {
    *this = ::std::move(from);
  }

  inline OutputPoint& operator=(const OutputPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputPoint& operator=(OutputPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputPoint* internal_default_instance() {
    return reinterpret_cast<const OutputPoint*>(
               &_OutputPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(OutputPoint& a, OutputPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputPoint>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.OutputPoint";
  }
  protected:
  explicit OutputPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int32 index = 2;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.OutputPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class OutputPointInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.OutputPointInfo) */ {
 public:
  inline OutputPointInfo() : OutputPointInfo(nullptr) {}
  ~OutputPointInfo() override;
  explicit PROTOBUF_CONSTEXPR OutputPointInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputPointInfo(const OutputPointInfo& from);
  OutputPointInfo(OutputPointInfo&& from) noexcept
    : OutputPointInfo() {
    *this = ::std::move(from);
  }

  inline OutputPointInfo& operator=(const OutputPointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputPointInfo& operator=(OutputPointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputPointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputPointInfo* internal_default_instance() {
    return reinterpret_cast<const OutputPointInfo*>(
               &_OutputPointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(OutputPointInfo& a, OutputPointInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputPointInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputPointInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputPointInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputPointInfo>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputPointInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.OutputPointInfo";
  }
  protected:
  explicit OutputPointInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutPointsFieldNumber = 1,
    kBlockNumFieldNumber = 2,
  };
  // repeated .protocol.OutputPoint out_points = 1;
  int out_points_size() const;
  private:
  int _internal_out_points_size() const;
  public:
  void clear_out_points();
  ::protocol::OutputPoint* mutable_out_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::OutputPoint >*
      mutable_out_points();
  private:
  const ::protocol::OutputPoint& _internal_out_points(int index) const;
  ::protocol::OutputPoint* _internal_add_out_points();
  public:
  const ::protocol::OutputPoint& out_points(int index) const;
  ::protocol::OutputPoint* add_out_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::OutputPoint >&
      out_points() const;

  // int32 block_num = 2;
  void clear_block_num();
  int32_t block_num() const;
  void set_block_num(int32_t value);
  private:
  int32_t _internal_block_num() const;
  void _internal_set_block_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.OutputPointInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::OutputPoint > out_points_;
    int32_t block_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class PedersenHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PedersenHash) */ {
 public:
  inline PedersenHash() : PedersenHash(nullptr) {}
  ~PedersenHash() override;
  explicit PROTOBUF_CONSTEXPR PedersenHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PedersenHash(const PedersenHash& from);
  PedersenHash(PedersenHash&& from) noexcept
    : PedersenHash() {
    *this = ::std::move(from);
  }

  inline PedersenHash& operator=(const PedersenHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline PedersenHash& operator=(PedersenHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PedersenHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const PedersenHash* internal_default_instance() {
    return reinterpret_cast<const PedersenHash*>(
               &_PedersenHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(PedersenHash& a, PedersenHash& b) {
    a.Swap(&b);
  }
  inline void Swap(PedersenHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PedersenHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PedersenHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PedersenHash>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PedersenHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PedersenHash";
  }
  protected:
  explicit PedersenHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // bytes content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:protocol.PedersenHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class IncrementalMerkleTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IncrementalMerkleTree) */ {
 public:
  inline IncrementalMerkleTree() : IncrementalMerkleTree(nullptr) {}
  ~IncrementalMerkleTree() override;
  explicit PROTOBUF_CONSTEXPR IncrementalMerkleTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncrementalMerkleTree(const IncrementalMerkleTree& from);
  IncrementalMerkleTree(IncrementalMerkleTree&& from) noexcept
    : IncrementalMerkleTree() {
    *this = ::std::move(from);
  }

  inline IncrementalMerkleTree& operator=(const IncrementalMerkleTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncrementalMerkleTree& operator=(IncrementalMerkleTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncrementalMerkleTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncrementalMerkleTree* internal_default_instance() {
    return reinterpret_cast<const IncrementalMerkleTree*>(
               &_IncrementalMerkleTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(IncrementalMerkleTree& a, IncrementalMerkleTree& b) {
    a.Swap(&b);
  }
  inline void Swap(IncrementalMerkleTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncrementalMerkleTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncrementalMerkleTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncrementalMerkleTree>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncrementalMerkleTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IncrementalMerkleTree";
  }
  protected:
  explicit IncrementalMerkleTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentsFieldNumber = 3,
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
  };
  // repeated .protocol.PedersenHash parents = 3;
  int parents_size() const;
  private:
  int _internal_parents_size() const;
  public:
  void clear_parents();
  ::protocol::PedersenHash* mutable_parents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >*
      mutable_parents();
  private:
  const ::protocol::PedersenHash& _internal_parents(int index) const;
  ::protocol::PedersenHash* _internal_add_parents();
  public:
  const ::protocol::PedersenHash& parents(int index) const;
  ::protocol::PedersenHash* add_parents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >&
      parents() const;

  // .protocol.PedersenHash left = 1;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::protocol::PedersenHash& left() const;
  PROTOBUF_NODISCARD ::protocol::PedersenHash* release_left();
  ::protocol::PedersenHash* mutable_left();
  void set_allocated_left(::protocol::PedersenHash* left);
  private:
  const ::protocol::PedersenHash& _internal_left() const;
  ::protocol::PedersenHash* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::protocol::PedersenHash* left);
  ::protocol::PedersenHash* unsafe_arena_release_left();

  // .protocol.PedersenHash right = 2;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  const ::protocol::PedersenHash& right() const;
  PROTOBUF_NODISCARD ::protocol::PedersenHash* release_right();
  ::protocol::PedersenHash* mutable_right();
  void set_allocated_right(::protocol::PedersenHash* right);
  private:
  const ::protocol::PedersenHash& _internal_right() const;
  ::protocol::PedersenHash* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::protocol::PedersenHash* right);
  ::protocol::PedersenHash* unsafe_arena_release_right();

  // @@protoc_insertion_point(class_scope:protocol.IncrementalMerkleTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash > parents_;
    ::protocol::PedersenHash* left_;
    ::protocol::PedersenHash* right_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class IncrementalMerkleVoucher final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IncrementalMerkleVoucher) */ {
 public:
  inline IncrementalMerkleVoucher() : IncrementalMerkleVoucher(nullptr) {}
  ~IncrementalMerkleVoucher() override;
  explicit PROTOBUF_CONSTEXPR IncrementalMerkleVoucher(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncrementalMerkleVoucher(const IncrementalMerkleVoucher& from);
  IncrementalMerkleVoucher(IncrementalMerkleVoucher&& from) noexcept
    : IncrementalMerkleVoucher() {
    *this = ::std::move(from);
  }

  inline IncrementalMerkleVoucher& operator=(const IncrementalMerkleVoucher& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncrementalMerkleVoucher& operator=(IncrementalMerkleVoucher&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncrementalMerkleVoucher& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncrementalMerkleVoucher* internal_default_instance() {
    return reinterpret_cast<const IncrementalMerkleVoucher*>(
               &_IncrementalMerkleVoucher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(IncrementalMerkleVoucher& a, IncrementalMerkleVoucher& b) {
    a.Swap(&b);
  }
  inline void Swap(IncrementalMerkleVoucher* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncrementalMerkleVoucher* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncrementalMerkleVoucher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncrementalMerkleVoucher>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncrementalMerkleVoucher* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IncrementalMerkleVoucher";
  }
  protected:
  explicit IncrementalMerkleVoucher(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilledFieldNumber = 2,
    kRtFieldNumber = 5,
    kTreeFieldNumber = 1,
    kCursorFieldNumber = 3,
    kOutputPointFieldNumber = 10,
    kCursorDepthFieldNumber = 4,
  };
  // repeated .protocol.PedersenHash filled = 2;
  int filled_size() const;
  private:
  int _internal_filled_size() const;
  public:
  void clear_filled();
  ::protocol::PedersenHash* mutable_filled(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >*
      mutable_filled();
  private:
  const ::protocol::PedersenHash& _internal_filled(int index) const;
  ::protocol::PedersenHash* _internal_add_filled();
  public:
  const ::protocol::PedersenHash& filled(int index) const;
  ::protocol::PedersenHash* add_filled();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >&
      filled() const;

  // bytes rt = 5;
  void clear_rt();
  const std::string& rt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rt();
  PROTOBUF_NODISCARD std::string* release_rt();
  void set_allocated_rt(std::string* rt);
  private:
  const std::string& _internal_rt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rt(const std::string& value);
  std::string* _internal_mutable_rt();
  public:

  // .protocol.IncrementalMerkleTree tree = 1;
  bool has_tree() const;
  private:
  bool _internal_has_tree() const;
  public:
  void clear_tree();
  const ::protocol::IncrementalMerkleTree& tree() const;
  PROTOBUF_NODISCARD ::protocol::IncrementalMerkleTree* release_tree();
  ::protocol::IncrementalMerkleTree* mutable_tree();
  void set_allocated_tree(::protocol::IncrementalMerkleTree* tree);
  private:
  const ::protocol::IncrementalMerkleTree& _internal_tree() const;
  ::protocol::IncrementalMerkleTree* _internal_mutable_tree();
  public:
  void unsafe_arena_set_allocated_tree(
      ::protocol::IncrementalMerkleTree* tree);
  ::protocol::IncrementalMerkleTree* unsafe_arena_release_tree();

  // .protocol.IncrementalMerkleTree cursor = 3;
  bool has_cursor() const;
  private:
  bool _internal_has_cursor() const;
  public:
  void clear_cursor();
  const ::protocol::IncrementalMerkleTree& cursor() const;
  PROTOBUF_NODISCARD ::protocol::IncrementalMerkleTree* release_cursor();
  ::protocol::IncrementalMerkleTree* mutable_cursor();
  void set_allocated_cursor(::protocol::IncrementalMerkleTree* cursor);
  private:
  const ::protocol::IncrementalMerkleTree& _internal_cursor() const;
  ::protocol::IncrementalMerkleTree* _internal_mutable_cursor();
  public:
  void unsafe_arena_set_allocated_cursor(
      ::protocol::IncrementalMerkleTree* cursor);
  ::protocol::IncrementalMerkleTree* unsafe_arena_release_cursor();

  // .protocol.OutputPoint output_point = 10;
  bool has_output_point() const;
  private:
  bool _internal_has_output_point() const;
  public:
  void clear_output_point();
  const ::protocol::OutputPoint& output_point() const;
  PROTOBUF_NODISCARD ::protocol::OutputPoint* release_output_point();
  ::protocol::OutputPoint* mutable_output_point();
  void set_allocated_output_point(::protocol::OutputPoint* output_point);
  private:
  const ::protocol::OutputPoint& _internal_output_point() const;
  ::protocol::OutputPoint* _internal_mutable_output_point();
  public:
  void unsafe_arena_set_allocated_output_point(
      ::protocol::OutputPoint* output_point);
  ::protocol::OutputPoint* unsafe_arena_release_output_point();

  // int64 cursor_depth = 4;
  void clear_cursor_depth();
  int64_t cursor_depth() const;
  void set_cursor_depth(int64_t value);
  private:
  int64_t _internal_cursor_depth() const;
  void _internal_set_cursor_depth(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.IncrementalMerkleVoucher)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash > filled_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rt_;
    ::protocol::IncrementalMerkleTree* tree_;
    ::protocol::IncrementalMerkleTree* cursor_;
    ::protocol::OutputPoint* output_point_;
    int64_t cursor_depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class IncrementalMerkleVoucherInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IncrementalMerkleVoucherInfo) */ {
 public:
  inline IncrementalMerkleVoucherInfo() : IncrementalMerkleVoucherInfo(nullptr) {}
  ~IncrementalMerkleVoucherInfo() override;
  explicit PROTOBUF_CONSTEXPR IncrementalMerkleVoucherInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncrementalMerkleVoucherInfo(const IncrementalMerkleVoucherInfo& from);
  IncrementalMerkleVoucherInfo(IncrementalMerkleVoucherInfo&& from) noexcept
    : IncrementalMerkleVoucherInfo() {
    *this = ::std::move(from);
  }

  inline IncrementalMerkleVoucherInfo& operator=(const IncrementalMerkleVoucherInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncrementalMerkleVoucherInfo& operator=(IncrementalMerkleVoucherInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncrementalMerkleVoucherInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncrementalMerkleVoucherInfo* internal_default_instance() {
    return reinterpret_cast<const IncrementalMerkleVoucherInfo*>(
               &_IncrementalMerkleVoucherInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(IncrementalMerkleVoucherInfo& a, IncrementalMerkleVoucherInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IncrementalMerkleVoucherInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncrementalMerkleVoucherInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncrementalMerkleVoucherInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncrementalMerkleVoucherInfo>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncrementalMerkleVoucherInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IncrementalMerkleVoucherInfo";
  }
  protected:
  explicit IncrementalMerkleVoucherInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVouchersFieldNumber = 1,
    kPathsFieldNumber = 2,
  };
  // repeated .protocol.IncrementalMerkleVoucher vouchers = 1;
  int vouchers_size() const;
  private:
  int _internal_vouchers_size() const;
  public:
  void clear_vouchers();
  ::protocol::IncrementalMerkleVoucher* mutable_vouchers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::IncrementalMerkleVoucher >*
      mutable_vouchers();
  private:
  const ::protocol::IncrementalMerkleVoucher& _internal_vouchers(int index) const;
  ::protocol::IncrementalMerkleVoucher* _internal_add_vouchers();
  public:
  const ::protocol::IncrementalMerkleVoucher& vouchers(int index) const;
  ::protocol::IncrementalMerkleVoucher* add_vouchers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::IncrementalMerkleVoucher >&
      vouchers() const;

  // repeated bytes paths = 2;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  const std::string& paths(int index) const;
  std::string* mutable_paths(int index);
  void set_paths(int index, const std::string& value);
  void set_paths(int index, std::string&& value);
  void set_paths(int index, const char* value);
  void set_paths(int index, const void* value, size_t size);
  std::string* add_paths();
  void add_paths(const std::string& value);
  void add_paths(std::string&& value);
  void add_paths(const char* value);
  void add_paths(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_paths();
  private:
  const std::string& _internal_paths(int index) const;
  std::string* _internal_add_paths();
  public:

  // @@protoc_insertion_point(class_scope:protocol.IncrementalMerkleVoucherInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::IncrementalMerkleVoucher > vouchers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> paths_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SpendDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SpendDescription) */ {
 public:
  inline SpendDescription() : SpendDescription(nullptr) {}
  ~SpendDescription() override;
  explicit PROTOBUF_CONSTEXPR SpendDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpendDescription(const SpendDescription& from);
  SpendDescription(SpendDescription&& from) noexcept
    : SpendDescription() {
    *this = ::std::move(from);
  }

  inline SpendDescription& operator=(const SpendDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpendDescription& operator=(SpendDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpendDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpendDescription* internal_default_instance() {
    return reinterpret_cast<const SpendDescription*>(
               &_SpendDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SpendDescription& a, SpendDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SpendDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpendDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpendDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpendDescription>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpendDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SpendDescription";
  }
  protected:
  explicit SpendDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueCommitmentFieldNumber = 1,
    kAnchorFieldNumber = 2,
    kNullifierFieldNumber = 3,
    kRkFieldNumber = 4,
    kZkproofFieldNumber = 5,
    kSpendAuthoritySignatureFieldNumber = 6,
  };
  // bytes value_commitment = 1;
  void clear_value_commitment();
  const std::string& value_commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_commitment();
  PROTOBUF_NODISCARD std::string* release_value_commitment();
  void set_allocated_value_commitment(std::string* value_commitment);
  private:
  const std::string& _internal_value_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_commitment(const std::string& value);
  std::string* _internal_mutable_value_commitment();
  public:

  // bytes anchor = 2;
  void clear_anchor();
  const std::string& anchor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_anchor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_anchor();
  PROTOBUF_NODISCARD std::string* release_anchor();
  void set_allocated_anchor(std::string* anchor);
  private:
  const std::string& _internal_anchor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_anchor(const std::string& value);
  std::string* _internal_mutable_anchor();
  public:

  // bytes nullifier = 3;
  void clear_nullifier();
  const std::string& nullifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nullifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nullifier();
  PROTOBUF_NODISCARD std::string* release_nullifier();
  void set_allocated_nullifier(std::string* nullifier);
  private:
  const std::string& _internal_nullifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nullifier(const std::string& value);
  std::string* _internal_mutable_nullifier();
  public:

  // bytes rk = 4;
  void clear_rk();
  const std::string& rk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rk();
  PROTOBUF_NODISCARD std::string* release_rk();
  void set_allocated_rk(std::string* rk);
  private:
  const std::string& _internal_rk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rk(const std::string& value);
  std::string* _internal_mutable_rk();
  public:

  // bytes zkproof = 5;
  void clear_zkproof();
  const std::string& zkproof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zkproof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zkproof();
  PROTOBUF_NODISCARD std::string* release_zkproof();
  void set_allocated_zkproof(std::string* zkproof);
  private:
  const std::string& _internal_zkproof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zkproof(const std::string& value);
  std::string* _internal_mutable_zkproof();
  public:

  // bytes spend_authority_signature = 6;
  void clear_spend_authority_signature();
  const std::string& spend_authority_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spend_authority_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spend_authority_signature();
  PROTOBUF_NODISCARD std::string* release_spend_authority_signature();
  void set_allocated_spend_authority_signature(std::string* spend_authority_signature);
  private:
  const std::string& _internal_spend_authority_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spend_authority_signature(const std::string& value);
  std::string* _internal_mutable_spend_authority_signature();
  public:

  // @@protoc_insertion_point(class_scope:protocol.SpendDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_commitment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr anchor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nullifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zkproof_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spend_authority_signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ReceiveDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ReceiveDescription) */ {
 public:
  inline ReceiveDescription() : ReceiveDescription(nullptr) {}
  ~ReceiveDescription() override;
  explicit PROTOBUF_CONSTEXPR ReceiveDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveDescription(const ReceiveDescription& from);
  ReceiveDescription(ReceiveDescription&& from) noexcept
    : ReceiveDescription() {
    *this = ::std::move(from);
  }

  inline ReceiveDescription& operator=(const ReceiveDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveDescription& operator=(ReceiveDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveDescription* internal_default_instance() {
    return reinterpret_cast<const ReceiveDescription*>(
               &_ReceiveDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ReceiveDescription& a, ReceiveDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveDescription>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ReceiveDescription";
  }
  protected:
  explicit ReceiveDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueCommitmentFieldNumber = 1,
    kNoteCommitmentFieldNumber = 2,
    kEpkFieldNumber = 3,
    kCEncFieldNumber = 4,
    kCOutFieldNumber = 5,
    kZkproofFieldNumber = 6,
  };
  // bytes value_commitment = 1;
  void clear_value_commitment();
  const std::string& value_commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_commitment();
  PROTOBUF_NODISCARD std::string* release_value_commitment();
  void set_allocated_value_commitment(std::string* value_commitment);
  private:
  const std::string& _internal_value_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_commitment(const std::string& value);
  std::string* _internal_mutable_value_commitment();
  public:

  // bytes note_commitment = 2;
  void clear_note_commitment();
  const std::string& note_commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note_commitment();
  PROTOBUF_NODISCARD std::string* release_note_commitment();
  void set_allocated_note_commitment(std::string* note_commitment);
  private:
  const std::string& _internal_note_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note_commitment(const std::string& value);
  std::string* _internal_mutable_note_commitment();
  public:

  // bytes epk = 3;
  void clear_epk();
  const std::string& epk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_epk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_epk();
  PROTOBUF_NODISCARD std::string* release_epk();
  void set_allocated_epk(std::string* epk);
  private:
  const std::string& _internal_epk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_epk(const std::string& value);
  std::string* _internal_mutable_epk();
  public:

  // bytes c_enc = 4;
  void clear_c_enc();
  const std::string& c_enc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c_enc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c_enc();
  PROTOBUF_NODISCARD std::string* release_c_enc();
  void set_allocated_c_enc(std::string* c_enc);
  private:
  const std::string& _internal_c_enc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c_enc(const std::string& value);
  std::string* _internal_mutable_c_enc();
  public:

  // bytes c_out = 5;
  void clear_c_out();
  const std::string& c_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c_out();
  PROTOBUF_NODISCARD std::string* release_c_out();
  void set_allocated_c_out(std::string* c_out);
  private:
  const std::string& _internal_c_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c_out(const std::string& value);
  std::string* _internal_mutable_c_out();
  public:

  // bytes zkproof = 6;
  void clear_zkproof();
  const std::string& zkproof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zkproof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zkproof();
  PROTOBUF_NODISCARD std::string* release_zkproof();
  void set_allocated_zkproof(std::string* zkproof);
  private:
  const std::string& _internal_zkproof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zkproof(const std::string& value);
  std::string* _internal_mutable_zkproof();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ReceiveDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_commitment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_commitment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr epk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_enc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zkproof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ShieldedTransferContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ShieldedTransferContract) */ {
 public:
  inline ShieldedTransferContract() : ShieldedTransferContract(nullptr) {}
  ~ShieldedTransferContract() override;
  explicit PROTOBUF_CONSTEXPR ShieldedTransferContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldedTransferContract(const ShieldedTransferContract& from);
  ShieldedTransferContract(ShieldedTransferContract&& from) noexcept
    : ShieldedTransferContract() {
    *this = ::std::move(from);
  }

  inline ShieldedTransferContract& operator=(const ShieldedTransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldedTransferContract& operator=(ShieldedTransferContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShieldedTransferContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldedTransferContract* internal_default_instance() {
    return reinterpret_cast<const ShieldedTransferContract*>(
               &_ShieldedTransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ShieldedTransferContract& a, ShieldedTransferContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldedTransferContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldedTransferContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShieldedTransferContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShieldedTransferContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShieldedTransferContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ShieldedTransferContract";
  }
  protected:
  explicit ShieldedTransferContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpendDescriptionFieldNumber = 3,
    kReceiveDescriptionFieldNumber = 4,
    kTransparentFromAddressFieldNumber = 1,
    kBindingSignatureFieldNumber = 5,
    kTransparentToAddressFieldNumber = 6,
    kFromAmountFieldNumber = 2,
    kToAmountFieldNumber = 7,
  };
  // repeated .protocol.SpendDescription spend_description = 3;
  int spend_description_size() const;
  private:
  int _internal_spend_description_size() const;
  public:
  void clear_spend_description();
  ::protocol::SpendDescription* mutable_spend_description(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >*
      mutable_spend_description();
  private:
  const ::protocol::SpendDescription& _internal_spend_description(int index) const;
  ::protocol::SpendDescription* _internal_add_spend_description();
  public:
  const ::protocol::SpendDescription& spend_description(int index) const;
  ::protocol::SpendDescription* add_spend_description();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >&
      spend_description() const;

  // repeated .protocol.ReceiveDescription receive_description = 4;
  int receive_description_size() const;
  private:
  int _internal_receive_description_size() const;
  public:
  void clear_receive_description();
  ::protocol::ReceiveDescription* mutable_receive_description(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >*
      mutable_receive_description();
  private:
  const ::protocol::ReceiveDescription& _internal_receive_description(int index) const;
  ::protocol::ReceiveDescription* _internal_add_receive_description();
  public:
  const ::protocol::ReceiveDescription& receive_description(int index) const;
  ::protocol::ReceiveDescription* add_receive_description();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >&
      receive_description() const;

  // bytes transparent_from_address = 1;
  void clear_transparent_from_address();
  const std::string& transparent_from_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_from_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_from_address();
  PROTOBUF_NODISCARD std::string* release_transparent_from_address();
  void set_allocated_transparent_from_address(std::string* transparent_from_address);
  private:
  const std::string& _internal_transparent_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_from_address(const std::string& value);
  std::string* _internal_mutable_transparent_from_address();
  public:

  // bytes binding_signature = 5;
  void clear_binding_signature();
  const std::string& binding_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binding_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binding_signature();
  PROTOBUF_NODISCARD std::string* release_binding_signature();
  void set_allocated_binding_signature(std::string* binding_signature);
  private:
  const std::string& _internal_binding_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binding_signature(const std::string& value);
  std::string* _internal_mutable_binding_signature();
  public:

  // bytes transparent_to_address = 6;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_NODISCARD std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // int64 from_amount = 2;
  void clear_from_amount();
  int64_t from_amount() const;
  void set_from_amount(int64_t value);
  private:
  int64_t _internal_from_amount() const;
  void _internal_set_from_amount(int64_t value);
  public:

  // int64 to_amount = 7;
  void clear_to_amount();
  int64_t to_amount() const;
  void set_to_amount(int64_t value);
  private:
  int64_t _internal_to_amount() const;
  void _internal_set_to_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ShieldedTransferContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription > spend_description_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription > receive_description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_from_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binding_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
    int64_t from_amount_;
    int64_t to_amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SmartContract_ABI_Entry_Param final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SmartContract.ABI.Entry.Param) */ {
 public:
  inline SmartContract_ABI_Entry_Param() : SmartContract_ABI_Entry_Param(nullptr) {}
  ~SmartContract_ABI_Entry_Param() override;
  explicit PROTOBUF_CONSTEXPR SmartContract_ABI_Entry_Param(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContract_ABI_Entry_Param(const SmartContract_ABI_Entry_Param& from);
  SmartContract_ABI_Entry_Param(SmartContract_ABI_Entry_Param&& from) noexcept
    : SmartContract_ABI_Entry_Param() {
    *this = ::std::move(from);
  }

  inline SmartContract_ABI_Entry_Param& operator=(const SmartContract_ABI_Entry_Param& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContract_ABI_Entry_Param& operator=(SmartContract_ABI_Entry_Param&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContract_ABI_Entry_Param& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContract_ABI_Entry_Param* internal_default_instance() {
    return reinterpret_cast<const SmartContract_ABI_Entry_Param*>(
               &_SmartContract_ABI_Entry_Param_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(SmartContract_ABI_Entry_Param& a, SmartContract_ABI_Entry_Param& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContract_ABI_Entry_Param* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContract_ABI_Entry_Param* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContract_ABI_Entry_Param* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContract_ABI_Entry_Param>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContract_ABI_Entry_Param* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SmartContract.ABI.Entry.Param";
  }
  protected:
  explicit SmartContract_ABI_Entry_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexedFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bool indexed = 1;
  void clear_indexed();
  bool indexed() const;
  void set_indexed(bool value);
  private:
  bool _internal_indexed() const;
  void _internal_set_indexed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SmartContract.ABI.Entry.Param)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    bool indexed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SmartContract_ABI_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SmartContract.ABI.Entry) */ {
 public:
  inline SmartContract_ABI_Entry() : SmartContract_ABI_Entry(nullptr) {}
  ~SmartContract_ABI_Entry() override;
  explicit PROTOBUF_CONSTEXPR SmartContract_ABI_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContract_ABI_Entry(const SmartContract_ABI_Entry& from);
  SmartContract_ABI_Entry(SmartContract_ABI_Entry&& from) noexcept
    : SmartContract_ABI_Entry() {
    *this = ::std::move(from);
  }

  inline SmartContract_ABI_Entry& operator=(const SmartContract_ABI_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContract_ABI_Entry& operator=(SmartContract_ABI_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContract_ABI_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContract_ABI_Entry* internal_default_instance() {
    return reinterpret_cast<const SmartContract_ABI_Entry*>(
               &_SmartContract_ABI_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(SmartContract_ABI_Entry& a, SmartContract_ABI_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContract_ABI_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContract_ABI_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContract_ABI_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContract_ABI_Entry>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContract_ABI_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SmartContract.ABI.Entry";
  }
  protected:
  explicit SmartContract_ABI_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SmartContract_ABI_Entry_Param Param;

  typedef SmartContract_ABI_Entry_EntryType EntryType;
  static constexpr EntryType UnknownEntryType =
    SmartContract_ABI_Entry_EntryType_UnknownEntryType;
  static constexpr EntryType Constructor =
    SmartContract_ABI_Entry_EntryType_Constructor;
  static constexpr EntryType Function =
    SmartContract_ABI_Entry_EntryType_Function;
  static constexpr EntryType Event =
    SmartContract_ABI_Entry_EntryType_Event;
  static constexpr EntryType Fallback =
    SmartContract_ABI_Entry_EntryType_Fallback;
  static constexpr EntryType Receive =
    SmartContract_ABI_Entry_EntryType_Receive;
  static constexpr EntryType Error =
    SmartContract_ABI_Entry_EntryType_Error;
  static inline bool EntryType_IsValid(int value) {
    return SmartContract_ABI_Entry_EntryType_IsValid(value);
  }
  static constexpr EntryType EntryType_MIN =
    SmartContract_ABI_Entry_EntryType_EntryType_MIN;
  static constexpr EntryType EntryType_MAX =
    SmartContract_ABI_Entry_EntryType_EntryType_MAX;
  static constexpr int EntryType_ARRAYSIZE =
    SmartContract_ABI_Entry_EntryType_EntryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EntryType_descriptor() {
    return SmartContract_ABI_Entry_EntryType_descriptor();
  }
  template<typename T>
  static inline const std::string& EntryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EntryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EntryType_Name.");
    return SmartContract_ABI_Entry_EntryType_Name(enum_t_value);
  }
  static inline bool EntryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EntryType* value) {
    return SmartContract_ABI_Entry_EntryType_Parse(name, value);
  }

  typedef SmartContract_ABI_Entry_StateMutabilityType StateMutabilityType;
  static constexpr StateMutabilityType UnknownMutabilityType =
    SmartContract_ABI_Entry_StateMutabilityType_UnknownMutabilityType;
  static constexpr StateMutabilityType Pure =
    SmartContract_ABI_Entry_StateMutabilityType_Pure;
  static constexpr StateMutabilityType View =
    SmartContract_ABI_Entry_StateMutabilityType_View;
  static constexpr StateMutabilityType Nonpayable =
    SmartContract_ABI_Entry_StateMutabilityType_Nonpayable;
  static constexpr StateMutabilityType Payable =
    SmartContract_ABI_Entry_StateMutabilityType_Payable;
  static inline bool StateMutabilityType_IsValid(int value) {
    return SmartContract_ABI_Entry_StateMutabilityType_IsValid(value);
  }
  static constexpr StateMutabilityType StateMutabilityType_MIN =
    SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_MIN;
  static constexpr StateMutabilityType StateMutabilityType_MAX =
    SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_MAX;
  static constexpr int StateMutabilityType_ARRAYSIZE =
    SmartContract_ABI_Entry_StateMutabilityType_StateMutabilityType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateMutabilityType_descriptor() {
    return SmartContract_ABI_Entry_StateMutabilityType_descriptor();
  }
  template<typename T>
  static inline const std::string& StateMutabilityType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateMutabilityType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateMutabilityType_Name.");
    return SmartContract_ABI_Entry_StateMutabilityType_Name(enum_t_value);
  }
  static inline bool StateMutabilityType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateMutabilityType* value) {
    return SmartContract_ABI_Entry_StateMutabilityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 4,
    kOutputsFieldNumber = 5,
    kNameFieldNumber = 3,
    kAnonymousFieldNumber = 1,
    kConstantFieldNumber = 2,
    kPayableFieldNumber = 7,
    kTypeFieldNumber = 6,
    kStateMutabilityFieldNumber = 8,
  };
  // repeated .protocol.SmartContract.ABI.Entry.Param inputs = 4;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::protocol::SmartContract_ABI_Entry_Param* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >*
      mutable_inputs();
  private:
  const ::protocol::SmartContract_ABI_Entry_Param& _internal_inputs(int index) const;
  ::protocol::SmartContract_ABI_Entry_Param* _internal_add_inputs();
  public:
  const ::protocol::SmartContract_ABI_Entry_Param& inputs(int index) const;
  ::protocol::SmartContract_ABI_Entry_Param* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >&
      inputs() const;

  // repeated .protocol.SmartContract.ABI.Entry.Param outputs = 5;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::protocol::SmartContract_ABI_Entry_Param* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >*
      mutable_outputs();
  private:
  const ::protocol::SmartContract_ABI_Entry_Param& _internal_outputs(int index) const;
  ::protocol::SmartContract_ABI_Entry_Param* _internal_add_outputs();
  public:
  const ::protocol::SmartContract_ABI_Entry_Param& outputs(int index) const;
  ::protocol::SmartContract_ABI_Entry_Param* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >&
      outputs() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool anonymous = 1;
  void clear_anonymous();
  bool anonymous() const;
  void set_anonymous(bool value);
  private:
  bool _internal_anonymous() const;
  void _internal_set_anonymous(bool value);
  public:

  // bool constant = 2;
  void clear_constant();
  bool constant() const;
  void set_constant(bool value);
  private:
  bool _internal_constant() const;
  void _internal_set_constant(bool value);
  public:

  // bool payable = 7;
  void clear_payable();
  bool payable() const;
  void set_payable(bool value);
  private:
  bool _internal_payable() const;
  void _internal_set_payable(bool value);
  public:

  // .protocol.SmartContract.ABI.Entry.EntryType type = 6;
  void clear_type();
  ::protocol::SmartContract_ABI_Entry_EntryType type() const;
  void set_type(::protocol::SmartContract_ABI_Entry_EntryType value);
  private:
  ::protocol::SmartContract_ABI_Entry_EntryType _internal_type() const;
  void _internal_set_type(::protocol::SmartContract_ABI_Entry_EntryType value);
  public:

  // .protocol.SmartContract.ABI.Entry.StateMutabilityType stateMutability = 8;
  void clear_statemutability();
  ::protocol::SmartContract_ABI_Entry_StateMutabilityType statemutability() const;
  void set_statemutability(::protocol::SmartContract_ABI_Entry_StateMutabilityType value);
  private:
  ::protocol::SmartContract_ABI_Entry_StateMutabilityType _internal_statemutability() const;
  void _internal_set_statemutability(::protocol::SmartContract_ABI_Entry_StateMutabilityType value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SmartContract.ABI.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param > outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool anonymous_;
    bool constant_;
    bool payable_;
    int type_;
    int statemutability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SmartContract_ABI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SmartContract.ABI) */ {
 public:
  inline SmartContract_ABI() : SmartContract_ABI(nullptr) {}
  ~SmartContract_ABI() override;
  explicit PROTOBUF_CONSTEXPR SmartContract_ABI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContract_ABI(const SmartContract_ABI& from);
  SmartContract_ABI(SmartContract_ABI&& from) noexcept
    : SmartContract_ABI() {
    *this = ::std::move(from);
  }

  inline SmartContract_ABI& operator=(const SmartContract_ABI& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContract_ABI& operator=(SmartContract_ABI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContract_ABI& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContract_ABI* internal_default_instance() {
    return reinterpret_cast<const SmartContract_ABI*>(
               &_SmartContract_ABI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SmartContract_ABI& a, SmartContract_ABI& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContract_ABI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContract_ABI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContract_ABI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContract_ABI>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContract_ABI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SmartContract.ABI";
  }
  protected:
  explicit SmartContract_ABI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SmartContract_ABI_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntrysFieldNumber = 1,
  };
  // repeated .protocol.SmartContract.ABI.Entry entrys = 1;
  int entrys_size() const;
  private:
  int _internal_entrys_size() const;
  public:
  void clear_entrys();
  ::protocol::SmartContract_ABI_Entry* mutable_entrys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry >*
      mutable_entrys();
  private:
  const ::protocol::SmartContract_ABI_Entry& _internal_entrys(int index) const;
  ::protocol::SmartContract_ABI_Entry* _internal_add_entrys();
  public:
  const ::protocol::SmartContract_ABI_Entry& entrys(int index) const;
  ::protocol::SmartContract_ABI_Entry* add_entrys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry >&
      entrys() const;

  // @@protoc_insertion_point(class_scope:protocol.SmartContract.ABI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry > entrys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SmartContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SmartContract) */ {
 public:
  inline SmartContract() : SmartContract(nullptr) {}
  ~SmartContract() override;
  explicit PROTOBUF_CONSTEXPR SmartContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContract(const SmartContract& from);
  SmartContract(SmartContract&& from) noexcept
    : SmartContract() {
    *this = ::std::move(from);
  }

  inline SmartContract& operator=(const SmartContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContract& operator=(SmartContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContract* internal_default_instance() {
    return reinterpret_cast<const SmartContract*>(
               &_SmartContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SmartContract& a, SmartContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SmartContract";
  }
  protected:
  explicit SmartContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SmartContract_ABI ABI;

  // accessors -------------------------------------------------------

  enum : int {
    kOriginAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kBytecodeFieldNumber = 4,
    kNameFieldNumber = 7,
    kCodeHashFieldNumber = 9,
    kTrxHashFieldNumber = 10,
    kAbiFieldNumber = 3,
    kCallValueFieldNumber = 5,
    kConsumeUserResourcePercentFieldNumber = 6,
    kOriginEnergyLimitFieldNumber = 8,
    kVersionFieldNumber = 11,
  };
  // bytes origin_address = 1;
  void clear_origin_address();
  const std::string& origin_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin_address();
  PROTOBUF_NODISCARD std::string* release_origin_address();
  void set_allocated_origin_address(std::string* origin_address);
  private:
  const std::string& _internal_origin_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin_address(const std::string& value);
  std::string* _internal_mutable_origin_address();
  public:

  // bytes contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // bytes bytecode = 4;
  void clear_bytecode();
  const std::string& bytecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytecode();
  PROTOBUF_NODISCARD std::string* release_bytecode();
  void set_allocated_bytecode(std::string* bytecode);
  private:
  const std::string& _internal_bytecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytecode(const std::string& value);
  std::string* _internal_mutable_bytecode();
  public:

  // string name = 7;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes code_hash = 9;
  void clear_code_hash();
  const std::string& code_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code_hash();
  PROTOBUF_NODISCARD std::string* release_code_hash();
  void set_allocated_code_hash(std::string* code_hash);
  private:
  const std::string& _internal_code_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_hash(const std::string& value);
  std::string* _internal_mutable_code_hash();
  public:

  // bytes trx_hash = 10;
  void clear_trx_hash();
  const std::string& trx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trx_hash();
  PROTOBUF_NODISCARD std::string* release_trx_hash();
  void set_allocated_trx_hash(std::string* trx_hash);
  private:
  const std::string& _internal_trx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trx_hash(const std::string& value);
  std::string* _internal_mutable_trx_hash();
  public:

  // .protocol.SmartContract.ABI abi = 3;
  bool has_abi() const;
  private:
  bool _internal_has_abi() const;
  public:
  void clear_abi();
  const ::protocol::SmartContract_ABI& abi() const;
  PROTOBUF_NODISCARD ::protocol::SmartContract_ABI* release_abi();
  ::protocol::SmartContract_ABI* mutable_abi();
  void set_allocated_abi(::protocol::SmartContract_ABI* abi);
  private:
  const ::protocol::SmartContract_ABI& _internal_abi() const;
  ::protocol::SmartContract_ABI* _internal_mutable_abi();
  public:
  void unsafe_arena_set_allocated_abi(
      ::protocol::SmartContract_ABI* abi);
  ::protocol::SmartContract_ABI* unsafe_arena_release_abi();

  // int64 call_value = 5;
  void clear_call_value();
  int64_t call_value() const;
  void set_call_value(int64_t value);
  private:
  int64_t _internal_call_value() const;
  void _internal_set_call_value(int64_t value);
  public:

  // int64 consume_user_resource_percent = 6;
  void clear_consume_user_resource_percent();
  int64_t consume_user_resource_percent() const;
  void set_consume_user_resource_percent(int64_t value);
  private:
  int64_t _internal_consume_user_resource_percent() const;
  void _internal_set_consume_user_resource_percent(int64_t value);
  public:

  // int64 origin_energy_limit = 8;
  void clear_origin_energy_limit();
  int64_t origin_energy_limit() const;
  void set_origin_energy_limit(int64_t value);
  private:
  int64_t _internal_origin_energy_limit() const;
  void _internal_set_origin_energy_limit(int64_t value);
  public:

  // int32 version = 11;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SmartContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trx_hash_;
    ::protocol::SmartContract_ABI* abi_;
    int64_t call_value_;
    int64_t consume_user_resource_percent_;
    int64_t origin_energy_limit_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ContractState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ContractState) */ {
 public:
  inline ContractState() : ContractState(nullptr) {}
  ~ContractState() override;
  explicit PROTOBUF_CONSTEXPR ContractState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractState(const ContractState& from);
  ContractState(ContractState&& from) noexcept
    : ContractState() {
    *this = ::std::move(from);
  }

  inline ContractState& operator=(const ContractState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractState& operator=(ContractState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractState* internal_default_instance() {
    return reinterpret_cast<const ContractState*>(
               &_ContractState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ContractState& a, ContractState& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractState>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ContractState";
  }
  protected:
  explicit ContractState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnergyUsageFieldNumber = 1,
    kEnergyFactorFieldNumber = 2,
    kUpdateCycleFieldNumber = 3,
  };
  // int64 energy_usage = 1;
  void clear_energy_usage();
  int64_t energy_usage() const;
  void set_energy_usage(int64_t value);
  private:
  int64_t _internal_energy_usage() const;
  void _internal_set_energy_usage(int64_t value);
  public:

  // int64 energy_factor = 2;
  void clear_energy_factor();
  int64_t energy_factor() const;
  void set_energy_factor(int64_t value);
  private:
  int64_t _internal_energy_factor() const;
  void _internal_set_energy_factor(int64_t value);
  public:

  // int64 update_cycle = 3;
  void clear_update_cycle();
  int64_t update_cycle() const;
  void set_update_cycle(int64_t value);
  private:
  int64_t _internal_update_cycle() const;
  void _internal_set_update_cycle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ContractState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t energy_usage_;
    int64_t energy_factor_;
    int64_t update_cycle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class CreateSmartContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CreateSmartContract) */ {
 public:
  inline CreateSmartContract() : CreateSmartContract(nullptr) {}
  ~CreateSmartContract() override;
  explicit PROTOBUF_CONSTEXPR CreateSmartContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSmartContract(const CreateSmartContract& from);
  CreateSmartContract(CreateSmartContract&& from) noexcept
    : CreateSmartContract() {
    *this = ::std::move(from);
  }

  inline CreateSmartContract& operator=(const CreateSmartContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSmartContract& operator=(CreateSmartContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSmartContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSmartContract* internal_default_instance() {
    return reinterpret_cast<const CreateSmartContract*>(
               &_CreateSmartContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CreateSmartContract& a, CreateSmartContract& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSmartContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSmartContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSmartContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSmartContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSmartContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CreateSmartContract";
  }
  protected:
  explicit CreateSmartContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kNewContractFieldNumber = 2,
    kCallTokenValueFieldNumber = 3,
    kTokenIdFieldNumber = 4,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // .protocol.SmartContract new_contract = 2;
  bool has_new_contract() const;
  private:
  bool _internal_has_new_contract() const;
  public:
  void clear_new_contract();
  const ::protocol::SmartContract& new_contract() const;
  PROTOBUF_NODISCARD ::protocol::SmartContract* release_new_contract();
  ::protocol::SmartContract* mutable_new_contract();
  void set_allocated_new_contract(::protocol::SmartContract* new_contract);
  private:
  const ::protocol::SmartContract& _internal_new_contract() const;
  ::protocol::SmartContract* _internal_mutable_new_contract();
  public:
  void unsafe_arena_set_allocated_new_contract(
      ::protocol::SmartContract* new_contract);
  ::protocol::SmartContract* unsafe_arena_release_new_contract();

  // int64 call_token_value = 3;
  void clear_call_token_value();
  int64_t call_token_value() const;
  void set_call_token_value(int64_t value);
  private:
  int64_t _internal_call_token_value() const;
  void _internal_set_call_token_value(int64_t value);
  public:

  // int64 token_id = 4;
  void clear_token_id();
  int64_t token_id() const;
  void set_token_id(int64_t value);
  private:
  int64_t _internal_token_id() const;
  void _internal_set_token_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CreateSmartContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::protocol::SmartContract* new_contract_;
    int64_t call_token_value_;
    int64_t token_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TriggerSmartContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TriggerSmartContract) */ {
 public:
  inline TriggerSmartContract() : TriggerSmartContract(nullptr) {}
  ~TriggerSmartContract() override;
  explicit PROTOBUF_CONSTEXPR TriggerSmartContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerSmartContract(const TriggerSmartContract& from);
  TriggerSmartContract(TriggerSmartContract&& from) noexcept
    : TriggerSmartContract() {
    *this = ::std::move(from);
  }

  inline TriggerSmartContract& operator=(const TriggerSmartContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerSmartContract& operator=(TriggerSmartContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerSmartContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerSmartContract* internal_default_instance() {
    return reinterpret_cast<const TriggerSmartContract*>(
               &_TriggerSmartContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(TriggerSmartContract& a, TriggerSmartContract& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerSmartContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerSmartContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerSmartContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerSmartContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerSmartContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TriggerSmartContract";
  }
  protected:
  explicit TriggerSmartContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kDataFieldNumber = 4,
    kCallValueFieldNumber = 3,
    kCallTokenValueFieldNumber = 5,
    kTokenIdFieldNumber = 6,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 call_value = 3;
  void clear_call_value();
  int64_t call_value() const;
  void set_call_value(int64_t value);
  private:
  int64_t _internal_call_value() const;
  void _internal_set_call_value(int64_t value);
  public:

  // int64 call_token_value = 5;
  void clear_call_token_value();
  int64_t call_token_value() const;
  void set_call_token_value(int64_t value);
  private:
  int64_t _internal_call_token_value() const;
  void _internal_set_call_token_value(int64_t value);
  public:

  // int64 token_id = 6;
  void clear_token_id();
  int64_t token_id() const;
  void set_token_id(int64_t value);
  private:
  int64_t _internal_token_id() const;
  void _internal_set_token_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TriggerSmartContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t call_value_;
    int64_t call_token_value_;
    int64_t token_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class ClearABIContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ClearABIContract) */ {
 public:
  inline ClearABIContract() : ClearABIContract(nullptr) {}
  ~ClearABIContract() override;
  explicit PROTOBUF_CONSTEXPR ClearABIContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearABIContract(const ClearABIContract& from);
  ClearABIContract(ClearABIContract&& from) noexcept
    : ClearABIContract() {
    *this = ::std::move(from);
  }

  inline ClearABIContract& operator=(const ClearABIContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearABIContract& operator=(ClearABIContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearABIContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearABIContract* internal_default_instance() {
    return reinterpret_cast<const ClearABIContract*>(
               &_ClearABIContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ClearABIContract& a, ClearABIContract& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearABIContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearABIContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearABIContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearABIContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearABIContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ClearABIContract";
  }
  protected:
  explicit ClearABIContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ClearABIContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UpdateSettingContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UpdateSettingContract) */ {
 public:
  inline UpdateSettingContract() : UpdateSettingContract(nullptr) {}
  ~UpdateSettingContract() override;
  explicit PROTOBUF_CONSTEXPR UpdateSettingContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSettingContract(const UpdateSettingContract& from);
  UpdateSettingContract(UpdateSettingContract&& from) noexcept
    : UpdateSettingContract() {
    *this = ::std::move(from);
  }

  inline UpdateSettingContract& operator=(const UpdateSettingContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSettingContract& operator=(UpdateSettingContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSettingContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSettingContract* internal_default_instance() {
    return reinterpret_cast<const UpdateSettingContract*>(
               &_UpdateSettingContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(UpdateSettingContract& a, UpdateSettingContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSettingContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSettingContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSettingContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSettingContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSettingContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UpdateSettingContract";
  }
  protected:
  explicit UpdateSettingContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kConsumeUserResourcePercentFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // int64 consume_user_resource_percent = 3;
  void clear_consume_user_resource_percent();
  int64_t consume_user_resource_percent() const;
  void set_consume_user_resource_percent(int64_t value);
  private:
  int64_t _internal_consume_user_resource_percent() const;
  void _internal_set_consume_user_resource_percent(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UpdateSettingContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    int64_t consume_user_resource_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UpdateEnergyLimitContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UpdateEnergyLimitContract) */ {
 public:
  inline UpdateEnergyLimitContract() : UpdateEnergyLimitContract(nullptr) {}
  ~UpdateEnergyLimitContract() override;
  explicit PROTOBUF_CONSTEXPR UpdateEnergyLimitContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEnergyLimitContract(const UpdateEnergyLimitContract& from);
  UpdateEnergyLimitContract(UpdateEnergyLimitContract&& from) noexcept
    : UpdateEnergyLimitContract() {
    *this = ::std::move(from);
  }

  inline UpdateEnergyLimitContract& operator=(const UpdateEnergyLimitContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEnergyLimitContract& operator=(UpdateEnergyLimitContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEnergyLimitContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEnergyLimitContract* internal_default_instance() {
    return reinterpret_cast<const UpdateEnergyLimitContract*>(
               &_UpdateEnergyLimitContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(UpdateEnergyLimitContract& a, UpdateEnergyLimitContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEnergyLimitContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEnergyLimitContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEnergyLimitContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEnergyLimitContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEnergyLimitContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UpdateEnergyLimitContract";
  }
  protected:
  explicit UpdateEnergyLimitContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kContractAddressFieldNumber = 2,
    kOriginEnergyLimitFieldNumber = 3,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes contract_address = 2;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // int64 origin_energy_limit = 3;
  void clear_origin_energy_limit();
  int64_t origin_energy_limit() const;
  void set_origin_energy_limit(int64_t value);
  private:
  int64_t _internal_origin_energy_limit() const;
  void _internal_set_origin_energy_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UpdateEnergyLimitContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    int64_t origin_energy_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SmartContractDataWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SmartContractDataWrapper) */ {
 public:
  inline SmartContractDataWrapper() : SmartContractDataWrapper(nullptr) {}
  ~SmartContractDataWrapper() override;
  explicit PROTOBUF_CONSTEXPR SmartContractDataWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartContractDataWrapper(const SmartContractDataWrapper& from);
  SmartContractDataWrapper(SmartContractDataWrapper&& from) noexcept
    : SmartContractDataWrapper() {
    *this = ::std::move(from);
  }

  inline SmartContractDataWrapper& operator=(const SmartContractDataWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartContractDataWrapper& operator=(SmartContractDataWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartContractDataWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartContractDataWrapper* internal_default_instance() {
    return reinterpret_cast<const SmartContractDataWrapper*>(
               &_SmartContractDataWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SmartContractDataWrapper& a, SmartContractDataWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartContractDataWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartContractDataWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartContractDataWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartContractDataWrapper>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartContractDataWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SmartContractDataWrapper";
  }
  protected:
  explicit SmartContractDataWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimecodeFieldNumber = 2,
    kSmartContractFieldNumber = 1,
    kContractStateFieldNumber = 3,
  };
  // bytes runtimecode = 2;
  void clear_runtimecode();
  const std::string& runtimecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtimecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtimecode();
  PROTOBUF_NODISCARD std::string* release_runtimecode();
  void set_allocated_runtimecode(std::string* runtimecode);
  private:
  const std::string& _internal_runtimecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtimecode(const std::string& value);
  std::string* _internal_mutable_runtimecode();
  public:

  // .protocol.SmartContract smart_contract = 1;
  bool has_smart_contract() const;
  private:
  bool _internal_has_smart_contract() const;
  public:
  void clear_smart_contract();
  const ::protocol::SmartContract& smart_contract() const;
  PROTOBUF_NODISCARD ::protocol::SmartContract* release_smart_contract();
  ::protocol::SmartContract* mutable_smart_contract();
  void set_allocated_smart_contract(::protocol::SmartContract* smart_contract);
  private:
  const ::protocol::SmartContract& _internal_smart_contract() const;
  ::protocol::SmartContract* _internal_mutable_smart_contract();
  public:
  void unsafe_arena_set_allocated_smart_contract(
      ::protocol::SmartContract* smart_contract);
  ::protocol::SmartContract* unsafe_arena_release_smart_contract();

  // .protocol.ContractState contract_state = 3;
  bool has_contract_state() const;
  private:
  bool _internal_has_contract_state() const;
  public:
  void clear_contract_state();
  const ::protocol::ContractState& contract_state() const;
  PROTOBUF_NODISCARD ::protocol::ContractState* release_contract_state();
  ::protocol::ContractState* mutable_contract_state();
  void set_allocated_contract_state(::protocol::ContractState* contract_state);
  private:
  const ::protocol::ContractState& _internal_contract_state() const;
  ::protocol::ContractState* _internal_mutable_contract_state();
  public:
  void unsafe_arena_set_allocated_contract_state(
      ::protocol::ContractState* contract_state);
  ::protocol::ContractState* unsafe_arena_release_contract_state();

  // @@protoc_insertion_point(class_scope:protocol.SmartContractDataWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtimecode_;
    ::protocol::SmartContract* smart_contract_;
    ::protocol::ContractState* contract_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BuyStorageBytesContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BuyStorageBytesContract) */ {
 public:
  inline BuyStorageBytesContract() : BuyStorageBytesContract(nullptr) {}
  ~BuyStorageBytesContract() override;
  explicit PROTOBUF_CONSTEXPR BuyStorageBytesContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyStorageBytesContract(const BuyStorageBytesContract& from);
  BuyStorageBytesContract(BuyStorageBytesContract&& from) noexcept
    : BuyStorageBytesContract() {
    *this = ::std::move(from);
  }

  inline BuyStorageBytesContract& operator=(const BuyStorageBytesContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyStorageBytesContract& operator=(BuyStorageBytesContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyStorageBytesContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyStorageBytesContract* internal_default_instance() {
    return reinterpret_cast<const BuyStorageBytesContract*>(
               &_BuyStorageBytesContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(BuyStorageBytesContract& a, BuyStorageBytesContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyStorageBytesContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyStorageBytesContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyStorageBytesContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyStorageBytesContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyStorageBytesContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BuyStorageBytesContract";
  }
  protected:
  explicit BuyStorageBytesContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kBytesFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 bytes = 2;
  void clear_bytes();
  int64_t bytes() const;
  void set_bytes(int64_t value);
  private:
  int64_t _internal_bytes() const;
  void _internal_set_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BuyStorageBytesContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BuyStorageContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BuyStorageContract) */ {
 public:
  inline BuyStorageContract() : BuyStorageContract(nullptr) {}
  ~BuyStorageContract() override;
  explicit PROTOBUF_CONSTEXPR BuyStorageContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyStorageContract(const BuyStorageContract& from);
  BuyStorageContract(BuyStorageContract&& from) noexcept
    : BuyStorageContract() {
    *this = ::std::move(from);
  }

  inline BuyStorageContract& operator=(const BuyStorageContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyStorageContract& operator=(BuyStorageContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyStorageContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyStorageContract* internal_default_instance() {
    return reinterpret_cast<const BuyStorageContract*>(
               &_BuyStorageContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(BuyStorageContract& a, BuyStorageContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyStorageContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyStorageContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyStorageContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyStorageContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyStorageContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BuyStorageContract";
  }
  protected:
  explicit BuyStorageContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kQuantFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 quant = 2;
  void clear_quant();
  int64_t quant() const;
  void set_quant(int64_t value);
  private:
  int64_t _internal_quant() const;
  void _internal_set_quant(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BuyStorageContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t quant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class SellStorageContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SellStorageContract) */ {
 public:
  inline SellStorageContract() : SellStorageContract(nullptr) {}
  ~SellStorageContract() override;
  explicit PROTOBUF_CONSTEXPR SellStorageContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellStorageContract(const SellStorageContract& from);
  SellStorageContract(SellStorageContract&& from) noexcept
    : SellStorageContract() {
    *this = ::std::move(from);
  }

  inline SellStorageContract& operator=(const SellStorageContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellStorageContract& operator=(SellStorageContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellStorageContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellStorageContract* internal_default_instance() {
    return reinterpret_cast<const SellStorageContract*>(
               &_SellStorageContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(SellStorageContract& a, SellStorageContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SellStorageContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellStorageContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellStorageContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SellStorageContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellStorageContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SellStorageContract";
  }
  protected:
  explicit SellStorageContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kStorageBytesFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 storage_bytes = 2;
  void clear_storage_bytes();
  int64_t storage_bytes() const;
  void set_storage_bytes(int64_t value);
  private:
  int64_t _internal_storage_bytes() const;
  void _internal_set_storage_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SellStorageContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int64_t storage_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class UpdateBrokerageContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UpdateBrokerageContract) */ {
 public:
  inline UpdateBrokerageContract() : UpdateBrokerageContract(nullptr) {}
  ~UpdateBrokerageContract() override;
  explicit PROTOBUF_CONSTEXPR UpdateBrokerageContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBrokerageContract(const UpdateBrokerageContract& from);
  UpdateBrokerageContract(UpdateBrokerageContract&& from) noexcept
    : UpdateBrokerageContract() {
    *this = ::std::move(from);
  }

  inline UpdateBrokerageContract& operator=(const UpdateBrokerageContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBrokerageContract& operator=(UpdateBrokerageContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBrokerageContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBrokerageContract* internal_default_instance() {
    return reinterpret_cast<const UpdateBrokerageContract*>(
               &_UpdateBrokerageContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(UpdateBrokerageContract& a, UpdateBrokerageContract& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBrokerageContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBrokerageContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBrokerageContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateBrokerageContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBrokerageContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UpdateBrokerageContract";
  }
  protected:
  explicit UpdateBrokerageContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kBrokerageFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int32 brokerage = 2;
  void clear_brokerage();
  int32_t brokerage() const;
  void set_brokerage(int32_t value);
  private:
  int32_t _internal_brokerage() const;
  void _internal_set_brokerage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UpdateBrokerageContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    int32_t brokerage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class VoteAssetContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.VoteAssetContract) */ {
 public:
  inline VoteAssetContract() : VoteAssetContract(nullptr) {}
  ~VoteAssetContract() override;
  explicit PROTOBUF_CONSTEXPR VoteAssetContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteAssetContract(const VoteAssetContract& from);
  VoteAssetContract(VoteAssetContract&& from) noexcept
    : VoteAssetContract() {
    *this = ::std::move(from);
  }

  inline VoteAssetContract& operator=(const VoteAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteAssetContract& operator=(VoteAssetContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteAssetContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteAssetContract* internal_default_instance() {
    return reinterpret_cast<const VoteAssetContract*>(
               &_VoteAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(VoteAssetContract& a, VoteAssetContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteAssetContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteAssetContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteAssetContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteAssetContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteAssetContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.VoteAssetContract";
  }
  protected:
  explicit VoteAssetContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteAddressFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
    kSupportFieldNumber = 3,
    kCountFieldNumber = 5,
  };
  // repeated bytes vote_address = 2;
  int vote_address_size() const;
  private:
  int _internal_vote_address_size() const;
  public:
  void clear_vote_address();
  const std::string& vote_address(int index) const;
  std::string* mutable_vote_address(int index);
  void set_vote_address(int index, const std::string& value);
  void set_vote_address(int index, std::string&& value);
  void set_vote_address(int index, const char* value);
  void set_vote_address(int index, const void* value, size_t size);
  std::string* add_vote_address();
  void add_vote_address(const std::string& value);
  void add_vote_address(std::string&& value);
  void add_vote_address(const char* value);
  void add_vote_address(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vote_address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vote_address();
  private:
  const std::string& _internal_vote_address(int index) const;
  std::string* _internal_add_vote_address();
  public:

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bool support = 3;
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // int32 count = 5;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.VoteAssetContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vote_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    bool support_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class WitnessCreateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.WitnessCreateContract) */ {
 public:
  inline WitnessCreateContract() : WitnessCreateContract(nullptr) {}
  ~WitnessCreateContract() override;
  explicit PROTOBUF_CONSTEXPR WitnessCreateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WitnessCreateContract(const WitnessCreateContract& from);
  WitnessCreateContract(WitnessCreateContract&& from) noexcept
    : WitnessCreateContract() {
    *this = ::std::move(from);
  }

  inline WitnessCreateContract& operator=(const WitnessCreateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WitnessCreateContract& operator=(WitnessCreateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WitnessCreateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WitnessCreateContract* internal_default_instance() {
    return reinterpret_cast<const WitnessCreateContract*>(
               &_WitnessCreateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(WitnessCreateContract& a, WitnessCreateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WitnessCreateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WitnessCreateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WitnessCreateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WitnessCreateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WitnessCreateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.WitnessCreateContract";
  }
  protected:
  explicit WitnessCreateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:protocol.WitnessCreateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class WitnessUpdateContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.WitnessUpdateContract) */ {
 public:
  inline WitnessUpdateContract() : WitnessUpdateContract(nullptr) {}
  ~WitnessUpdateContract() override;
  explicit PROTOBUF_CONSTEXPR WitnessUpdateContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WitnessUpdateContract(const WitnessUpdateContract& from);
  WitnessUpdateContract(WitnessUpdateContract&& from) noexcept
    : WitnessUpdateContract() {
    *this = ::std::move(from);
  }

  inline WitnessUpdateContract& operator=(const WitnessUpdateContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WitnessUpdateContract& operator=(WitnessUpdateContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WitnessUpdateContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WitnessUpdateContract* internal_default_instance() {
    return reinterpret_cast<const WitnessUpdateContract*>(
               &_WitnessUpdateContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(WitnessUpdateContract& a, WitnessUpdateContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WitnessUpdateContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WitnessUpdateContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WitnessUpdateContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WitnessUpdateContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WitnessUpdateContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.WitnessUpdateContract";
  }
  protected:
  explicit WitnessUpdateContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerAddressFieldNumber = 1,
    kUpdateUrlFieldNumber = 12,
  };
  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes update_url = 12;
  void clear_update_url();
  const std::string& update_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_url();
  PROTOBUF_NODISCARD std::string* release_update_url();
  void set_allocated_update_url(std::string* update_url);
  private:
  const std::string& _internal_update_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_url(const std::string& value);
  std::string* _internal_mutable_update_url();
  public:

  // @@protoc_insertion_point(class_scope:protocol.WitnessUpdateContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class VoteWitnessContract_Vote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.VoteWitnessContract.Vote) */ {
 public:
  inline VoteWitnessContract_Vote() : VoteWitnessContract_Vote(nullptr) {}
  ~VoteWitnessContract_Vote() override;
  explicit PROTOBUF_CONSTEXPR VoteWitnessContract_Vote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteWitnessContract_Vote(const VoteWitnessContract_Vote& from);
  VoteWitnessContract_Vote(VoteWitnessContract_Vote&& from) noexcept
    : VoteWitnessContract_Vote() {
    *this = ::std::move(from);
  }

  inline VoteWitnessContract_Vote& operator=(const VoteWitnessContract_Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteWitnessContract_Vote& operator=(VoteWitnessContract_Vote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteWitnessContract_Vote& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteWitnessContract_Vote* internal_default_instance() {
    return reinterpret_cast<const VoteWitnessContract_Vote*>(
               &_VoteWitnessContract_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(VoteWitnessContract_Vote& a, VoteWitnessContract_Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteWitnessContract_Vote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteWitnessContract_Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteWitnessContract_Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteWitnessContract_Vote>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteWitnessContract_Vote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.VoteWitnessContract.Vote";
  }
  protected:
  explicit VoteWitnessContract_Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteAddressFieldNumber = 1,
    kVoteCountFieldNumber = 2,
  };
  // bytes vote_address = 1;
  void clear_vote_address();
  const std::string& vote_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vote_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vote_address();
  PROTOBUF_NODISCARD std::string* release_vote_address();
  void set_allocated_vote_address(std::string* vote_address);
  private:
  const std::string& _internal_vote_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_address(const std::string& value);
  std::string* _internal_mutable_vote_address();
  public:

  // int64 vote_count = 2;
  void clear_vote_count();
  int64_t vote_count() const;
  void set_vote_count(int64_t value);
  private:
  int64_t _internal_vote_count() const;
  void _internal_set_vote_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.VoteWitnessContract.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_address_;
    int64_t vote_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class VoteWitnessContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.VoteWitnessContract) */ {
 public:
  inline VoteWitnessContract() : VoteWitnessContract(nullptr) {}
  ~VoteWitnessContract() override;
  explicit PROTOBUF_CONSTEXPR VoteWitnessContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteWitnessContract(const VoteWitnessContract& from);
  VoteWitnessContract(VoteWitnessContract&& from) noexcept
    : VoteWitnessContract() {
    *this = ::std::move(from);
  }

  inline VoteWitnessContract& operator=(const VoteWitnessContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteWitnessContract& operator=(VoteWitnessContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteWitnessContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteWitnessContract* internal_default_instance() {
    return reinterpret_cast<const VoteWitnessContract*>(
               &_VoteWitnessContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(VoteWitnessContract& a, VoteWitnessContract& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteWitnessContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteWitnessContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteWitnessContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteWitnessContract>(arena);
  }
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteWitnessContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.VoteWitnessContract";
  }
  protected:
  explicit VoteWitnessContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VoteWitnessContract_Vote Vote;

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
    kSupportFieldNumber = 3,
  };
  // repeated .protocol.VoteWitnessContract.Vote votes = 2;
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::protocol::VoteWitnessContract_Vote* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::VoteWitnessContract_Vote >*
      mutable_votes();
  private:
  const ::protocol::VoteWitnessContract_Vote& _internal_votes(int index) const;
  ::protocol::VoteWitnessContract_Vote* _internal_add_votes();
  public:
  const ::protocol::VoteWitnessContract_Vote& votes(int index) const;
  ::protocol::VoteWitnessContract_Vote* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::VoteWitnessContract_Vote >&
      votes() const;

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bool support = 3;
  void clear_support();
  bool support() const;
  void set_support(bool value);
  private:
  bool _internal_support() const;
  void _internal_set_support(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.VoteWitnessContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::VoteWitnessContract_Vote > votes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
    bool support_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TronInternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountId

// bytes name = 1;
inline void AccountId::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AccountId::name() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountId::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountId.name)
}
inline std::string* AccountId::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.name)
  return _s;
}
inline const std::string& AccountId::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AccountId::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountId::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountId::release_name() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.name)
  return _impl_.name_.Release();
}
inline void AccountId::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.name)
}

// bytes address = 2;
inline void AccountId::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& AccountId::address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountId::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountId.address)
}
inline std::string* AccountId::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.address)
  return _s;
}
inline const std::string& AccountId::_internal_address() const {
  return _impl_.address_.Get();
}
inline void AccountId::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountId::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountId::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.address)
  return _impl_.address_.Release();
}
inline void AccountId::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.address)
}

// -------------------------------------------------------------------

// authority

// .protocol.AccountId account = 1;
inline bool authority::_internal_has_account() const {
  return this != internal_default_instance() && _impl_.account_ != nullptr;
}
inline bool authority::has_account() const {
  return _internal_has_account();
}
inline void authority::clear_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_ != nullptr) {
    delete _impl_.account_;
  }
  _impl_.account_ = nullptr;
}
inline const ::protocol::AccountId& authority::_internal_account() const {
  const ::protocol::AccountId* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::AccountId&>(
      ::protocol::_AccountId_default_instance_);
}
inline const ::protocol::AccountId& authority::account() const {
  // @@protoc_insertion_point(field_get:protocol.authority.account)
  return _internal_account();
}
inline void authority::unsafe_arena_set_allocated_account(
    ::protocol::AccountId* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.authority.account)
}
inline ::protocol::AccountId* authority::release_account() {
  
  ::protocol::AccountId* temp = _impl_.account_;
  _impl_.account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::AccountId* authority::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:protocol.authority.account)
  
  ::protocol::AccountId* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::protocol::AccountId* authority::_internal_mutable_account() {
  
  if (_impl_.account_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::AccountId>(GetArenaForAllocation());
    _impl_.account_ = p;
  }
  return _impl_.account_;
}
inline ::protocol::AccountId* authority::mutable_account() {
  ::protocol::AccountId* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:protocol.authority.account)
  return _msg;
}
inline void authority::set_allocated_account(::protocol::AccountId* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_ = account;
  // @@protoc_insertion_point(field_set_allocated:protocol.authority.account)
}

// bytes permission_name = 2;
inline void authority::clear_permission_name() {
  _impl_.permission_name_.ClearToEmpty();
}
inline const std::string& authority::permission_name() const {
  // @@protoc_insertion_point(field_get:protocol.authority.permission_name)
  return _internal_permission_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void authority::set_permission_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.authority.permission_name)
}
inline std::string* authority::mutable_permission_name() {
  std::string* _s = _internal_mutable_permission_name();
  // @@protoc_insertion_point(field_mutable:protocol.authority.permission_name)
  return _s;
}
inline const std::string& authority::_internal_permission_name() const {
  return _impl_.permission_name_.Get();
}
inline void authority::_internal_set_permission_name(const std::string& value) {
  
  _impl_.permission_name_.Set(value, GetArenaForAllocation());
}
inline std::string* authority::_internal_mutable_permission_name() {
  
  return _impl_.permission_name_.Mutable(GetArenaForAllocation());
}
inline std::string* authority::release_permission_name() {
  // @@protoc_insertion_point(field_release:protocol.authority.permission_name)
  return _impl_.permission_name_.Release();
}
inline void authority::set_allocated_permission_name(std::string* permission_name) {
  if (permission_name != nullptr) {
    
  } else {
    
  }
  _impl_.permission_name_.SetAllocated(permission_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_name_.IsDefault()) {
    _impl_.permission_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.authority.permission_name)
}

// -------------------------------------------------------------------

// Permission

// .protocol.Permission.PermissionType type = 1;
inline void Permission::clear_type() {
  _impl_.type_ = 0;
}
inline ::protocol::Permission_PermissionType Permission::_internal_type() const {
  return static_cast< ::protocol::Permission_PermissionType >(_impl_.type_);
}
inline ::protocol::Permission_PermissionType Permission::type() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.type)
  return _internal_type();
}
inline void Permission::_internal_set_type(::protocol::Permission_PermissionType value) {
  
  _impl_.type_ = value;
}
inline void Permission::set_type(::protocol::Permission_PermissionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.type)
}

// int32 id = 2;
inline void Permission::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Permission::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Permission::id() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.id)
  return _internal_id();
}
inline void Permission::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Permission::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.id)
}

// string permission_name = 3;
inline void Permission::clear_permission_name() {
  _impl_.permission_name_.ClearToEmpty();
}
inline const std::string& Permission::permission_name() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.permission_name)
  return _internal_permission_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_permission_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Permission.permission_name)
}
inline std::string* Permission::mutable_permission_name() {
  std::string* _s = _internal_mutable_permission_name();
  // @@protoc_insertion_point(field_mutable:protocol.Permission.permission_name)
  return _s;
}
inline const std::string& Permission::_internal_permission_name() const {
  return _impl_.permission_name_.Get();
}
inline void Permission::_internal_set_permission_name(const std::string& value) {
  
  _impl_.permission_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_permission_name() {
  
  return _impl_.permission_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_permission_name() {
  // @@protoc_insertion_point(field_release:protocol.Permission.permission_name)
  return _impl_.permission_name_.Release();
}
inline void Permission::set_allocated_permission_name(std::string* permission_name) {
  if (permission_name != nullptr) {
    
  } else {
    
  }
  _impl_.permission_name_.SetAllocated(permission_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_name_.IsDefault()) {
    _impl_.permission_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Permission.permission_name)
}

// int64 threshold = 4;
inline void Permission::clear_threshold() {
  _impl_.threshold_ = int64_t{0};
}
inline int64_t Permission::_internal_threshold() const {
  return _impl_.threshold_;
}
inline int64_t Permission::threshold() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.threshold)
  return _internal_threshold();
}
inline void Permission::_internal_set_threshold(int64_t value) {
  
  _impl_.threshold_ = value;
}
inline void Permission::set_threshold(int64_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.threshold)
}

// int32 parent_id = 5;
inline void Permission::clear_parent_id() {
  _impl_.parent_id_ = 0;
}
inline int32_t Permission::_internal_parent_id() const {
  return _impl_.parent_id_;
}
inline int32_t Permission::parent_id() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.parent_id)
  return _internal_parent_id();
}
inline void Permission::_internal_set_parent_id(int32_t value) {
  
  _impl_.parent_id_ = value;
}
inline void Permission::set_parent_id(int32_t value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.parent_id)
}

// bytes operations = 6;
inline void Permission::clear_operations() {
  _impl_.operations_.ClearToEmpty();
}
inline const std::string& Permission::operations() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.operations)
  return _internal_operations();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_operations(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operations_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Permission.operations)
}
inline std::string* Permission::mutable_operations() {
  std::string* _s = _internal_mutable_operations();
  // @@protoc_insertion_point(field_mutable:protocol.Permission.operations)
  return _s;
}
inline const std::string& Permission::_internal_operations() const {
  return _impl_.operations_.Get();
}
inline void Permission::_internal_set_operations(const std::string& value) {
  
  _impl_.operations_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_operations() {
  
  return _impl_.operations_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_operations() {
  // @@protoc_insertion_point(field_release:protocol.Permission.operations)
  return _impl_.operations_.Release();
}
inline void Permission::set_allocated_operations(std::string* operations) {
  if (operations != nullptr) {
    
  } else {
    
  }
  _impl_.operations_.SetAllocated(operations, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operations_.IsDefault()) {
    _impl_.operations_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Permission.operations)
}

// repeated .protocol.Key keys = 7;
inline int Permission::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int Permission::keys_size() const {
  return _internal_keys_size();
}
inline void Permission::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::protocol::Key* Permission::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Permission.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >*
Permission::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Permission.keys)
  return &_impl_.keys_;
}
inline const ::protocol::Key& Permission::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::protocol::Key& Permission::keys(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Permission.keys)
  return _internal_keys(index);
}
inline ::protocol::Key* Permission::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::protocol::Key* Permission::add_keys() {
  ::protocol::Key* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:protocol.Permission.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >&
Permission::keys() const {
  // @@protoc_insertion_point(field_list:protocol.Permission.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// MarketOrderDetail

// bytes makerOrderId = 1;
inline void MarketOrderDetail::clear_makerorderid() {
  _impl_.makerorderid_.ClearToEmpty();
}
inline const std::string& MarketOrderDetail::makerorderid() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.makerOrderId)
  return _internal_makerorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderDetail::set_makerorderid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.makerorderid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.makerOrderId)
}
inline std::string* MarketOrderDetail::mutable_makerorderid() {
  std::string* _s = _internal_mutable_makerorderid();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderDetail.makerOrderId)
  return _s;
}
inline const std::string& MarketOrderDetail::_internal_makerorderid() const {
  return _impl_.makerorderid_.Get();
}
inline void MarketOrderDetail::_internal_set_makerorderid(const std::string& value) {
  
  _impl_.makerorderid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::_internal_mutable_makerorderid() {
  
  return _impl_.makerorderid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::release_makerorderid() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderDetail.makerOrderId)
  return _impl_.makerorderid_.Release();
}
inline void MarketOrderDetail::set_allocated_makerorderid(std::string* makerorderid) {
  if (makerorderid != nullptr) {
    
  } else {
    
  }
  _impl_.makerorderid_.SetAllocated(makerorderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.makerorderid_.IsDefault()) {
    _impl_.makerorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderDetail.makerOrderId)
}

// bytes takerOrderId = 2;
inline void MarketOrderDetail::clear_takerorderid() {
  _impl_.takerorderid_.ClearToEmpty();
}
inline const std::string& MarketOrderDetail::takerorderid() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.takerOrderId)
  return _internal_takerorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderDetail::set_takerorderid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.takerorderid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.takerOrderId)
}
inline std::string* MarketOrderDetail::mutable_takerorderid() {
  std::string* _s = _internal_mutable_takerorderid();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderDetail.takerOrderId)
  return _s;
}
inline const std::string& MarketOrderDetail::_internal_takerorderid() const {
  return _impl_.takerorderid_.Get();
}
inline void MarketOrderDetail::_internal_set_takerorderid(const std::string& value) {
  
  _impl_.takerorderid_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::_internal_mutable_takerorderid() {
  
  return _impl_.takerorderid_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::release_takerorderid() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderDetail.takerOrderId)
  return _impl_.takerorderid_.Release();
}
inline void MarketOrderDetail::set_allocated_takerorderid(std::string* takerorderid) {
  if (takerorderid != nullptr) {
    
  } else {
    
  }
  _impl_.takerorderid_.SetAllocated(takerorderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.takerorderid_.IsDefault()) {
    _impl_.takerorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderDetail.takerOrderId)
}

// int64 fillSellQuantity = 3;
inline void MarketOrderDetail::clear_fillsellquantity() {
  _impl_.fillsellquantity_ = int64_t{0};
}
inline int64_t MarketOrderDetail::_internal_fillsellquantity() const {
  return _impl_.fillsellquantity_;
}
inline int64_t MarketOrderDetail::fillsellquantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.fillSellQuantity)
  return _internal_fillsellquantity();
}
inline void MarketOrderDetail::_internal_set_fillsellquantity(int64_t value) {
  
  _impl_.fillsellquantity_ = value;
}
inline void MarketOrderDetail::set_fillsellquantity(int64_t value) {
  _internal_set_fillsellquantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.fillSellQuantity)
}

// int64 fillBuyQuantity = 4;
inline void MarketOrderDetail::clear_fillbuyquantity() {
  _impl_.fillbuyquantity_ = int64_t{0};
}
inline int64_t MarketOrderDetail::_internal_fillbuyquantity() const {
  return _impl_.fillbuyquantity_;
}
inline int64_t MarketOrderDetail::fillbuyquantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.fillBuyQuantity)
  return _internal_fillbuyquantity();
}
inline void MarketOrderDetail::_internal_set_fillbuyquantity(int64_t value) {
  
  _impl_.fillbuyquantity_ = value;
}
inline void MarketOrderDetail::set_fillbuyquantity(int64_t value) {
  _internal_set_fillbuyquantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.fillBuyQuantity)
}

// -------------------------------------------------------------------

// Key

// bytes address = 1;
inline void Key::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Key::address() const {
  // @@protoc_insertion_point(field_get:protocol.Key.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Key::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Key.address)
}
inline std::string* Key::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Key.address)
  return _s;
}
inline const std::string& Key::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Key::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Key::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Key.address)
  return _impl_.address_.Release();
}
inline void Key::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Key.address)
}

// int64 weight = 2;
inline void Key::clear_weight() {
  _impl_.weight_ = int64_t{0};
}
inline int64_t Key::_internal_weight() const {
  return _impl_.weight_;
}
inline int64_t Key::weight() const {
  // @@protoc_insertion_point(field_get:protocol.Key.weight)
  return _internal_weight();
}
inline void Key::_internal_set_weight(int64_t value) {
  
  _impl_.weight_ = value;
}
inline void Key::set_weight(int64_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:protocol.Key.weight)
}

// -------------------------------------------------------------------

// Transaction_Contract

// .protocol.Transaction.Contract.ContractType type = 1;
inline void Transaction_Contract::clear_type() {
  _impl_.type_ = 0;
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::_internal_type() const {
  return static_cast< ::protocol::Transaction_Contract_ContractType >(_impl_.type_);
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.type)
  return _internal_type();
}
inline void Transaction_Contract::_internal_set_type(::protocol::Transaction_Contract_ContractType value) {
  
  _impl_.type_ = value;
}
inline void Transaction_Contract::set_type(::protocol::Transaction_Contract_ContractType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Transaction_Contract::_internal_has_parameter() const {
  return this != internal_default_instance() && _impl_.parameter_ != nullptr;
}
inline bool Transaction_Contract::has_parameter() const {
  return _internal_has_parameter();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Transaction_Contract::_internal_parameter() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.parameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Transaction_Contract::parameter() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.parameter)
  return _internal_parameter();
}
inline void Transaction_Contract::unsafe_arena_set_allocated_parameter(
    ::PROTOBUF_NAMESPACE_ID::Any* parameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameter_);
  }
  _impl_.parameter_ = parameter;
  if (parameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Transaction.Contract.parameter)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::release_parameter() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.parameter_;
  _impl_.parameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::unsafe_arena_release_parameter() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.parameter)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.parameter_;
  _impl_.parameter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::_internal_mutable_parameter() {
  
  if (_impl_.parameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.parameter_ = p;
  }
  return _impl_.parameter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::mutable_parameter() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.parameter)
  return _msg;
}
inline void Transaction_Contract::set_allocated_parameter(::PROTOBUF_NAMESPACE_ID::Any* parameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameter_);
  }
  if (parameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameter));
    if (message_arena != submessage_arena) {
      parameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.parameter)
}

// bytes provider = 3;
inline void Transaction_Contract::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& Transaction_Contract::provider() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Contract::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.provider)
}
inline std::string* Transaction_Contract::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.provider)
  return _s;
}
inline const std::string& Transaction_Contract::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void Transaction_Contract::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_Contract::release_provider() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.provider)
  return _impl_.provider_.Release();
}
inline void Transaction_Contract::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.provider)
}

// bytes ContractName = 4;
inline void Transaction_Contract::clear_contractname() {
  _impl_.contractname_.ClearToEmpty();
}
inline const std::string& Transaction_Contract::contractname() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.ContractName)
  return _internal_contractname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Contract::set_contractname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contractname_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.ContractName)
}
inline std::string* Transaction_Contract::mutable_contractname() {
  std::string* _s = _internal_mutable_contractname();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.ContractName)
  return _s;
}
inline const std::string& Transaction_Contract::_internal_contractname() const {
  return _impl_.contractname_.Get();
}
inline void Transaction_Contract::_internal_set_contractname(const std::string& value) {
  
  _impl_.contractname_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::_internal_mutable_contractname() {
  
  return _impl_.contractname_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_Contract::release_contractname() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.ContractName)
  return _impl_.contractname_.Release();
}
inline void Transaction_Contract::set_allocated_contractname(std::string* contractname) {
  if (contractname != nullptr) {
    
  } else {
    
  }
  _impl_.contractname_.SetAllocated(contractname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractname_.IsDefault()) {
    _impl_.contractname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.ContractName)
}

// int32 Permission_id = 5;
inline void Transaction_Contract::clear_permission_id() {
  _impl_.permission_id_ = 0;
}
inline int32_t Transaction_Contract::_internal_permission_id() const {
  return _impl_.permission_id_;
}
inline int32_t Transaction_Contract::permission_id() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.Permission_id)
  return _internal_permission_id();
}
inline void Transaction_Contract::_internal_set_permission_id(int32_t value) {
  
  _impl_.permission_id_ = value;
}
inline void Transaction_Contract::set_permission_id(int32_t value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.Permission_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Transaction_Result

// int64 fee = 1;
inline void Transaction_Result::clear_fee() {
  _impl_.fee_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_fee() const {
  return _impl_.fee_;
}
inline int64_t Transaction_Result::fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.fee)
  return _internal_fee();
}
inline void Transaction_Result::_internal_set_fee(int64_t value) {
  
  _impl_.fee_ = value;
}
inline void Transaction_Result::set_fee(int64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.fee)
}

// .protocol.Transaction.Result.code ret = 2;
inline void Transaction_Result::clear_ret() {
  _impl_.ret_ = 0;
}
inline ::protocol::Transaction_Result_code Transaction_Result::_internal_ret() const {
  return static_cast< ::protocol::Transaction_Result_code >(_impl_.ret_);
}
inline ::protocol::Transaction_Result_code Transaction_Result::ret() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.ret)
  return _internal_ret();
}
inline void Transaction_Result::_internal_set_ret(::protocol::Transaction_Result_code value) {
  
  _impl_.ret_ = value;
}
inline void Transaction_Result::set_ret(::protocol::Transaction_Result_code value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.ret)
}

// .protocol.Transaction.Result.contractResult contractRet = 3;
inline void Transaction_Result::clear_contractret() {
  _impl_.contractret_ = 0;
}
inline ::protocol::Transaction_Result_contractResult Transaction_Result::_internal_contractret() const {
  return static_cast< ::protocol::Transaction_Result_contractResult >(_impl_.contractret_);
}
inline ::protocol::Transaction_Result_contractResult Transaction_Result::contractret() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.contractRet)
  return _internal_contractret();
}
inline void Transaction_Result::_internal_set_contractret(::protocol::Transaction_Result_contractResult value) {
  
  _impl_.contractret_ = value;
}
inline void Transaction_Result::set_contractret(::protocol::Transaction_Result_contractResult value) {
  _internal_set_contractret(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.contractRet)
}

// string assetIssueID = 14;
inline void Transaction_Result::clear_assetissueid() {
  _impl_.assetissueid_.ClearToEmpty();
}
inline const std::string& Transaction_Result::assetissueid() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.assetIssueID)
  return _internal_assetissueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Result::set_assetissueid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.assetissueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.assetIssueID)
}
inline std::string* Transaction_Result::mutable_assetissueid() {
  std::string* _s = _internal_mutable_assetissueid();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.assetIssueID)
  return _s;
}
inline const std::string& Transaction_Result::_internal_assetissueid() const {
  return _impl_.assetissueid_.Get();
}
inline void Transaction_Result::_internal_set_assetissueid(const std::string& value) {
  
  _impl_.assetissueid_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_Result::_internal_mutable_assetissueid() {
  
  return _impl_.assetissueid_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_Result::release_assetissueid() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Result.assetIssueID)
  return _impl_.assetissueid_.Release();
}
inline void Transaction_Result::set_allocated_assetissueid(std::string* assetissueid) {
  if (assetissueid != nullptr) {
    
  } else {
    
  }
  _impl_.assetissueid_.SetAllocated(assetissueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assetissueid_.IsDefault()) {
    _impl_.assetissueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Result.assetIssueID)
}

// int64 withdraw_amount = 15;
inline void Transaction_Result::clear_withdraw_amount() {
  _impl_.withdraw_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_withdraw_amount() const {
  return _impl_.withdraw_amount_;
}
inline int64_t Transaction_Result::withdraw_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.withdraw_amount)
  return _internal_withdraw_amount();
}
inline void Transaction_Result::_internal_set_withdraw_amount(int64_t value) {
  
  _impl_.withdraw_amount_ = value;
}
inline void Transaction_Result::set_withdraw_amount(int64_t value) {
  _internal_set_withdraw_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.withdraw_amount)
}

// int64 unfreeze_amount = 16;
inline void Transaction_Result::clear_unfreeze_amount() {
  _impl_.unfreeze_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_unfreeze_amount() const {
  return _impl_.unfreeze_amount_;
}
inline int64_t Transaction_Result::unfreeze_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.unfreeze_amount)
  return _internal_unfreeze_amount();
}
inline void Transaction_Result::_internal_set_unfreeze_amount(int64_t value) {
  
  _impl_.unfreeze_amount_ = value;
}
inline void Transaction_Result::set_unfreeze_amount(int64_t value) {
  _internal_set_unfreeze_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.unfreeze_amount)
}

// int64 exchange_received_amount = 18;
inline void Transaction_Result::clear_exchange_received_amount() {
  _impl_.exchange_received_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_received_amount() const {
  return _impl_.exchange_received_amount_;
}
inline int64_t Transaction_Result::exchange_received_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_received_amount)
  return _internal_exchange_received_amount();
}
inline void Transaction_Result::_internal_set_exchange_received_amount(int64_t value) {
  
  _impl_.exchange_received_amount_ = value;
}
inline void Transaction_Result::set_exchange_received_amount(int64_t value) {
  _internal_set_exchange_received_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_received_amount)
}

// int64 exchange_inject_another_amount = 19;
inline void Transaction_Result::clear_exchange_inject_another_amount() {
  _impl_.exchange_inject_another_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_inject_another_amount() const {
  return _impl_.exchange_inject_another_amount_;
}
inline int64_t Transaction_Result::exchange_inject_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_inject_another_amount)
  return _internal_exchange_inject_another_amount();
}
inline void Transaction_Result::_internal_set_exchange_inject_another_amount(int64_t value) {
  
  _impl_.exchange_inject_another_amount_ = value;
}
inline void Transaction_Result::set_exchange_inject_another_amount(int64_t value) {
  _internal_set_exchange_inject_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_inject_another_amount)
}

// int64 exchange_withdraw_another_amount = 20;
inline void Transaction_Result::clear_exchange_withdraw_another_amount() {
  _impl_.exchange_withdraw_another_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_withdraw_another_amount() const {
  return _impl_.exchange_withdraw_another_amount_;
}
inline int64_t Transaction_Result::exchange_withdraw_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_withdraw_another_amount)
  return _internal_exchange_withdraw_another_amount();
}
inline void Transaction_Result::_internal_set_exchange_withdraw_another_amount(int64_t value) {
  
  _impl_.exchange_withdraw_another_amount_ = value;
}
inline void Transaction_Result::set_exchange_withdraw_another_amount(int64_t value) {
  _internal_set_exchange_withdraw_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_withdraw_another_amount)
}

// int64 exchange_id = 21;
inline void Transaction_Result::clear_exchange_id() {
  _impl_.exchange_id_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_id() const {
  return _impl_.exchange_id_;
}
inline int64_t Transaction_Result::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_id)
  return _internal_exchange_id();
}
inline void Transaction_Result::_internal_set_exchange_id(int64_t value) {
  
  _impl_.exchange_id_ = value;
}
inline void Transaction_Result::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_id)
}

// int64 shielded_transaction_fee = 22;
inline void Transaction_Result::clear_shielded_transaction_fee() {
  _impl_.shielded_transaction_fee_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_shielded_transaction_fee() const {
  return _impl_.shielded_transaction_fee_;
}
inline int64_t Transaction_Result::shielded_transaction_fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.shielded_transaction_fee)
  return _internal_shielded_transaction_fee();
}
inline void Transaction_Result::_internal_set_shielded_transaction_fee(int64_t value) {
  
  _impl_.shielded_transaction_fee_ = value;
}
inline void Transaction_Result::set_shielded_transaction_fee(int64_t value) {
  _internal_set_shielded_transaction_fee(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.shielded_transaction_fee)
}

// bytes orderId = 25;
inline void Transaction_Result::clear_orderid() {
  _impl_.orderid_.ClearToEmpty();
}
inline const std::string& Transaction_Result::orderid() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.orderId)
  return _internal_orderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Result::set_orderid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.orderid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.orderId)
}
inline std::string* Transaction_Result::mutable_orderid() {
  std::string* _s = _internal_mutable_orderid();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.orderId)
  return _s;
}
inline const std::string& Transaction_Result::_internal_orderid() const {
  return _impl_.orderid_.Get();
}
inline void Transaction_Result::_internal_set_orderid(const std::string& value) {
  
  _impl_.orderid_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_Result::_internal_mutable_orderid() {
  
  return _impl_.orderid_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_Result::release_orderid() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Result.orderId)
  return _impl_.orderid_.Release();
}
inline void Transaction_Result::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  _impl_.orderid_.SetAllocated(orderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.orderid_.IsDefault()) {
    _impl_.orderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Result.orderId)
}

// repeated .protocol.MarketOrderDetail orderDetails = 26;
inline int Transaction_Result::_internal_orderdetails_size() const {
  return _impl_.orderdetails_.size();
}
inline int Transaction_Result::orderdetails_size() const {
  return _internal_orderdetails_size();
}
inline void Transaction_Result::clear_orderdetails() {
  _impl_.orderdetails_.Clear();
}
inline ::protocol::MarketOrderDetail* Transaction_Result::mutable_orderdetails(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.orderDetails)
  return _impl_.orderdetails_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
Transaction_Result::mutable_orderdetails() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.Result.orderDetails)
  return &_impl_.orderdetails_;
}
inline const ::protocol::MarketOrderDetail& Transaction_Result::_internal_orderdetails(int index) const {
  return _impl_.orderdetails_.Get(index);
}
inline const ::protocol::MarketOrderDetail& Transaction_Result::orderdetails(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.orderDetails)
  return _internal_orderdetails(index);
}
inline ::protocol::MarketOrderDetail* Transaction_Result::_internal_add_orderdetails() {
  return _impl_.orderdetails_.Add();
}
inline ::protocol::MarketOrderDetail* Transaction_Result::add_orderdetails() {
  ::protocol::MarketOrderDetail* _add = _internal_add_orderdetails();
  // @@protoc_insertion_point(field_add:protocol.Transaction.Result.orderDetails)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
Transaction_Result::orderdetails() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.Result.orderDetails)
  return _impl_.orderdetails_;
}

// int64 withdraw_expire_amount = 27;
inline void Transaction_Result::clear_withdraw_expire_amount() {
  _impl_.withdraw_expire_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_withdraw_expire_amount() const {
  return _impl_.withdraw_expire_amount_;
}
inline int64_t Transaction_Result::withdraw_expire_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.withdraw_expire_amount)
  return _internal_withdraw_expire_amount();
}
inline void Transaction_Result::_internal_set_withdraw_expire_amount(int64_t value) {
  
  _impl_.withdraw_expire_amount_ = value;
}
inline void Transaction_Result::set_withdraw_expire_amount(int64_t value) {
  _internal_set_withdraw_expire_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.withdraw_expire_amount)
}

// map<string, int64> cancel_unfreezeV2_amount = 28;
inline int Transaction_Result::_internal_cancel_unfreezev2_amount_size() const {
  return _impl_.cancel_unfreezev2_amount_.size();
}
inline int Transaction_Result::cancel_unfreezev2_amount_size() const {
  return _internal_cancel_unfreezev2_amount_size();
}
inline void Transaction_Result::clear_cancel_unfreezev2_amount() {
  _impl_.cancel_unfreezev2_amount_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Transaction_Result::_internal_cancel_unfreezev2_amount() const {
  return _impl_.cancel_unfreezev2_amount_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Transaction_Result::cancel_unfreezev2_amount() const {
  // @@protoc_insertion_point(field_map:protocol.Transaction.Result.cancel_unfreezeV2_amount)
  return _internal_cancel_unfreezev2_amount();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Transaction_Result::_internal_mutable_cancel_unfreezev2_amount() {
  return _impl_.cancel_unfreezev2_amount_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Transaction_Result::mutable_cancel_unfreezev2_amount() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Transaction.Result.cancel_unfreezeV2_amount)
  return _internal_mutable_cancel_unfreezev2_amount();
}

// -------------------------------------------------------------------

// Transaction_raw

// bytes ref_block_bytes = 1;
inline void Transaction_raw::clear_ref_block_bytes() {
  _impl_.ref_block_bytes_.ClearToEmpty();
}
inline const std::string& Transaction_raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_bytes)
  return _internal_ref_block_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_ref_block_bytes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ref_block_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_bytes)
}
inline std::string* Transaction_raw::mutable_ref_block_bytes() {
  std::string* _s = _internal_mutable_ref_block_bytes();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_bytes)
  return _s;
}
inline const std::string& Transaction_raw::_internal_ref_block_bytes() const {
  return _impl_.ref_block_bytes_.Get();
}
inline void Transaction_raw::_internal_set_ref_block_bytes(const std::string& value) {
  
  _impl_.ref_block_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_ref_block_bytes() {
  
  return _impl_.ref_block_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_bytes)
  return _impl_.ref_block_bytes_.Release();
}
inline void Transaction_raw::set_allocated_ref_block_bytes(std::string* ref_block_bytes) {
  if (ref_block_bytes != nullptr) {
    
  } else {
    
  }
  _impl_.ref_block_bytes_.SetAllocated(ref_block_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ref_block_bytes_.IsDefault()) {
    _impl_.ref_block_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_bytes)
}

// int64 ref_block_num = 3;
inline void Transaction_raw::clear_ref_block_num() {
  _impl_.ref_block_num_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_ref_block_num() const {
  return _impl_.ref_block_num_;
}
inline int64_t Transaction_raw::ref_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_num)
  return _internal_ref_block_num();
}
inline void Transaction_raw::_internal_set_ref_block_num(int64_t value) {
  
  _impl_.ref_block_num_ = value;
}
inline void Transaction_raw::set_ref_block_num(int64_t value) {
  _internal_set_ref_block_num(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_num)
}

// bytes ref_block_hash = 4;
inline void Transaction_raw::clear_ref_block_hash() {
  _impl_.ref_block_hash_.ClearToEmpty();
}
inline const std::string& Transaction_raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_hash)
  return _internal_ref_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_ref_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ref_block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_hash)
}
inline std::string* Transaction_raw::mutable_ref_block_hash() {
  std::string* _s = _internal_mutable_ref_block_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_hash)
  return _s;
}
inline const std::string& Transaction_raw::_internal_ref_block_hash() const {
  return _impl_.ref_block_hash_.Get();
}
inline void Transaction_raw::_internal_set_ref_block_hash(const std::string& value) {
  
  _impl_.ref_block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_ref_block_hash() {
  
  return _impl_.ref_block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_hash)
  return _impl_.ref_block_hash_.Release();
}
inline void Transaction_raw::set_allocated_ref_block_hash(std::string* ref_block_hash) {
  if (ref_block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.ref_block_hash_.SetAllocated(ref_block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ref_block_hash_.IsDefault()) {
    _impl_.ref_block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void Transaction_raw::clear_expiration() {
  _impl_.expiration_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_expiration() const {
  return _impl_.expiration_;
}
inline int64_t Transaction_raw::expiration() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.expiration)
  return _internal_expiration();
}
inline void Transaction_raw::_internal_set_expiration(int64_t value) {
  
  _impl_.expiration_ = value;
}
inline void Transaction_raw::set_expiration(int64_t value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.expiration)
}

// repeated .protocol.authority auths = 9;
inline int Transaction_raw::_internal_auths_size() const {
  return _impl_.auths_.size();
}
inline int Transaction_raw::auths_size() const {
  return _internal_auths_size();
}
inline void Transaction_raw::clear_auths() {
  _impl_.auths_.Clear();
}
inline ::protocol::authority* Transaction_raw::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.auths)
  return _impl_.auths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >*
Transaction_raw::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.auths)
  return &_impl_.auths_;
}
inline const ::protocol::authority& Transaction_raw::_internal_auths(int index) const {
  return _impl_.auths_.Get(index);
}
inline const ::protocol::authority& Transaction_raw::auths(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.auths)
  return _internal_auths(index);
}
inline ::protocol::authority* Transaction_raw::_internal_add_auths() {
  return _impl_.auths_.Add();
}
inline ::protocol::authority* Transaction_raw::add_auths() {
  ::protocol::authority* _add = _internal_add_auths();
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.auths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >&
Transaction_raw::auths() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.auths)
  return _impl_.auths_;
}

// bytes data = 10;
inline void Transaction_raw::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Transaction_raw::data() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.data)
}
inline std::string* Transaction_raw::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.data)
  return _s;
}
inline const std::string& Transaction_raw::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Transaction_raw::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.data)
  return _impl_.data_.Release();
}
inline void Transaction_raw::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.data)
}

// repeated .protocol.Transaction.Contract contract = 11;
inline int Transaction_raw::_internal_contract_size() const {
  return _impl_.contract_.size();
}
inline int Transaction_raw::contract_size() const {
  return _internal_contract_size();
}
inline void Transaction_raw::clear_contract() {
  _impl_.contract_.Clear();
}
inline ::protocol::Transaction_Contract* Transaction_raw::mutable_contract(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.contract)
  return _impl_.contract_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >*
Transaction_raw::mutable_contract() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.contract)
  return &_impl_.contract_;
}
inline const ::protocol::Transaction_Contract& Transaction_raw::_internal_contract(int index) const {
  return _impl_.contract_.Get(index);
}
inline const ::protocol::Transaction_Contract& Transaction_raw::contract(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.contract)
  return _internal_contract(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::_internal_add_contract() {
  return _impl_.contract_.Add();
}
inline ::protocol::Transaction_Contract* Transaction_raw::add_contract() {
  ::protocol::Transaction_Contract* _add = _internal_add_contract();
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.contract)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >&
Transaction_raw::contract() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.contract)
  return _impl_.contract_;
}

// bytes scripts = 12;
inline void Transaction_raw::clear_scripts() {
  _impl_.scripts_.ClearToEmpty();
}
inline const std::string& Transaction_raw::scripts() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.scripts)
  return _internal_scripts();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_scripts(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scripts_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.scripts)
}
inline std::string* Transaction_raw::mutable_scripts() {
  std::string* _s = _internal_mutable_scripts();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.scripts)
  return _s;
}
inline const std::string& Transaction_raw::_internal_scripts() const {
  return _impl_.scripts_.Get();
}
inline void Transaction_raw::_internal_set_scripts(const std::string& value) {
  
  _impl_.scripts_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_scripts() {
  
  return _impl_.scripts_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_scripts() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.scripts)
  return _impl_.scripts_.Release();
}
inline void Transaction_raw::set_allocated_scripts(std::string* scripts) {
  if (scripts != nullptr) {
    
  } else {
    
  }
  _impl_.scripts_.SetAllocated(scripts, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scripts_.IsDefault()) {
    _impl_.scripts_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.scripts)
}

// int64 timestamp = 14;
inline void Transaction_raw::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Transaction_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.timestamp)
  return _internal_timestamp();
}
inline void Transaction_raw::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Transaction_raw::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.timestamp)
}

// int64 fee_limit = 18;
inline void Transaction_raw::clear_fee_limit() {
  _impl_.fee_limit_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_fee_limit() const {
  return _impl_.fee_limit_;
}
inline int64_t Transaction_raw::fee_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.fee_limit)
  return _internal_fee_limit();
}
inline void Transaction_raw::_internal_set_fee_limit(int64_t value) {
  
  _impl_.fee_limit_ = value;
}
inline void Transaction_raw::set_fee_limit(int64_t value) {
  _internal_set_fee_limit(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.fee_limit)
}

// -------------------------------------------------------------------

// Transaction

// .protocol.Transaction.raw raw_data = 1;
inline bool Transaction::_internal_has_raw_data() const {
  return this != internal_default_instance() && _impl_.raw_data_ != nullptr;
}
inline bool Transaction::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void Transaction::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.raw_data_ != nullptr) {
    delete _impl_.raw_data_;
  }
  _impl_.raw_data_ = nullptr;
}
inline const ::protocol::Transaction_raw& Transaction::_internal_raw_data() const {
  const ::protocol::Transaction_raw* p = _impl_.raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Transaction_raw&>(
      ::protocol::_Transaction_raw_default_instance_);
}
inline const ::protocol::Transaction_raw& Transaction::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw_data)
  return _internal_raw_data();
}
inline void Transaction::unsafe_arena_set_allocated_raw_data(
    ::protocol::Transaction_raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.raw_data_);
  }
  _impl_.raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Transaction.raw_data)
}
inline ::protocol::Transaction_raw* Transaction::release_raw_data() {
  
  ::protocol::Transaction_raw* temp = _impl_.raw_data_;
  _impl_.raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw_data)
  
  ::protocol::Transaction_raw* temp = _impl_.raw_data_;
  _impl_.raw_data_ = nullptr;
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::_internal_mutable_raw_data() {
  
  if (_impl_.raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction_raw>(GetArenaForAllocation());
    _impl_.raw_data_ = p;
  }
  return _impl_.raw_data_;
}
inline ::protocol::Transaction_raw* Transaction::mutable_raw_data() {
  ::protocol::Transaction_raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw_data)
  return _msg;
}
inline void Transaction::set_allocated_raw_data(::protocol::Transaction_raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw_data)
}

// repeated bytes signature = 2;
inline int Transaction::_internal_signature_size() const {
  return _impl_.signature_.size();
}
inline int Transaction::signature_size() const {
  return _internal_signature_size();
}
inline void Transaction::clear_signature() {
  _impl_.signature_.Clear();
}
inline std::string* Transaction::add_signature() {
  std::string* _s = _internal_add_signature();
  // @@protoc_insertion_point(field_add_mutable:protocol.Transaction.signature)
  return _s;
}
inline const std::string& Transaction::_internal_signature(int index) const {
  return _impl_.signature_.Get(index);
}
inline const std::string& Transaction::signature(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.signature)
  return _internal_signature(index);
}
inline std::string* Transaction::mutable_signature(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.signature)
  return _impl_.signature_.Mutable(index);
}
inline void Transaction::set_signature(int index, const std::string& value) {
  _impl_.signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, std::string&& value) {
  _impl_.signature_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, const void* value, size_t size) {
  _impl_.signature_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.signature)
}
inline std::string* Transaction::_internal_add_signature() {
  return _impl_.signature_.Add();
}
inline void Transaction::add_signature(const std::string& value) {
  _impl_.signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
inline void Transaction::add_signature(std::string&& value) {
  _impl_.signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
inline void Transaction::add_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Transaction.signature)
}
inline void Transaction::add_signature(const void* value, size_t size) {
  _impl_.signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Transaction.signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Transaction::signature() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.signature)
  return _impl_.signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Transaction::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.signature)
  return &_impl_.signature_;
}

// repeated .protocol.Transaction.Result ret = 5;
inline int Transaction::_internal_ret_size() const {
  return _impl_.ret_.size();
}
inline int Transaction::ret_size() const {
  return _internal_ret_size();
}
inline void Transaction::clear_ret() {
  _impl_.ret_.Clear();
}
inline ::protocol::Transaction_Result* Transaction::mutable_ret(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.ret)
  return _impl_.ret_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >*
Transaction::mutable_ret() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.ret)
  return &_impl_.ret_;
}
inline const ::protocol::Transaction_Result& Transaction::_internal_ret(int index) const {
  return _impl_.ret_.Get(index);
}
inline const ::protocol::Transaction_Result& Transaction::ret(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.ret)
  return _internal_ret(index);
}
inline ::protocol::Transaction_Result* Transaction::_internal_add_ret() {
  return _impl_.ret_.Add();
}
inline ::protocol::Transaction_Result* Transaction::add_ret() {
  ::protocol::Transaction_Result* _add = _internal_add_ret();
  // @@protoc_insertion_point(field_add:protocol.Transaction.ret)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >&
Transaction::ret() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.ret)
  return _impl_.ret_;
}

// -------------------------------------------------------------------

// BlockHeader_raw

// int64 timestamp = 1;
inline void BlockHeader_raw::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t BlockHeader_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader_raw::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BlockHeader_raw::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.timestamp)
}

// bytes txTrieRoot = 2;
inline void BlockHeader_raw::clear_txtrieroot() {
  _impl_.txtrieroot_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::txtrieroot() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.txTrieRoot)
  return _internal_txtrieroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_txtrieroot(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txtrieroot_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.txTrieRoot)
}
inline std::string* BlockHeader_raw::mutable_txtrieroot() {
  std::string* _s = _internal_mutable_txtrieroot();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.txTrieRoot)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_txtrieroot() const {
  return _impl_.txtrieroot_.Get();
}
inline void BlockHeader_raw::_internal_set_txtrieroot(const std::string& value) {
  
  _impl_.txtrieroot_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_txtrieroot() {
  
  return _impl_.txtrieroot_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_txtrieroot() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.txTrieRoot)
  return _impl_.txtrieroot_.Release();
}
inline void BlockHeader_raw::set_allocated_txtrieroot(std::string* txtrieroot) {
  if (txtrieroot != nullptr) {
    
  } else {
    
  }
  _impl_.txtrieroot_.SetAllocated(txtrieroot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txtrieroot_.IsDefault()) {
    _impl_.txtrieroot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.txTrieRoot)
}

// bytes parentHash = 3;
inline void BlockHeader_raw::clear_parenthash() {
  _impl_.parenthash_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::parenthash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.parentHash)
  return _internal_parenthash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_parenthash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parenthash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.parentHash)
}
inline std::string* BlockHeader_raw::mutable_parenthash() {
  std::string* _s = _internal_mutable_parenthash();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.parentHash)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_parenthash() const {
  return _impl_.parenthash_.Get();
}
inline void BlockHeader_raw::_internal_set_parenthash(const std::string& value) {
  
  _impl_.parenthash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_parenthash() {
  
  return _impl_.parenthash_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_parenthash() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.parentHash)
  return _impl_.parenthash_.Release();
}
inline void BlockHeader_raw::set_allocated_parenthash(std::string* parenthash) {
  if (parenthash != nullptr) {
    
  } else {
    
  }
  _impl_.parenthash_.SetAllocated(parenthash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parenthash_.IsDefault()) {
    _impl_.parenthash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.parentHash)
}

// bytes nonce = 5;
inline void BlockHeader_raw::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.nonce)
}
inline std::string* BlockHeader_raw::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.nonce)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void BlockHeader_raw::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_nonce() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.nonce)
  return _impl_.nonce_.Release();
}
inline void BlockHeader_raw::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.nonce)
}

// bytes difficulty = 6;
inline void BlockHeader_raw::clear_difficulty() {
  _impl_.difficulty_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::difficulty() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.difficulty)
  return _internal_difficulty();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_difficulty(ArgT0&& arg0, ArgT... args) {
 
 _impl_.difficulty_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.difficulty)
}
inline std::string* BlockHeader_raw::mutable_difficulty() {
  std::string* _s = _internal_mutable_difficulty();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.difficulty)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_difficulty() const {
  return _impl_.difficulty_.Get();
}
inline void BlockHeader_raw::_internal_set_difficulty(const std::string& value) {
  
  _impl_.difficulty_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_difficulty() {
  
  return _impl_.difficulty_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_difficulty() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.difficulty)
  return _impl_.difficulty_.Release();
}
inline void BlockHeader_raw::set_allocated_difficulty(std::string* difficulty) {
  if (difficulty != nullptr) {
    
  } else {
    
  }
  _impl_.difficulty_.SetAllocated(difficulty, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.difficulty_.IsDefault()) {
    _impl_.difficulty_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.difficulty)
}

// int64 number = 7;
inline void BlockHeader_raw::clear_number() {
  _impl_.number_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_number() const {
  return _impl_.number_;
}
inline int64_t BlockHeader_raw::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.number)
  return _internal_number();
}
inline void BlockHeader_raw::_internal_set_number(int64_t value) {
  
  _impl_.number_ = value;
}
inline void BlockHeader_raw::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.number)
}

// int64 witness_id = 8;
inline void BlockHeader_raw::clear_witness_id() {
  _impl_.witness_id_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_witness_id() const {
  return _impl_.witness_id_;
}
inline int64_t BlockHeader_raw::witness_id() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_id)
  return _internal_witness_id();
}
inline void BlockHeader_raw::_internal_set_witness_id(int64_t value) {
  
  _impl_.witness_id_ = value;
}
inline void BlockHeader_raw::set_witness_id(int64_t value) {
  _internal_set_witness_id(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_id)
}

// bytes witness_address = 9;
inline void BlockHeader_raw::clear_witness_address() {
  _impl_.witness_address_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::witness_address() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_address)
  return _internal_witness_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_witness_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.witness_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_address)
}
inline std::string* BlockHeader_raw::mutable_witness_address() {
  std::string* _s = _internal_mutable_witness_address();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.witness_address)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_witness_address() const {
  return _impl_.witness_address_.Get();
}
inline void BlockHeader_raw::_internal_set_witness_address(const std::string& value) {
  
  _impl_.witness_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_witness_address() {
  
  return _impl_.witness_address_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_witness_address() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.witness_address)
  return _impl_.witness_address_.Release();
}
inline void BlockHeader_raw::set_allocated_witness_address(std::string* witness_address) {
  if (witness_address != nullptr) {
    
  } else {
    
  }
  _impl_.witness_address_.SetAllocated(witness_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.witness_address_.IsDefault()) {
    _impl_.witness_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.witness_address)
}

// int32 version = 10;
inline void BlockHeader_raw::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t BlockHeader_raw::_internal_version() const {
  return _impl_.version_;
}
inline int32_t BlockHeader_raw::version() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.version)
  return _internal_version();
}
inline void BlockHeader_raw::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void BlockHeader_raw::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.version)
}

// bytes accountStateRoot = 11;
inline void BlockHeader_raw::clear_accountstateroot() {
  _impl_.accountstateroot_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::accountstateroot() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.accountStateRoot)
  return _internal_accountstateroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_accountstateroot(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accountstateroot_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.accountStateRoot)
}
inline std::string* BlockHeader_raw::mutable_accountstateroot() {
  std::string* _s = _internal_mutable_accountstateroot();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.accountStateRoot)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_accountstateroot() const {
  return _impl_.accountstateroot_.Get();
}
inline void BlockHeader_raw::_internal_set_accountstateroot(const std::string& value) {
  
  _impl_.accountstateroot_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_accountstateroot() {
  
  return _impl_.accountstateroot_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_accountstateroot() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.accountStateRoot)
  return _impl_.accountstateroot_.Release();
}
inline void BlockHeader_raw::set_allocated_accountstateroot(std::string* accountstateroot) {
  if (accountstateroot != nullptr) {
    
  } else {
    
  }
  _impl_.accountstateroot_.SetAllocated(accountstateroot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountstateroot_.IsDefault()) {
    _impl_.accountstateroot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.accountStateRoot)
}

// -------------------------------------------------------------------

// BlockHeader

// .protocol.BlockHeader.raw raw_data = 1;
inline bool BlockHeader::_internal_has_raw_data() const {
  return this != internal_default_instance() && _impl_.raw_data_ != nullptr;
}
inline bool BlockHeader::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void BlockHeader::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.raw_data_ != nullptr) {
    delete _impl_.raw_data_;
  }
  _impl_.raw_data_ = nullptr;
}
inline const ::protocol::BlockHeader_raw& BlockHeader::_internal_raw_data() const {
  const ::protocol::BlockHeader_raw* p = _impl_.raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockHeader_raw&>(
      ::protocol::_BlockHeader_raw_default_instance_);
}
inline const ::protocol::BlockHeader_raw& BlockHeader::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw_data)
  return _internal_raw_data();
}
inline void BlockHeader::unsafe_arena_set_allocated_raw_data(
    ::protocol::BlockHeader_raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.raw_data_);
  }
  _impl_.raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.BlockHeader.raw_data)
}
inline ::protocol::BlockHeader_raw* BlockHeader::release_raw_data() {
  
  ::protocol::BlockHeader_raw* temp = _impl_.raw_data_;
  _impl_.raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw_data)
  
  ::protocol::BlockHeader_raw* temp = _impl_.raw_data_;
  _impl_.raw_data_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::_internal_mutable_raw_data() {
  
  if (_impl_.raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader_raw>(GetArenaForAllocation());
    _impl_.raw_data_ = p;
  }
  return _impl_.raw_data_;
}
inline ::protocol::BlockHeader_raw* BlockHeader::mutable_raw_data() {
  ::protocol::BlockHeader_raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw_data)
  return _msg;
}
inline void BlockHeader::set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw_data)
}

// bytes witness_signature = 2;
inline void BlockHeader::clear_witness_signature() {
  _impl_.witness_signature_.ClearToEmpty();
}
inline const std::string& BlockHeader::witness_signature() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.witness_signature)
  return _internal_witness_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_witness_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.witness_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.witness_signature)
}
inline std::string* BlockHeader::mutable_witness_signature() {
  std::string* _s = _internal_mutable_witness_signature();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.witness_signature)
  return _s;
}
inline const std::string& BlockHeader::_internal_witness_signature() const {
  return _impl_.witness_signature_.Get();
}
inline void BlockHeader::_internal_set_witness_signature(const std::string& value) {
  
  _impl_.witness_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_witness_signature() {
  
  return _impl_.witness_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHeader::release_witness_signature() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.witness_signature)
  return _impl_.witness_signature_.Release();
}
inline void BlockHeader::set_allocated_witness_signature(std::string* witness_signature) {
  if (witness_signature != nullptr) {
    
  } else {
    
  }
  _impl_.witness_signature_.SetAllocated(witness_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.witness_signature_.IsDefault()) {
    _impl_.witness_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.witness_signature)
}

// -------------------------------------------------------------------

// AccountCreateContract

// bytes owner_address = 1;
inline void AccountCreateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& AccountCreateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountCreateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountCreateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountCreateContract.owner_address)
}
inline std::string* AccountCreateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountCreateContract.owner_address)
  return _s;
}
inline const std::string& AccountCreateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void AccountCreateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountCreateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountCreateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountCreateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void AccountCreateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountCreateContract.owner_address)
}

// bytes account_address = 2;
inline void AccountCreateContract::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& AccountCreateContract::account_address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountCreateContract.account_address)
  return _internal_account_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountCreateContract::set_account_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountCreateContract.account_address)
}
inline std::string* AccountCreateContract::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountCreateContract.account_address)
  return _s;
}
inline const std::string& AccountCreateContract::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void AccountCreateContract::_internal_set_account_address(const std::string& value) {
  
  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountCreateContract::_internal_mutable_account_address() {
  
  return _impl_.account_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountCreateContract::release_account_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountCreateContract.account_address)
  return _impl_.account_address_.Release();
}
inline void AccountCreateContract::set_allocated_account_address(std::string* account_address) {
  if (account_address != nullptr) {
    
  } else {
    
  }
  _impl_.account_address_.SetAllocated(account_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_address_.IsDefault()) {
    _impl_.account_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountCreateContract.account_address)
}

// .protocol.AccountType type = 3;
inline void AccountCreateContract::clear_type() {
  _impl_.type_ = 0;
}
inline ::protocol::AccountType AccountCreateContract::_internal_type() const {
  return static_cast< ::protocol::AccountType >(_impl_.type_);
}
inline ::protocol::AccountType AccountCreateContract::type() const {
  // @@protoc_insertion_point(field_get:protocol.AccountCreateContract.type)
  return _internal_type();
}
inline void AccountCreateContract::_internal_set_type(::protocol::AccountType value) {
  
  _impl_.type_ = value;
}
inline void AccountCreateContract::set_type(::protocol::AccountType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.AccountCreateContract.type)
}

// -------------------------------------------------------------------

// AccountUpdateContract

// bytes account_name = 1;
inline void AccountUpdateContract::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& AccountUpdateContract::account_name() const {
  // @@protoc_insertion_point(field_get:protocol.AccountUpdateContract.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountUpdateContract::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountUpdateContract.account_name)
}
inline std::string* AccountUpdateContract::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:protocol.AccountUpdateContract.account_name)
  return _s;
}
inline const std::string& AccountUpdateContract::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void AccountUpdateContract::_internal_set_account_name(const std::string& value) {
  
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountUpdateContract::_internal_mutable_account_name() {
  
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountUpdateContract::release_account_name() {
  // @@protoc_insertion_point(field_release:protocol.AccountUpdateContract.account_name)
  return _impl_.account_name_.Release();
}
inline void AccountUpdateContract::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountUpdateContract.account_name)
}

// bytes owner_address = 2;
inline void AccountUpdateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& AccountUpdateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountUpdateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountUpdateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountUpdateContract.owner_address)
}
inline std::string* AccountUpdateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountUpdateContract.owner_address)
  return _s;
}
inline const std::string& AccountUpdateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void AccountUpdateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountUpdateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountUpdateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountUpdateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void AccountUpdateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountUpdateContract.owner_address)
}

// -------------------------------------------------------------------

// SetAccountIdContract

// bytes account_id = 1;
inline void SetAccountIdContract::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& SetAccountIdContract::account_id() const {
  // @@protoc_insertion_point(field_get:protocol.SetAccountIdContract.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountIdContract::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SetAccountIdContract.account_id)
}
inline std::string* SetAccountIdContract::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:protocol.SetAccountIdContract.account_id)
  return _s;
}
inline const std::string& SetAccountIdContract::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void SetAccountIdContract::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountIdContract::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountIdContract::release_account_id() {
  // @@protoc_insertion_point(field_release:protocol.SetAccountIdContract.account_id)
  return _impl_.account_id_.Release();
}
inline void SetAccountIdContract::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SetAccountIdContract.account_id)
}

// bytes owner_address = 2;
inline void SetAccountIdContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& SetAccountIdContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.SetAccountIdContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountIdContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SetAccountIdContract.owner_address)
}
inline std::string* SetAccountIdContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.SetAccountIdContract.owner_address)
  return _s;
}
inline const std::string& SetAccountIdContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void SetAccountIdContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountIdContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountIdContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.SetAccountIdContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void SetAccountIdContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SetAccountIdContract.owner_address)
}

// -------------------------------------------------------------------

// AccountPermissionUpdateContract

// bytes owner_address = 1;
inline void AccountPermissionUpdateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& AccountPermissionUpdateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPermissionUpdateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountPermissionUpdateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountPermissionUpdateContract.owner_address)
}
inline std::string* AccountPermissionUpdateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountPermissionUpdateContract.owner_address)
  return _s;
}
inline const std::string& AccountPermissionUpdateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void AccountPermissionUpdateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountPermissionUpdateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountPermissionUpdateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountPermissionUpdateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void AccountPermissionUpdateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPermissionUpdateContract.owner_address)
}

// .protocol.Permission owner = 2;
inline bool AccountPermissionUpdateContract::_internal_has_owner() const {
  return this != internal_default_instance() && _impl_.owner_ != nullptr;
}
inline bool AccountPermissionUpdateContract::has_owner() const {
  return _internal_has_owner();
}
inline void AccountPermissionUpdateContract::clear_owner() {
  if (GetArenaForAllocation() == nullptr && _impl_.owner_ != nullptr) {
    delete _impl_.owner_;
  }
  _impl_.owner_ = nullptr;
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::_internal_owner() const {
  const ::protocol::Permission* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Permission&>(
      ::protocol::_Permission_default_instance_);
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::owner() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPermissionUpdateContract.owner)
  return _internal_owner();
}
inline void AccountPermissionUpdateContract::unsafe_arena_set_allocated_owner(
    ::protocol::Permission* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountPermissionUpdateContract.owner)
}
inline ::protocol::Permission* AccountPermissionUpdateContract::release_owner() {
  
  ::protocol::Permission* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:protocol.AccountPermissionUpdateContract.owner)
  
  ::protocol::Permission* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::_internal_mutable_owner() {
  
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Permission>(GetArenaForAllocation());
    _impl_.owner_ = p;
  }
  return _impl_.owner_;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::mutable_owner() {
  ::protocol::Permission* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:protocol.AccountPermissionUpdateContract.owner)
  return _msg;
}
inline void AccountPermissionUpdateContract::set_allocated_owner(::protocol::Permission* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.owner_;
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(owner);
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPermissionUpdateContract.owner)
}

// .protocol.Permission witness = 3;
inline bool AccountPermissionUpdateContract::_internal_has_witness() const {
  return this != internal_default_instance() && _impl_.witness_ != nullptr;
}
inline bool AccountPermissionUpdateContract::has_witness() const {
  return _internal_has_witness();
}
inline void AccountPermissionUpdateContract::clear_witness() {
  if (GetArenaForAllocation() == nullptr && _impl_.witness_ != nullptr) {
    delete _impl_.witness_;
  }
  _impl_.witness_ = nullptr;
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::_internal_witness() const {
  const ::protocol::Permission* p = _impl_.witness_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Permission&>(
      ::protocol::_Permission_default_instance_);
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::witness() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPermissionUpdateContract.witness)
  return _internal_witness();
}
inline void AccountPermissionUpdateContract::unsafe_arena_set_allocated_witness(
    ::protocol::Permission* witness) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.witness_);
  }
  _impl_.witness_ = witness;
  if (witness) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountPermissionUpdateContract.witness)
}
inline ::protocol::Permission* AccountPermissionUpdateContract::release_witness() {
  
  ::protocol::Permission* temp = _impl_.witness_;
  _impl_.witness_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::unsafe_arena_release_witness() {
  // @@protoc_insertion_point(field_release:protocol.AccountPermissionUpdateContract.witness)
  
  ::protocol::Permission* temp = _impl_.witness_;
  _impl_.witness_ = nullptr;
  return temp;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::_internal_mutable_witness() {
  
  if (_impl_.witness_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Permission>(GetArenaForAllocation());
    _impl_.witness_ = p;
  }
  return _impl_.witness_;
}
inline ::protocol::Permission* AccountPermissionUpdateContract::mutable_witness() {
  ::protocol::Permission* _msg = _internal_mutable_witness();
  // @@protoc_insertion_point(field_mutable:protocol.AccountPermissionUpdateContract.witness)
  return _msg;
}
inline void AccountPermissionUpdateContract::set_allocated_witness(::protocol::Permission* witness) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.witness_;
  }
  if (witness) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(witness);
    if (message_arena != submessage_arena) {
      witness = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, witness, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.witness_ = witness;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPermissionUpdateContract.witness)
}

// repeated .protocol.Permission actives = 4;
inline int AccountPermissionUpdateContract::_internal_actives_size() const {
  return _impl_.actives_.size();
}
inline int AccountPermissionUpdateContract::actives_size() const {
  return _internal_actives_size();
}
inline void AccountPermissionUpdateContract::clear_actives() {
  _impl_.actives_.Clear();
}
inline ::protocol::Permission* AccountPermissionUpdateContract::mutable_actives(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AccountPermissionUpdateContract.actives)
  return _impl_.actives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >*
AccountPermissionUpdateContract::mutable_actives() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AccountPermissionUpdateContract.actives)
  return &_impl_.actives_;
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::_internal_actives(int index) const {
  return _impl_.actives_.Get(index);
}
inline const ::protocol::Permission& AccountPermissionUpdateContract::actives(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AccountPermissionUpdateContract.actives)
  return _internal_actives(index);
}
inline ::protocol::Permission* AccountPermissionUpdateContract::_internal_add_actives() {
  return _impl_.actives_.Add();
}
inline ::protocol::Permission* AccountPermissionUpdateContract::add_actives() {
  ::protocol::Permission* _add = _internal_add_actives();
  // @@protoc_insertion_point(field_add:protocol.AccountPermissionUpdateContract.actives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >&
AccountPermissionUpdateContract::actives() const {
  // @@protoc_insertion_point(field_list:protocol.AccountPermissionUpdateContract.actives)
  return _impl_.actives_;
}

// -------------------------------------------------------------------

// AssetIssueContract_FrozenSupply

// int64 frozen_amount = 1;
inline void AssetIssueContract_FrozenSupply::clear_frozen_amount() {
  _impl_.frozen_amount_ = int64_t{0};
}
inline int64_t AssetIssueContract_FrozenSupply::_internal_frozen_amount() const {
  return _impl_.frozen_amount_;
}
inline int64_t AssetIssueContract_FrozenSupply::frozen_amount() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.FrozenSupply.frozen_amount)
  return _internal_frozen_amount();
}
inline void AssetIssueContract_FrozenSupply::_internal_set_frozen_amount(int64_t value) {
  
  _impl_.frozen_amount_ = value;
}
inline void AssetIssueContract_FrozenSupply::set_frozen_amount(int64_t value) {
  _internal_set_frozen_amount(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.FrozenSupply.frozen_amount)
}

// int64 frozen_days = 2;
inline void AssetIssueContract_FrozenSupply::clear_frozen_days() {
  _impl_.frozen_days_ = int64_t{0};
}
inline int64_t AssetIssueContract_FrozenSupply::_internal_frozen_days() const {
  return _impl_.frozen_days_;
}
inline int64_t AssetIssueContract_FrozenSupply::frozen_days() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.FrozenSupply.frozen_days)
  return _internal_frozen_days();
}
inline void AssetIssueContract_FrozenSupply::_internal_set_frozen_days(int64_t value) {
  
  _impl_.frozen_days_ = value;
}
inline void AssetIssueContract_FrozenSupply::set_frozen_days(int64_t value) {
  _internal_set_frozen_days(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.FrozenSupply.frozen_days)
}

// -------------------------------------------------------------------

// AssetIssueContract

// string id = 41;
inline void AssetIssueContract::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::id() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.id)
}
inline std::string* AssetIssueContract::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.id)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AssetIssueContract::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_id() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.id)
  return _impl_.id_.Release();
}
inline void AssetIssueContract::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.id)
}

// bytes owner_address = 1;
inline void AssetIssueContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.owner_address)
}
inline std::string* AssetIssueContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.owner_address)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void AssetIssueContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void AssetIssueContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.owner_address)
}

// bytes name = 2;
inline void AssetIssueContract::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::name() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.name)
}
inline std::string* AssetIssueContract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.name)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AssetIssueContract::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_name() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.name)
  return _impl_.name_.Release();
}
inline void AssetIssueContract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.name)
}

// bytes abbr = 3;
inline void AssetIssueContract::clear_abbr() {
  _impl_.abbr_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::abbr() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.abbr)
  return _internal_abbr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_abbr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.abbr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.abbr)
}
inline std::string* AssetIssueContract::mutable_abbr() {
  std::string* _s = _internal_mutable_abbr();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.abbr)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_abbr() const {
  return _impl_.abbr_.Get();
}
inline void AssetIssueContract::_internal_set_abbr(const std::string& value) {
  
  _impl_.abbr_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_abbr() {
  
  return _impl_.abbr_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_abbr() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.abbr)
  return _impl_.abbr_.Release();
}
inline void AssetIssueContract::set_allocated_abbr(std::string* abbr) {
  if (abbr != nullptr) {
    
  } else {
    
  }
  _impl_.abbr_.SetAllocated(abbr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbr_.IsDefault()) {
    _impl_.abbr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.abbr)
}

// int64 total_supply = 4;
inline void AssetIssueContract::clear_total_supply() {
  _impl_.total_supply_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_total_supply() const {
  return _impl_.total_supply_;
}
inline int64_t AssetIssueContract::total_supply() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.total_supply)
  return _internal_total_supply();
}
inline void AssetIssueContract::_internal_set_total_supply(int64_t value) {
  
  _impl_.total_supply_ = value;
}
inline void AssetIssueContract::set_total_supply(int64_t value) {
  _internal_set_total_supply(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.total_supply)
}

// repeated .protocol.AssetIssueContract.FrozenSupply frozen_supply = 5;
inline int AssetIssueContract::_internal_frozen_supply_size() const {
  return _impl_.frozen_supply_.size();
}
inline int AssetIssueContract::frozen_supply_size() const {
  return _internal_frozen_supply_size();
}
inline void AssetIssueContract::clear_frozen_supply() {
  _impl_.frozen_supply_.Clear();
}
inline ::protocol::AssetIssueContract_FrozenSupply* AssetIssueContract::mutable_frozen_supply(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.frozen_supply)
  return _impl_.frozen_supply_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract_FrozenSupply >*
AssetIssueContract::mutable_frozen_supply() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AssetIssueContract.frozen_supply)
  return &_impl_.frozen_supply_;
}
inline const ::protocol::AssetIssueContract_FrozenSupply& AssetIssueContract::_internal_frozen_supply(int index) const {
  return _impl_.frozen_supply_.Get(index);
}
inline const ::protocol::AssetIssueContract_FrozenSupply& AssetIssueContract::frozen_supply(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.frozen_supply)
  return _internal_frozen_supply(index);
}
inline ::protocol::AssetIssueContract_FrozenSupply* AssetIssueContract::_internal_add_frozen_supply() {
  return _impl_.frozen_supply_.Add();
}
inline ::protocol::AssetIssueContract_FrozenSupply* AssetIssueContract::add_frozen_supply() {
  ::protocol::AssetIssueContract_FrozenSupply* _add = _internal_add_frozen_supply();
  // @@protoc_insertion_point(field_add:protocol.AssetIssueContract.frozen_supply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract_FrozenSupply >&
AssetIssueContract::frozen_supply() const {
  // @@protoc_insertion_point(field_list:protocol.AssetIssueContract.frozen_supply)
  return _impl_.frozen_supply_;
}

// int32 trx_num = 6;
inline void AssetIssueContract::clear_trx_num() {
  _impl_.trx_num_ = 0;
}
inline int32_t AssetIssueContract::_internal_trx_num() const {
  return _impl_.trx_num_;
}
inline int32_t AssetIssueContract::trx_num() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.trx_num)
  return _internal_trx_num();
}
inline void AssetIssueContract::_internal_set_trx_num(int32_t value) {
  
  _impl_.trx_num_ = value;
}
inline void AssetIssueContract::set_trx_num(int32_t value) {
  _internal_set_trx_num(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.trx_num)
}

// int32 precision = 7;
inline void AssetIssueContract::clear_precision() {
  _impl_.precision_ = 0;
}
inline int32_t AssetIssueContract::_internal_precision() const {
  return _impl_.precision_;
}
inline int32_t AssetIssueContract::precision() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.precision)
  return _internal_precision();
}
inline void AssetIssueContract::_internal_set_precision(int32_t value) {
  
  _impl_.precision_ = value;
}
inline void AssetIssueContract::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.precision)
}

// int32 num = 8;
inline void AssetIssueContract::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t AssetIssueContract::_internal_num() const {
  return _impl_.num_;
}
inline int32_t AssetIssueContract::num() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.num)
  return _internal_num();
}
inline void AssetIssueContract::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void AssetIssueContract::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.num)
}

// int64 start_time = 9;
inline void AssetIssueContract::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t AssetIssueContract::start_time() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.start_time)
  return _internal_start_time();
}
inline void AssetIssueContract::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void AssetIssueContract::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.start_time)
}

// int64 end_time = 10;
inline void AssetIssueContract::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t AssetIssueContract::end_time() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.end_time)
  return _internal_end_time();
}
inline void AssetIssueContract::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void AssetIssueContract::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.end_time)
}

// int64 order = 11;
inline void AssetIssueContract::clear_order() {
  _impl_.order_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_order() const {
  return _impl_.order_;
}
inline int64_t AssetIssueContract::order() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.order)
  return _internal_order();
}
inline void AssetIssueContract::_internal_set_order(int64_t value) {
  
  _impl_.order_ = value;
}
inline void AssetIssueContract::set_order(int64_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.order)
}

// int32 vote_score = 16;
inline void AssetIssueContract::clear_vote_score() {
  _impl_.vote_score_ = 0;
}
inline int32_t AssetIssueContract::_internal_vote_score() const {
  return _impl_.vote_score_;
}
inline int32_t AssetIssueContract::vote_score() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.vote_score)
  return _internal_vote_score();
}
inline void AssetIssueContract::_internal_set_vote_score(int32_t value) {
  
  _impl_.vote_score_ = value;
}
inline void AssetIssueContract::set_vote_score(int32_t value) {
  _internal_set_vote_score(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.vote_score)
}

// bytes description = 20;
inline void AssetIssueContract::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::description() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.description)
}
inline std::string* AssetIssueContract::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.description)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_description() const {
  return _impl_.description_.Get();
}
inline void AssetIssueContract::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_description() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.description)
  return _impl_.description_.Release();
}
inline void AssetIssueContract::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.description)
}

// bytes url = 21;
inline void AssetIssueContract::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& AssetIssueContract::url() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetIssueContract::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.url)
}
inline std::string* AssetIssueContract::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueContract.url)
  return _s;
}
inline const std::string& AssetIssueContract::_internal_url() const {
  return _impl_.url_.Get();
}
inline void AssetIssueContract::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetIssueContract::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetIssueContract::release_url() {
  // @@protoc_insertion_point(field_release:protocol.AssetIssueContract.url)
  return _impl_.url_.Release();
}
inline void AssetIssueContract::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetIssueContract.url)
}

// int64 free_asset_net_limit = 22;
inline void AssetIssueContract::clear_free_asset_net_limit() {
  _impl_.free_asset_net_limit_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_free_asset_net_limit() const {
  return _impl_.free_asset_net_limit_;
}
inline int64_t AssetIssueContract::free_asset_net_limit() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.free_asset_net_limit)
  return _internal_free_asset_net_limit();
}
inline void AssetIssueContract::_internal_set_free_asset_net_limit(int64_t value) {
  
  _impl_.free_asset_net_limit_ = value;
}
inline void AssetIssueContract::set_free_asset_net_limit(int64_t value) {
  _internal_set_free_asset_net_limit(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.free_asset_net_limit)
}

// int64 public_free_asset_net_limit = 23;
inline void AssetIssueContract::clear_public_free_asset_net_limit() {
  _impl_.public_free_asset_net_limit_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_public_free_asset_net_limit() const {
  return _impl_.public_free_asset_net_limit_;
}
inline int64_t AssetIssueContract::public_free_asset_net_limit() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.public_free_asset_net_limit)
  return _internal_public_free_asset_net_limit();
}
inline void AssetIssueContract::_internal_set_public_free_asset_net_limit(int64_t value) {
  
  _impl_.public_free_asset_net_limit_ = value;
}
inline void AssetIssueContract::set_public_free_asset_net_limit(int64_t value) {
  _internal_set_public_free_asset_net_limit(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.public_free_asset_net_limit)
}

// int64 public_free_asset_net_usage = 24;
inline void AssetIssueContract::clear_public_free_asset_net_usage() {
  _impl_.public_free_asset_net_usage_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_public_free_asset_net_usage() const {
  return _impl_.public_free_asset_net_usage_;
}
inline int64_t AssetIssueContract::public_free_asset_net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.public_free_asset_net_usage)
  return _internal_public_free_asset_net_usage();
}
inline void AssetIssueContract::_internal_set_public_free_asset_net_usage(int64_t value) {
  
  _impl_.public_free_asset_net_usage_ = value;
}
inline void AssetIssueContract::set_public_free_asset_net_usage(int64_t value) {
  _internal_set_public_free_asset_net_usage(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.public_free_asset_net_usage)
}

// int64 public_latest_free_net_time = 25;
inline void AssetIssueContract::clear_public_latest_free_net_time() {
  _impl_.public_latest_free_net_time_ = int64_t{0};
}
inline int64_t AssetIssueContract::_internal_public_latest_free_net_time() const {
  return _impl_.public_latest_free_net_time_;
}
inline int64_t AssetIssueContract::public_latest_free_net_time() const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueContract.public_latest_free_net_time)
  return _internal_public_latest_free_net_time();
}
inline void AssetIssueContract::_internal_set_public_latest_free_net_time(int64_t value) {
  
  _impl_.public_latest_free_net_time_ = value;
}
inline void AssetIssueContract::set_public_latest_free_net_time(int64_t value) {
  _internal_set_public_latest_free_net_time(value);
  // @@protoc_insertion_point(field_set:protocol.AssetIssueContract.public_latest_free_net_time)
}

// -------------------------------------------------------------------

// TransferAssetContract

// bytes asset_name = 1;
inline void TransferAssetContract::clear_asset_name() {
  _impl_.asset_name_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::asset_name() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.asset_name)
  return _internal_asset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_asset_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.asset_name)
}
inline std::string* TransferAssetContract::mutable_asset_name() {
  std::string* _s = _internal_mutable_asset_name();
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.asset_name)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_asset_name() const {
  return _impl_.asset_name_.Get();
}
inline void TransferAssetContract::_internal_set_asset_name(const std::string& value) {
  
  _impl_.asset_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_asset_name() {
  
  return _impl_.asset_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.asset_name)
  return _impl_.asset_name_.Release();
}
inline void TransferAssetContract::set_allocated_asset_name(std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  _impl_.asset_name_.SetAllocated(asset_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_name_.IsDefault()) {
    _impl_.asset_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.asset_name)
}

// bytes owner_address = 2;
inline void TransferAssetContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.owner_address)
}
inline std::string* TransferAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.owner_address)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void TransferAssetContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void TransferAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.owner_address)
}

// bytes to_address = 3;
inline void TransferAssetContract::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& TransferAssetContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAssetContract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.to_address)
}
inline std::string* TransferAssetContract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.to_address)
  return _s;
}
inline const std::string& TransferAssetContract::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void TransferAssetContract::_internal_set_to_address(const std::string& value) {
  
  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAssetContract::_internal_mutable_to_address() {
  
  return _impl_.to_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAssetContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.to_address)
  return _impl_.to_address_.Release();
}
inline void TransferAssetContract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  _impl_.to_address_.SetAllocated(to_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_address_.IsDefault()) {
    _impl_.to_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.to_address)
}

// int64 amount = 4;
inline void TransferAssetContract::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t TransferAssetContract::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t TransferAssetContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.amount)
  return _internal_amount();
}
inline void TransferAssetContract::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void TransferAssetContract::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.amount)
}

// -------------------------------------------------------------------

// UnfreezeAssetContract

// bytes owner_address = 1;
inline void UnfreezeAssetContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnfreezeAssetContract.owner_address)
}
inline std::string* UnfreezeAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnfreezeAssetContract.owner_address)
  return _s;
}
inline const std::string& UnfreezeAssetContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UnfreezeAssetContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnfreezeAssetContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnfreezeAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UnfreezeAssetContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UnfreezeAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnfreezeAssetContract.owner_address)
}

// -------------------------------------------------------------------

// UpdateAssetContract

// bytes owner_address = 1;
inline void UpdateAssetContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UpdateAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateAssetContract.owner_address)
}
inline std::string* UpdateAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateAssetContract.owner_address)
  return _s;
}
inline const std::string& UpdateAssetContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UpdateAssetContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateAssetContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UpdateAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateAssetContract.owner_address)
}

// bytes description = 2;
inline void UpdateAssetContract::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateAssetContract::description() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateAssetContract.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetContract::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateAssetContract.description)
}
inline std::string* UpdateAssetContract::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateAssetContract.description)
  return _s;
}
inline const std::string& UpdateAssetContract::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateAssetContract::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::release_description() {
  // @@protoc_insertion_point(field_release:protocol.UpdateAssetContract.description)
  return _impl_.description_.Release();
}
inline void UpdateAssetContract::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateAssetContract.description)
}

// bytes url = 3;
inline void UpdateAssetContract::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& UpdateAssetContract::url() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateAssetContract.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetContract::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateAssetContract.url)
}
inline std::string* UpdateAssetContract::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateAssetContract.url)
  return _s;
}
inline const std::string& UpdateAssetContract::_internal_url() const {
  return _impl_.url_.Get();
}
inline void UpdateAssetContract::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetContract::release_url() {
  // @@protoc_insertion_point(field_release:protocol.UpdateAssetContract.url)
  return _impl_.url_.Release();
}
inline void UpdateAssetContract::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateAssetContract.url)
}

// int64 new_limit = 4;
inline void UpdateAssetContract::clear_new_limit() {
  _impl_.new_limit_ = int64_t{0};
}
inline int64_t UpdateAssetContract::_internal_new_limit() const {
  return _impl_.new_limit_;
}
inline int64_t UpdateAssetContract::new_limit() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateAssetContract.new_limit)
  return _internal_new_limit();
}
inline void UpdateAssetContract::_internal_set_new_limit(int64_t value) {
  
  _impl_.new_limit_ = value;
}
inline void UpdateAssetContract::set_new_limit(int64_t value) {
  _internal_set_new_limit(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateAssetContract.new_limit)
}

// int64 new_public_limit = 5;
inline void UpdateAssetContract::clear_new_public_limit() {
  _impl_.new_public_limit_ = int64_t{0};
}
inline int64_t UpdateAssetContract::_internal_new_public_limit() const {
  return _impl_.new_public_limit_;
}
inline int64_t UpdateAssetContract::new_public_limit() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateAssetContract.new_public_limit)
  return _internal_new_public_limit();
}
inline void UpdateAssetContract::_internal_set_new_public_limit(int64_t value) {
  
  _impl_.new_public_limit_ = value;
}
inline void UpdateAssetContract::set_new_public_limit(int64_t value) {
  _internal_set_new_public_limit(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateAssetContract.new_public_limit)
}

// -------------------------------------------------------------------

// ParticipateAssetIssueContract

// bytes owner_address = 1;
inline void ParticipateAssetIssueContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ParticipateAssetIssueContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ParticipateAssetIssueContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipateAssetIssueContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ParticipateAssetIssueContract.owner_address)
}
inline std::string* ParticipateAssetIssueContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ParticipateAssetIssueContract.owner_address)
  return _s;
}
inline const std::string& ParticipateAssetIssueContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ParticipateAssetIssueContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ParticipateAssetIssueContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ParticipateAssetIssueContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ParticipateAssetIssueContract.owner_address)
}

// bytes to_address = 2;
inline void ParticipateAssetIssueContract::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& ParticipateAssetIssueContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.ParticipateAssetIssueContract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipateAssetIssueContract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ParticipateAssetIssueContract.to_address)
}
inline std::string* ParticipateAssetIssueContract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.ParticipateAssetIssueContract.to_address)
  return _s;
}
inline const std::string& ParticipateAssetIssueContract::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void ParticipateAssetIssueContract::_internal_set_to_address(const std::string& value) {
  
  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::_internal_mutable_to_address() {
  
  return _impl_.to_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.ParticipateAssetIssueContract.to_address)
  return _impl_.to_address_.Release();
}
inline void ParticipateAssetIssueContract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  _impl_.to_address_.SetAllocated(to_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_address_.IsDefault()) {
    _impl_.to_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ParticipateAssetIssueContract.to_address)
}

// bytes asset_name = 3;
inline void ParticipateAssetIssueContract::clear_asset_name() {
  _impl_.asset_name_.ClearToEmpty();
}
inline const std::string& ParticipateAssetIssueContract::asset_name() const {
  // @@protoc_insertion_point(field_get:protocol.ParticipateAssetIssueContract.asset_name)
  return _internal_asset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipateAssetIssueContract::set_asset_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ParticipateAssetIssueContract.asset_name)
}
inline std::string* ParticipateAssetIssueContract::mutable_asset_name() {
  std::string* _s = _internal_mutable_asset_name();
  // @@protoc_insertion_point(field_mutable:protocol.ParticipateAssetIssueContract.asset_name)
  return _s;
}
inline const std::string& ParticipateAssetIssueContract::_internal_asset_name() const {
  return _impl_.asset_name_.Get();
}
inline void ParticipateAssetIssueContract::_internal_set_asset_name(const std::string& value) {
  
  _impl_.asset_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::_internal_mutable_asset_name() {
  
  return _impl_.asset_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipateAssetIssueContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:protocol.ParticipateAssetIssueContract.asset_name)
  return _impl_.asset_name_.Release();
}
inline void ParticipateAssetIssueContract::set_allocated_asset_name(std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  _impl_.asset_name_.SetAllocated(asset_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_name_.IsDefault()) {
    _impl_.asset_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ParticipateAssetIssueContract.asset_name)
}

// int64 amount = 4;
inline void ParticipateAssetIssueContract::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t ParticipateAssetIssueContract::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t ParticipateAssetIssueContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.ParticipateAssetIssueContract.amount)
  return _internal_amount();
}
inline void ParticipateAssetIssueContract::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void ParticipateAssetIssueContract::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.ParticipateAssetIssueContract.amount)
}

// -------------------------------------------------------------------

// FreezeBalanceContract

// bytes owner_address = 1;
inline void FreezeBalanceContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceContract.owner_address)
}
inline std::string* FreezeBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.FreezeBalanceContract.owner_address)
  return _s;
}
inline const std::string& FreezeBalanceContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void FreezeBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.FreezeBalanceContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void FreezeBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.FreezeBalanceContract.owner_address)
}

// int64 frozen_balance = 2;
inline void FreezeBalanceContract::clear_frozen_balance() {
  _impl_.frozen_balance_ = int64_t{0};
}
inline int64_t FreezeBalanceContract::_internal_frozen_balance() const {
  return _impl_.frozen_balance_;
}
inline int64_t FreezeBalanceContract::frozen_balance() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceContract.frozen_balance)
  return _internal_frozen_balance();
}
inline void FreezeBalanceContract::_internal_set_frozen_balance(int64_t value) {
  
  _impl_.frozen_balance_ = value;
}
inline void FreezeBalanceContract::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceContract.frozen_balance)
}

// int64 frozen_duration = 3;
inline void FreezeBalanceContract::clear_frozen_duration() {
  _impl_.frozen_duration_ = int64_t{0};
}
inline int64_t FreezeBalanceContract::_internal_frozen_duration() const {
  return _impl_.frozen_duration_;
}
inline int64_t FreezeBalanceContract::frozen_duration() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceContract.frozen_duration)
  return _internal_frozen_duration();
}
inline void FreezeBalanceContract::_internal_set_frozen_duration(int64_t value) {
  
  _impl_.frozen_duration_ = value;
}
inline void FreezeBalanceContract::set_frozen_duration(int64_t value) {
  _internal_set_frozen_duration(value);
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceContract.frozen_duration)
}

// .protocol.ResourceCode resource = 10;
inline void FreezeBalanceContract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode FreezeBalanceContract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode FreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceContract.resource)
  return _internal_resource();
}
inline void FreezeBalanceContract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void FreezeBalanceContract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceContract.resource)
}

// bytes receiver_address = 15;
inline void FreezeBalanceContract::clear_receiver_address() {
  _impl_.receiver_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receiver_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceContract.receiver_address)
}
inline std::string* FreezeBalanceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:protocol.FreezeBalanceContract.receiver_address)
  return _s;
}
inline const std::string& FreezeBalanceContract::_internal_receiver_address() const {
  return _impl_.receiver_address_.Get();
}
inline void FreezeBalanceContract::_internal_set_receiver_address(const std::string& value) {
  
  _impl_.receiver_address_.Set(value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::_internal_mutable_receiver_address() {
  
  return _impl_.receiver_address_.Mutable(GetArenaForAllocation());
}
inline std::string* FreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:protocol.FreezeBalanceContract.receiver_address)
  return _impl_.receiver_address_.Release();
}
inline void FreezeBalanceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  _impl_.receiver_address_.SetAllocated(receiver_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiver_address_.IsDefault()) {
    _impl_.receiver_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.FreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// UnfreezeBalanceContract

// bytes owner_address = 1;
inline void UnfreezeBalanceContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceContract.owner_address)
}
inline std::string* UnfreezeBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnfreezeBalanceContract.owner_address)
  return _s;
}
inline const std::string& UnfreezeBalanceContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UnfreezeBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UnfreezeBalanceContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UnfreezeBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnfreezeBalanceContract.owner_address)
}

// .protocol.ResourceCode resource = 10;
inline void UnfreezeBalanceContract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode UnfreezeBalanceContract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode UnfreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceContract.resource)
  return _internal_resource();
}
inline void UnfreezeBalanceContract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void UnfreezeBalanceContract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceContract.resource)
}

// bytes receiver_address = 15;
inline void UnfreezeBalanceContract::clear_receiver_address() {
  _impl_.receiver_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receiver_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceContract.receiver_address)
}
inline std::string* UnfreezeBalanceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnfreezeBalanceContract.receiver_address)
  return _s;
}
inline const std::string& UnfreezeBalanceContract::_internal_receiver_address() const {
  return _impl_.receiver_address_.Get();
}
inline void UnfreezeBalanceContract::_internal_set_receiver_address(const std::string& value) {
  
  _impl_.receiver_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::_internal_mutable_receiver_address() {
  
  return _impl_.receiver_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:protocol.UnfreezeBalanceContract.receiver_address)
  return _impl_.receiver_address_.Release();
}
inline void UnfreezeBalanceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  _impl_.receiver_address_.SetAllocated(receiver_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiver_address_.IsDefault()) {
    _impl_.receiver_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnfreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// WithdrawBalanceContract

// bytes owner_address = 1;
inline void WithdrawBalanceContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& WithdrawBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.WithdrawBalanceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WithdrawBalanceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WithdrawBalanceContract.owner_address)
}
inline std::string* WithdrawBalanceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.WithdrawBalanceContract.owner_address)
  return _s;
}
inline const std::string& WithdrawBalanceContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void WithdrawBalanceContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WithdrawBalanceContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* WithdrawBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.WithdrawBalanceContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void WithdrawBalanceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WithdrawBalanceContract.owner_address)
}

// -------------------------------------------------------------------

// TransferContract

// bytes owner_address = 1;
inline void TransferContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& TransferContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransferContract.owner_address)
}
inline std::string* TransferContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.owner_address)
  return _s;
}
inline const std::string& TransferContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void TransferContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void TransferContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.owner_address)
}

// bytes to_address = 2;
inline void TransferContract::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& TransferContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.to_address)
  return _internal_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferContract::set_to_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransferContract.to_address)
}
inline std::string* TransferContract::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.to_address)
  return _s;
}
inline const std::string& TransferContract::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void TransferContract::_internal_set_to_address(const std::string& value) {
  
  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferContract::_internal_mutable_to_address() {
  
  return _impl_.to_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.to_address)
  return _impl_.to_address_.Release();
}
inline void TransferContract::set_allocated_to_address(std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  _impl_.to_address_.SetAllocated(to_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_address_.IsDefault()) {
    _impl_.to_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.to_address)
}

// int64 amount = 3;
inline void TransferContract::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t TransferContract::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t TransferContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.amount)
  return _internal_amount();
}
inline void TransferContract::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void TransferContract::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransferContract.amount)
}

// -------------------------------------------------------------------

// TransactionBalanceTrace_Operation

// int64 operation_identifier = 1;
inline void TransactionBalanceTrace_Operation::clear_operation_identifier() {
  _impl_.operation_identifier_ = int64_t{0};
}
inline int64_t TransactionBalanceTrace_Operation::_internal_operation_identifier() const {
  return _impl_.operation_identifier_;
}
inline int64_t TransactionBalanceTrace_Operation::operation_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.Operation.operation_identifier)
  return _internal_operation_identifier();
}
inline void TransactionBalanceTrace_Operation::_internal_set_operation_identifier(int64_t value) {
  
  _impl_.operation_identifier_ = value;
}
inline void TransactionBalanceTrace_Operation::set_operation_identifier(int64_t value) {
  _internal_set_operation_identifier(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.Operation.operation_identifier)
}

// bytes address = 2;
inline void TransactionBalanceTrace_Operation::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TransactionBalanceTrace_Operation::address() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.Operation.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionBalanceTrace_Operation::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.Operation.address)
}
inline std::string* TransactionBalanceTrace_Operation::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionBalanceTrace.Operation.address)
  return _s;
}
inline const std::string& TransactionBalanceTrace_Operation::_internal_address() const {
  return _impl_.address_.Get();
}
inline void TransactionBalanceTrace_Operation::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace_Operation::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace_Operation::release_address() {
  // @@protoc_insertion_point(field_release:protocol.TransactionBalanceTrace.Operation.address)
  return _impl_.address_.Release();
}
inline void TransactionBalanceTrace_Operation::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionBalanceTrace.Operation.address)
}

// int64 amount = 3;
inline void TransactionBalanceTrace_Operation::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t TransactionBalanceTrace_Operation::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t TransactionBalanceTrace_Operation::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.Operation.amount)
  return _internal_amount();
}
inline void TransactionBalanceTrace_Operation::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void TransactionBalanceTrace_Operation::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.Operation.amount)
}

// -------------------------------------------------------------------

// TransactionBalanceTrace

// bytes transaction_identifier = 1;
inline void TransactionBalanceTrace::clear_transaction_identifier() {
  _impl_.transaction_identifier_.ClearToEmpty();
}
inline const std::string& TransactionBalanceTrace::transaction_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.transaction_identifier)
  return _internal_transaction_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionBalanceTrace::set_transaction_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transaction_identifier_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.transaction_identifier)
}
inline std::string* TransactionBalanceTrace::mutable_transaction_identifier() {
  std::string* _s = _internal_mutable_transaction_identifier();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionBalanceTrace.transaction_identifier)
  return _s;
}
inline const std::string& TransactionBalanceTrace::_internal_transaction_identifier() const {
  return _impl_.transaction_identifier_.Get();
}
inline void TransactionBalanceTrace::_internal_set_transaction_identifier(const std::string& value) {
  
  _impl_.transaction_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::_internal_mutable_transaction_identifier() {
  
  return _impl_.transaction_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::release_transaction_identifier() {
  // @@protoc_insertion_point(field_release:protocol.TransactionBalanceTrace.transaction_identifier)
  return _impl_.transaction_identifier_.Release();
}
inline void TransactionBalanceTrace::set_allocated_transaction_identifier(std::string* transaction_identifier) {
  if (transaction_identifier != nullptr) {
    
  } else {
    
  }
  _impl_.transaction_identifier_.SetAllocated(transaction_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transaction_identifier_.IsDefault()) {
    _impl_.transaction_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionBalanceTrace.transaction_identifier)
}

// repeated .protocol.TransactionBalanceTrace.Operation operation = 2;
inline int TransactionBalanceTrace::_internal_operation_size() const {
  return _impl_.operation_.size();
}
inline int TransactionBalanceTrace::operation_size() const {
  return _internal_operation_size();
}
inline void TransactionBalanceTrace::clear_operation() {
  _impl_.operation_.Clear();
}
inline ::protocol::TransactionBalanceTrace_Operation* TransactionBalanceTrace::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionBalanceTrace.operation)
  return _impl_.operation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace_Operation >*
TransactionBalanceTrace::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionBalanceTrace.operation)
  return &_impl_.operation_;
}
inline const ::protocol::TransactionBalanceTrace_Operation& TransactionBalanceTrace::_internal_operation(int index) const {
  return _impl_.operation_.Get(index);
}
inline const ::protocol::TransactionBalanceTrace_Operation& TransactionBalanceTrace::operation(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.operation)
  return _internal_operation(index);
}
inline ::protocol::TransactionBalanceTrace_Operation* TransactionBalanceTrace::_internal_add_operation() {
  return _impl_.operation_.Add();
}
inline ::protocol::TransactionBalanceTrace_Operation* TransactionBalanceTrace::add_operation() {
  ::protocol::TransactionBalanceTrace_Operation* _add = _internal_add_operation();
  // @@protoc_insertion_point(field_add:protocol.TransactionBalanceTrace.operation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace_Operation >&
TransactionBalanceTrace::operation() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionBalanceTrace.operation)
  return _impl_.operation_;
}

// string type = 3;
inline void TransactionBalanceTrace::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TransactionBalanceTrace::type() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionBalanceTrace::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.type)
}
inline std::string* TransactionBalanceTrace::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionBalanceTrace.type)
  return _s;
}
inline const std::string& TransactionBalanceTrace::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TransactionBalanceTrace::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::release_type() {
  // @@protoc_insertion_point(field_release:protocol.TransactionBalanceTrace.type)
  return _impl_.type_.Release();
}
inline void TransactionBalanceTrace::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionBalanceTrace.type)
}

// string status = 4;
inline void TransactionBalanceTrace::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& TransactionBalanceTrace::status() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionBalanceTrace.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionBalanceTrace::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionBalanceTrace.status)
}
inline std::string* TransactionBalanceTrace::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionBalanceTrace.status)
  return _s;
}
inline const std::string& TransactionBalanceTrace::_internal_status() const {
  return _impl_.status_.Get();
}
inline void TransactionBalanceTrace::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionBalanceTrace::release_status() {
  // @@protoc_insertion_point(field_release:protocol.TransactionBalanceTrace.status)
  return _impl_.status_.Release();
}
inline void TransactionBalanceTrace::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionBalanceTrace.status)
}

// -------------------------------------------------------------------

// BlockBalanceTrace_BlockIdentifier

// bytes hash = 1;
inline void BlockBalanceTrace_BlockIdentifier::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& BlockBalanceTrace_BlockIdentifier::hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockBalanceTrace.BlockIdentifier.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockBalanceTrace_BlockIdentifier::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockBalanceTrace.BlockIdentifier.hash)
}
inline std::string* BlockBalanceTrace_BlockIdentifier::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.BlockBalanceTrace.BlockIdentifier.hash)
  return _s;
}
inline const std::string& BlockBalanceTrace_BlockIdentifier::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void BlockBalanceTrace_BlockIdentifier::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBalanceTrace_BlockIdentifier::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockBalanceTrace_BlockIdentifier::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockBalanceTrace.BlockIdentifier.hash)
  return _impl_.hash_.Release();
}
inline void BlockBalanceTrace_BlockIdentifier::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockBalanceTrace.BlockIdentifier.hash)
}

// int64 number = 2;
inline void BlockBalanceTrace_BlockIdentifier::clear_number() {
  _impl_.number_ = int64_t{0};
}
inline int64_t BlockBalanceTrace_BlockIdentifier::_internal_number() const {
  return _impl_.number_;
}
inline int64_t BlockBalanceTrace_BlockIdentifier::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockBalanceTrace.BlockIdentifier.number)
  return _internal_number();
}
inline void BlockBalanceTrace_BlockIdentifier::_internal_set_number(int64_t value) {
  
  _impl_.number_ = value;
}
inline void BlockBalanceTrace_BlockIdentifier::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.BlockBalanceTrace.BlockIdentifier.number)
}

// -------------------------------------------------------------------

// BlockBalanceTrace

// .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 1;
inline bool BlockBalanceTrace::_internal_has_block_identifier() const {
  return this != internal_default_instance() && _impl_.block_identifier_ != nullptr;
}
inline bool BlockBalanceTrace::has_block_identifier() const {
  return _internal_has_block_identifier();
}
inline void BlockBalanceTrace::clear_block_identifier() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_identifier_ != nullptr) {
    delete _impl_.block_identifier_;
  }
  _impl_.block_identifier_ = nullptr;
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& BlockBalanceTrace::_internal_block_identifier() const {
  const ::protocol::BlockBalanceTrace_BlockIdentifier* p = _impl_.block_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockBalanceTrace_BlockIdentifier&>(
      ::protocol::_BlockBalanceTrace_BlockIdentifier_default_instance_);
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& BlockBalanceTrace::block_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.BlockBalanceTrace.block_identifier)
  return _internal_block_identifier();
}
inline void BlockBalanceTrace::unsafe_arena_set_allocated_block_identifier(
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_identifier_);
  }
  _impl_.block_identifier_ = block_identifier;
  if (block_identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.BlockBalanceTrace.block_identifier)
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* BlockBalanceTrace::release_block_identifier() {
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* BlockBalanceTrace::unsafe_arena_release_block_identifier() {
  // @@protoc_insertion_point(field_release:protocol.BlockBalanceTrace.block_identifier)
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* BlockBalanceTrace::_internal_mutable_block_identifier() {
  
  if (_impl_.block_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockBalanceTrace_BlockIdentifier>(GetArenaForAllocation());
    _impl_.block_identifier_ = p;
  }
  return _impl_.block_identifier_;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* BlockBalanceTrace::mutable_block_identifier() {
  ::protocol::BlockBalanceTrace_BlockIdentifier* _msg = _internal_mutable_block_identifier();
  // @@protoc_insertion_point(field_mutable:protocol.BlockBalanceTrace.block_identifier)
  return _msg;
}
inline void BlockBalanceTrace::set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_identifier_;
  }
  if (block_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_identifier);
    if (message_arena != submessage_arena) {
      block_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_identifier, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_identifier_ = block_identifier;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockBalanceTrace.block_identifier)
}

// int64 timestamp = 2;
inline void BlockBalanceTrace::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t BlockBalanceTrace::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t BlockBalanceTrace::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockBalanceTrace.timestamp)
  return _internal_timestamp();
}
inline void BlockBalanceTrace::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BlockBalanceTrace::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.BlockBalanceTrace.timestamp)
}

// repeated .protocol.TransactionBalanceTrace transaction_balance_trace = 3;
inline int BlockBalanceTrace::_internal_transaction_balance_trace_size() const {
  return _impl_.transaction_balance_trace_.size();
}
inline int BlockBalanceTrace::transaction_balance_trace_size() const {
  return _internal_transaction_balance_trace_size();
}
inline void BlockBalanceTrace::clear_transaction_balance_trace() {
  _impl_.transaction_balance_trace_.Clear();
}
inline ::protocol::TransactionBalanceTrace* BlockBalanceTrace::mutable_transaction_balance_trace(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockBalanceTrace.transaction_balance_trace)
  return _impl_.transaction_balance_trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace >*
BlockBalanceTrace::mutable_transaction_balance_trace() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockBalanceTrace.transaction_balance_trace)
  return &_impl_.transaction_balance_trace_;
}
inline const ::protocol::TransactionBalanceTrace& BlockBalanceTrace::_internal_transaction_balance_trace(int index) const {
  return _impl_.transaction_balance_trace_.Get(index);
}
inline const ::protocol::TransactionBalanceTrace& BlockBalanceTrace::transaction_balance_trace(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockBalanceTrace.transaction_balance_trace)
  return _internal_transaction_balance_trace(index);
}
inline ::protocol::TransactionBalanceTrace* BlockBalanceTrace::_internal_add_transaction_balance_trace() {
  return _impl_.transaction_balance_trace_.Add();
}
inline ::protocol::TransactionBalanceTrace* BlockBalanceTrace::add_transaction_balance_trace() {
  ::protocol::TransactionBalanceTrace* _add = _internal_add_transaction_balance_trace();
  // @@protoc_insertion_point(field_add:protocol.BlockBalanceTrace.transaction_balance_trace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionBalanceTrace >&
BlockBalanceTrace::transaction_balance_trace() const {
  // @@protoc_insertion_point(field_list:protocol.BlockBalanceTrace.transaction_balance_trace)
  return _impl_.transaction_balance_trace_;
}

// -------------------------------------------------------------------

// AccountTrace

// int64 balance = 1;
inline void AccountTrace::clear_balance() {
  _impl_.balance_ = int64_t{0};
}
inline int64_t AccountTrace::_internal_balance() const {
  return _impl_.balance_;
}
inline int64_t AccountTrace::balance() const {
  // @@protoc_insertion_point(field_get:protocol.AccountTrace.balance)
  return _internal_balance();
}
inline void AccountTrace::_internal_set_balance(int64_t value) {
  
  _impl_.balance_ = value;
}
inline void AccountTrace::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:protocol.AccountTrace.balance)
}

// int64 placeholder = 99;
inline void AccountTrace::clear_placeholder() {
  _impl_.placeholder_ = int64_t{0};
}
inline int64_t AccountTrace::_internal_placeholder() const {
  return _impl_.placeholder_;
}
inline int64_t AccountTrace::placeholder() const {
  // @@protoc_insertion_point(field_get:protocol.AccountTrace.placeholder)
  return _internal_placeholder();
}
inline void AccountTrace::_internal_set_placeholder(int64_t value) {
  
  _impl_.placeholder_ = value;
}
inline void AccountTrace::set_placeholder(int64_t value) {
  _internal_set_placeholder(value);
  // @@protoc_insertion_point(field_set:protocol.AccountTrace.placeholder)
}

// -------------------------------------------------------------------

// AccountIdentifier

// bytes address = 1;
inline void AccountIdentifier::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& AccountIdentifier::address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountIdentifier.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountIdentifier::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountIdentifier.address)
}
inline std::string* AccountIdentifier::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountIdentifier.address)
  return _s;
}
inline const std::string& AccountIdentifier::_internal_address() const {
  return _impl_.address_.Get();
}
inline void AccountIdentifier::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountIdentifier::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountIdentifier::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountIdentifier.address)
  return _impl_.address_.Release();
}
inline void AccountIdentifier::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountIdentifier.address)
}

// -------------------------------------------------------------------

// AccountBalanceRequest

// .protocol.AccountIdentifier account_identifier = 1;
inline bool AccountBalanceRequest::_internal_has_account_identifier() const {
  return this != internal_default_instance() && _impl_.account_identifier_ != nullptr;
}
inline bool AccountBalanceRequest::has_account_identifier() const {
  return _internal_has_account_identifier();
}
inline void AccountBalanceRequest::clear_account_identifier() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_identifier_ != nullptr) {
    delete _impl_.account_identifier_;
  }
  _impl_.account_identifier_ = nullptr;
}
inline const ::protocol::AccountIdentifier& AccountBalanceRequest::_internal_account_identifier() const {
  const ::protocol::AccountIdentifier* p = _impl_.account_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::AccountIdentifier&>(
      ::protocol::_AccountIdentifier_default_instance_);
}
inline const ::protocol::AccountIdentifier& AccountBalanceRequest::account_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.AccountBalanceRequest.account_identifier)
  return _internal_account_identifier();
}
inline void AccountBalanceRequest::unsafe_arena_set_allocated_account_identifier(
    ::protocol::AccountIdentifier* account_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_identifier_);
  }
  _impl_.account_identifier_ = account_identifier;
  if (account_identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountBalanceRequest.account_identifier)
}
inline ::protocol::AccountIdentifier* AccountBalanceRequest::release_account_identifier() {
  
  ::protocol::AccountIdentifier* temp = _impl_.account_identifier_;
  _impl_.account_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::AccountIdentifier* AccountBalanceRequest::unsafe_arena_release_account_identifier() {
  // @@protoc_insertion_point(field_release:protocol.AccountBalanceRequest.account_identifier)
  
  ::protocol::AccountIdentifier* temp = _impl_.account_identifier_;
  _impl_.account_identifier_ = nullptr;
  return temp;
}
inline ::protocol::AccountIdentifier* AccountBalanceRequest::_internal_mutable_account_identifier() {
  
  if (_impl_.account_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::AccountIdentifier>(GetArenaForAllocation());
    _impl_.account_identifier_ = p;
  }
  return _impl_.account_identifier_;
}
inline ::protocol::AccountIdentifier* AccountBalanceRequest::mutable_account_identifier() {
  ::protocol::AccountIdentifier* _msg = _internal_mutable_account_identifier();
  // @@protoc_insertion_point(field_mutable:protocol.AccountBalanceRequest.account_identifier)
  return _msg;
}
inline void AccountBalanceRequest::set_allocated_account_identifier(::protocol::AccountIdentifier* account_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_identifier_;
  }
  if (account_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_identifier);
    if (message_arena != submessage_arena) {
      account_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_identifier, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_identifier_ = account_identifier;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountBalanceRequest.account_identifier)
}

// .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 2;
inline bool AccountBalanceRequest::_internal_has_block_identifier() const {
  return this != internal_default_instance() && _impl_.block_identifier_ != nullptr;
}
inline bool AccountBalanceRequest::has_block_identifier() const {
  return _internal_has_block_identifier();
}
inline void AccountBalanceRequest::clear_block_identifier() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_identifier_ != nullptr) {
    delete _impl_.block_identifier_;
  }
  _impl_.block_identifier_ = nullptr;
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& AccountBalanceRequest::_internal_block_identifier() const {
  const ::protocol::BlockBalanceTrace_BlockIdentifier* p = _impl_.block_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockBalanceTrace_BlockIdentifier&>(
      ::protocol::_BlockBalanceTrace_BlockIdentifier_default_instance_);
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& AccountBalanceRequest::block_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.AccountBalanceRequest.block_identifier)
  return _internal_block_identifier();
}
inline void AccountBalanceRequest::unsafe_arena_set_allocated_block_identifier(
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_identifier_);
  }
  _impl_.block_identifier_ = block_identifier;
  if (block_identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountBalanceRequest.block_identifier)
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceRequest::release_block_identifier() {
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceRequest::unsafe_arena_release_block_identifier() {
  // @@protoc_insertion_point(field_release:protocol.AccountBalanceRequest.block_identifier)
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceRequest::_internal_mutable_block_identifier() {
  
  if (_impl_.block_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockBalanceTrace_BlockIdentifier>(GetArenaForAllocation());
    _impl_.block_identifier_ = p;
  }
  return _impl_.block_identifier_;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceRequest::mutable_block_identifier() {
  ::protocol::BlockBalanceTrace_BlockIdentifier* _msg = _internal_mutable_block_identifier();
  // @@protoc_insertion_point(field_mutable:protocol.AccountBalanceRequest.block_identifier)
  return _msg;
}
inline void AccountBalanceRequest::set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_identifier_;
  }
  if (block_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_identifier);
    if (message_arena != submessage_arena) {
      block_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_identifier, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_identifier_ = block_identifier;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountBalanceRequest.block_identifier)
}

// -------------------------------------------------------------------

// AccountBalanceResponse

// int64 balance = 1;
inline void AccountBalanceResponse::clear_balance() {
  _impl_.balance_ = int64_t{0};
}
inline int64_t AccountBalanceResponse::_internal_balance() const {
  return _impl_.balance_;
}
inline int64_t AccountBalanceResponse::balance() const {
  // @@protoc_insertion_point(field_get:protocol.AccountBalanceResponse.balance)
  return _internal_balance();
}
inline void AccountBalanceResponse::_internal_set_balance(int64_t value) {
  
  _impl_.balance_ = value;
}
inline void AccountBalanceResponse::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:protocol.AccountBalanceResponse.balance)
}

// .protocol.BlockBalanceTrace.BlockIdentifier block_identifier = 2;
inline bool AccountBalanceResponse::_internal_has_block_identifier() const {
  return this != internal_default_instance() && _impl_.block_identifier_ != nullptr;
}
inline bool AccountBalanceResponse::has_block_identifier() const {
  return _internal_has_block_identifier();
}
inline void AccountBalanceResponse::clear_block_identifier() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_identifier_ != nullptr) {
    delete _impl_.block_identifier_;
  }
  _impl_.block_identifier_ = nullptr;
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& AccountBalanceResponse::_internal_block_identifier() const {
  const ::protocol::BlockBalanceTrace_BlockIdentifier* p = _impl_.block_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockBalanceTrace_BlockIdentifier&>(
      ::protocol::_BlockBalanceTrace_BlockIdentifier_default_instance_);
}
inline const ::protocol::BlockBalanceTrace_BlockIdentifier& AccountBalanceResponse::block_identifier() const {
  // @@protoc_insertion_point(field_get:protocol.AccountBalanceResponse.block_identifier)
  return _internal_block_identifier();
}
inline void AccountBalanceResponse::unsafe_arena_set_allocated_block_identifier(
    ::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_identifier_);
  }
  _impl_.block_identifier_ = block_identifier;
  if (block_identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountBalanceResponse.block_identifier)
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceResponse::release_block_identifier() {
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceResponse::unsafe_arena_release_block_identifier() {
  // @@protoc_insertion_point(field_release:protocol.AccountBalanceResponse.block_identifier)
  
  ::protocol::BlockBalanceTrace_BlockIdentifier* temp = _impl_.block_identifier_;
  _impl_.block_identifier_ = nullptr;
  return temp;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceResponse::_internal_mutable_block_identifier() {
  
  if (_impl_.block_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockBalanceTrace_BlockIdentifier>(GetArenaForAllocation());
    _impl_.block_identifier_ = p;
  }
  return _impl_.block_identifier_;
}
inline ::protocol::BlockBalanceTrace_BlockIdentifier* AccountBalanceResponse::mutable_block_identifier() {
  ::protocol::BlockBalanceTrace_BlockIdentifier* _msg = _internal_mutable_block_identifier();
  // @@protoc_insertion_point(field_mutable:protocol.AccountBalanceResponse.block_identifier)
  return _msg;
}
inline void AccountBalanceResponse::set_allocated_block_identifier(::protocol::BlockBalanceTrace_BlockIdentifier* block_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_identifier_;
  }
  if (block_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_identifier);
    if (message_arena != submessage_arena) {
      block_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_identifier, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_identifier_ = block_identifier;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountBalanceResponse.block_identifier)
}

// -------------------------------------------------------------------

// FreezeBalanceV2Contract

// bytes owner_address = 1;
inline void FreezeBalanceV2Contract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& FreezeBalanceV2Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceV2Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreezeBalanceV2Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceV2Contract.owner_address)
}
inline std::string* FreezeBalanceV2Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.FreezeBalanceV2Contract.owner_address)
  return _s;
}
inline const std::string& FreezeBalanceV2Contract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void FreezeBalanceV2Contract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* FreezeBalanceV2Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.FreezeBalanceV2Contract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void FreezeBalanceV2Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.FreezeBalanceV2Contract.owner_address)
}

// int64 frozen_balance = 2;
inline void FreezeBalanceV2Contract::clear_frozen_balance() {
  _impl_.frozen_balance_ = int64_t{0};
}
inline int64_t FreezeBalanceV2Contract::_internal_frozen_balance() const {
  return _impl_.frozen_balance_;
}
inline int64_t FreezeBalanceV2Contract::frozen_balance() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceV2Contract.frozen_balance)
  return _internal_frozen_balance();
}
inline void FreezeBalanceV2Contract::_internal_set_frozen_balance(int64_t value) {
  
  _impl_.frozen_balance_ = value;
}
inline void FreezeBalanceV2Contract::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceV2Contract.frozen_balance)
}

// .protocol.ResourceCode resource = 3;
inline void FreezeBalanceV2Contract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode FreezeBalanceV2Contract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode FreezeBalanceV2Contract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.FreezeBalanceV2Contract.resource)
  return _internal_resource();
}
inline void FreezeBalanceV2Contract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void FreezeBalanceV2Contract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.FreezeBalanceV2Contract.resource)
}

// -------------------------------------------------------------------

// UnfreezeBalanceV2Contract

// bytes owner_address = 1;
inline void UnfreezeBalanceV2Contract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UnfreezeBalanceV2Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceV2Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnfreezeBalanceV2Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceV2Contract.owner_address)
}
inline std::string* UnfreezeBalanceV2Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnfreezeBalanceV2Contract.owner_address)
  return _s;
}
inline const std::string& UnfreezeBalanceV2Contract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UnfreezeBalanceV2Contract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnfreezeBalanceV2Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UnfreezeBalanceV2Contract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UnfreezeBalanceV2Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnfreezeBalanceV2Contract.owner_address)
}

// int64 unfreeze_balance = 2;
inline void UnfreezeBalanceV2Contract::clear_unfreeze_balance() {
  _impl_.unfreeze_balance_ = int64_t{0};
}
inline int64_t UnfreezeBalanceV2Contract::_internal_unfreeze_balance() const {
  return _impl_.unfreeze_balance_;
}
inline int64_t UnfreezeBalanceV2Contract::unfreeze_balance() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceV2Contract.unfreeze_balance)
  return _internal_unfreeze_balance();
}
inline void UnfreezeBalanceV2Contract::_internal_set_unfreeze_balance(int64_t value) {
  
  _impl_.unfreeze_balance_ = value;
}
inline void UnfreezeBalanceV2Contract::set_unfreeze_balance(int64_t value) {
  _internal_set_unfreeze_balance(value);
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceV2Contract.unfreeze_balance)
}

// .protocol.ResourceCode resource = 3;
inline void UnfreezeBalanceV2Contract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode UnfreezeBalanceV2Contract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode UnfreezeBalanceV2Contract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.UnfreezeBalanceV2Contract.resource)
  return _internal_resource();
}
inline void UnfreezeBalanceV2Contract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void UnfreezeBalanceV2Contract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.UnfreezeBalanceV2Contract.resource)
}

// -------------------------------------------------------------------

// WithdrawExpireUnfreezeContract

// bytes owner_address = 1;
inline void WithdrawExpireUnfreezeContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& WithdrawExpireUnfreezeContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.WithdrawExpireUnfreezeContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WithdrawExpireUnfreezeContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WithdrawExpireUnfreezeContract.owner_address)
}
inline std::string* WithdrawExpireUnfreezeContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.WithdrawExpireUnfreezeContract.owner_address)
  return _s;
}
inline const std::string& WithdrawExpireUnfreezeContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void WithdrawExpireUnfreezeContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WithdrawExpireUnfreezeContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* WithdrawExpireUnfreezeContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.WithdrawExpireUnfreezeContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void WithdrawExpireUnfreezeContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WithdrawExpireUnfreezeContract.owner_address)
}

// -------------------------------------------------------------------

// DelegateResourceContract

// bytes owner_address = 1;
inline void DelegateResourceContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& DelegateResourceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateResourceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.owner_address)
}
inline std::string* DelegateResourceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.DelegateResourceContract.owner_address)
  return _s;
}
inline const std::string& DelegateResourceContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void DelegateResourceContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.DelegateResourceContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void DelegateResourceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegateResourceContract.owner_address)
}

// .protocol.ResourceCode resource = 2;
inline void DelegateResourceContract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode DelegateResourceContract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode DelegateResourceContract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.resource)
  return _internal_resource();
}
inline void DelegateResourceContract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void DelegateResourceContract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.resource)
}

// int64 balance = 3;
inline void DelegateResourceContract::clear_balance() {
  _impl_.balance_ = int64_t{0};
}
inline int64_t DelegateResourceContract::_internal_balance() const {
  return _impl_.balance_;
}
inline int64_t DelegateResourceContract::balance() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.balance)
  return _internal_balance();
}
inline void DelegateResourceContract::_internal_set_balance(int64_t value) {
  
  _impl_.balance_ = value;
}
inline void DelegateResourceContract::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.balance)
}

// bytes receiver_address = 4;
inline void DelegateResourceContract::clear_receiver_address() {
  _impl_.receiver_address_.ClearToEmpty();
}
inline const std::string& DelegateResourceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegateResourceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receiver_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.receiver_address)
}
inline std::string* DelegateResourceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:protocol.DelegateResourceContract.receiver_address)
  return _s;
}
inline const std::string& DelegateResourceContract::_internal_receiver_address() const {
  return _impl_.receiver_address_.Get();
}
inline void DelegateResourceContract::_internal_set_receiver_address(const std::string& value) {
  
  _impl_.receiver_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::_internal_mutable_receiver_address() {
  
  return _impl_.receiver_address_.Mutable(GetArenaForAllocation());
}
inline std::string* DelegateResourceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:protocol.DelegateResourceContract.receiver_address)
  return _impl_.receiver_address_.Release();
}
inline void DelegateResourceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  _impl_.receiver_address_.SetAllocated(receiver_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiver_address_.IsDefault()) {
    _impl_.receiver_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegateResourceContract.receiver_address)
}

// bool lock = 5;
inline void DelegateResourceContract::clear_lock() {
  _impl_.lock_ = false;
}
inline bool DelegateResourceContract::_internal_lock() const {
  return _impl_.lock_;
}
inline bool DelegateResourceContract::lock() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.lock)
  return _internal_lock();
}
inline void DelegateResourceContract::_internal_set_lock(bool value) {
  
  _impl_.lock_ = value;
}
inline void DelegateResourceContract::set_lock(bool value) {
  _internal_set_lock(value);
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.lock)
}

// int64 lock_period = 6;
inline void DelegateResourceContract::clear_lock_period() {
  _impl_.lock_period_ = int64_t{0};
}
inline int64_t DelegateResourceContract::_internal_lock_period() const {
  return _impl_.lock_period_;
}
inline int64_t DelegateResourceContract::lock_period() const {
  // @@protoc_insertion_point(field_get:protocol.DelegateResourceContract.lock_period)
  return _internal_lock_period();
}
inline void DelegateResourceContract::_internal_set_lock_period(int64_t value) {
  
  _impl_.lock_period_ = value;
}
inline void DelegateResourceContract::set_lock_period(int64_t value) {
  _internal_set_lock_period(value);
  // @@protoc_insertion_point(field_set:protocol.DelegateResourceContract.lock_period)
}

// -------------------------------------------------------------------

// UnDelegateResourceContract

// bytes owner_address = 1;
inline void UnDelegateResourceContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UnDelegateResourceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnDelegateResourceContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnDelegateResourceContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnDelegateResourceContract.owner_address)
}
inline std::string* UnDelegateResourceContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnDelegateResourceContract.owner_address)
  return _s;
}
inline const std::string& UnDelegateResourceContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UnDelegateResourceContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UnDelegateResourceContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UnDelegateResourceContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnDelegateResourceContract.owner_address)
}

// .protocol.ResourceCode resource = 2;
inline void UnDelegateResourceContract::clear_resource() {
  _impl_.resource_ = 0;
}
inline ::protocol::ResourceCode UnDelegateResourceContract::_internal_resource() const {
  return static_cast< ::protocol::ResourceCode >(_impl_.resource_);
}
inline ::protocol::ResourceCode UnDelegateResourceContract::resource() const {
  // @@protoc_insertion_point(field_get:protocol.UnDelegateResourceContract.resource)
  return _internal_resource();
}
inline void UnDelegateResourceContract::_internal_set_resource(::protocol::ResourceCode value) {
  
  _impl_.resource_ = value;
}
inline void UnDelegateResourceContract::set_resource(::protocol::ResourceCode value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:protocol.UnDelegateResourceContract.resource)
}

// int64 balance = 3;
inline void UnDelegateResourceContract::clear_balance() {
  _impl_.balance_ = int64_t{0};
}
inline int64_t UnDelegateResourceContract::_internal_balance() const {
  return _impl_.balance_;
}
inline int64_t UnDelegateResourceContract::balance() const {
  // @@protoc_insertion_point(field_get:protocol.UnDelegateResourceContract.balance)
  return _internal_balance();
}
inline void UnDelegateResourceContract::_internal_set_balance(int64_t value) {
  
  _impl_.balance_ = value;
}
inline void UnDelegateResourceContract::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:protocol.UnDelegateResourceContract.balance)
}

// bytes receiver_address = 4;
inline void UnDelegateResourceContract::clear_receiver_address() {
  _impl_.receiver_address_.ClearToEmpty();
}
inline const std::string& UnDelegateResourceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:protocol.UnDelegateResourceContract.receiver_address)
  return _internal_receiver_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnDelegateResourceContract::set_receiver_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receiver_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UnDelegateResourceContract.receiver_address)
}
inline std::string* UnDelegateResourceContract::mutable_receiver_address() {
  std::string* _s = _internal_mutable_receiver_address();
  // @@protoc_insertion_point(field_mutable:protocol.UnDelegateResourceContract.receiver_address)
  return _s;
}
inline const std::string& UnDelegateResourceContract::_internal_receiver_address() const {
  return _impl_.receiver_address_.Get();
}
inline void UnDelegateResourceContract::_internal_set_receiver_address(const std::string& value) {
  
  _impl_.receiver_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::_internal_mutable_receiver_address() {
  
  return _impl_.receiver_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UnDelegateResourceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:protocol.UnDelegateResourceContract.receiver_address)
  return _impl_.receiver_address_.Release();
}
inline void UnDelegateResourceContract::set_allocated_receiver_address(std::string* receiver_address) {
  if (receiver_address != nullptr) {
    
  } else {
    
  }
  _impl_.receiver_address_.SetAllocated(receiver_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiver_address_.IsDefault()) {
    _impl_.receiver_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UnDelegateResourceContract.receiver_address)
}

// -------------------------------------------------------------------

// CancelAllUnfreezeV2Contract

// bytes owner_address = 1;
inline void CancelAllUnfreezeV2Contract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& CancelAllUnfreezeV2Contract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.CancelAllUnfreezeV2Contract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelAllUnfreezeV2Contract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.CancelAllUnfreezeV2Contract.owner_address)
}
inline std::string* CancelAllUnfreezeV2Contract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.CancelAllUnfreezeV2Contract.owner_address)
  return _s;
}
inline const std::string& CancelAllUnfreezeV2Contract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void CancelAllUnfreezeV2Contract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelAllUnfreezeV2Contract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelAllUnfreezeV2Contract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.CancelAllUnfreezeV2Contract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void CancelAllUnfreezeV2Contract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.CancelAllUnfreezeV2Contract.owner_address)
}

// -------------------------------------------------------------------

// ExchangeCreateContract

// bytes owner_address = 1;
inline void ExchangeCreateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ExchangeCreateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeCreateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeCreateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeCreateContract.owner_address)
}
inline std::string* ExchangeCreateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeCreateContract.owner_address)
  return _s;
}
inline const std::string& ExchangeCreateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ExchangeCreateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeCreateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ExchangeCreateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeCreateContract.owner_address)
}

// bytes first_token_id = 2;
inline void ExchangeCreateContract::clear_first_token_id() {
  _impl_.first_token_id_.ClearToEmpty();
}
inline const std::string& ExchangeCreateContract::first_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeCreateContract.first_token_id)
  return _internal_first_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeCreateContract::set_first_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.first_token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeCreateContract.first_token_id)
}
inline std::string* ExchangeCreateContract::mutable_first_token_id() {
  std::string* _s = _internal_mutable_first_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeCreateContract.first_token_id)
  return _s;
}
inline const std::string& ExchangeCreateContract::_internal_first_token_id() const {
  return _impl_.first_token_id_.Get();
}
inline void ExchangeCreateContract::_internal_set_first_token_id(const std::string& value) {
  
  _impl_.first_token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::_internal_mutable_first_token_id() {
  
  return _impl_.first_token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::release_first_token_id() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeCreateContract.first_token_id)
  return _impl_.first_token_id_.Release();
}
inline void ExchangeCreateContract::set_allocated_first_token_id(std::string* first_token_id) {
  if (first_token_id != nullptr) {
    
  } else {
    
  }
  _impl_.first_token_id_.SetAllocated(first_token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_token_id_.IsDefault()) {
    _impl_.first_token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeCreateContract.first_token_id)
}

// int64 first_token_balance = 3;
inline void ExchangeCreateContract::clear_first_token_balance() {
  _impl_.first_token_balance_ = int64_t{0};
}
inline int64_t ExchangeCreateContract::_internal_first_token_balance() const {
  return _impl_.first_token_balance_;
}
inline int64_t ExchangeCreateContract::first_token_balance() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeCreateContract.first_token_balance)
  return _internal_first_token_balance();
}
inline void ExchangeCreateContract::_internal_set_first_token_balance(int64_t value) {
  
  _impl_.first_token_balance_ = value;
}
inline void ExchangeCreateContract::set_first_token_balance(int64_t value) {
  _internal_set_first_token_balance(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeCreateContract.first_token_balance)
}

// bytes second_token_id = 4;
inline void ExchangeCreateContract::clear_second_token_id() {
  _impl_.second_token_id_.ClearToEmpty();
}
inline const std::string& ExchangeCreateContract::second_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeCreateContract.second_token_id)
  return _internal_second_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeCreateContract::set_second_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.second_token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeCreateContract.second_token_id)
}
inline std::string* ExchangeCreateContract::mutable_second_token_id() {
  std::string* _s = _internal_mutable_second_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeCreateContract.second_token_id)
  return _s;
}
inline const std::string& ExchangeCreateContract::_internal_second_token_id() const {
  return _impl_.second_token_id_.Get();
}
inline void ExchangeCreateContract::_internal_set_second_token_id(const std::string& value) {
  
  _impl_.second_token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::_internal_mutable_second_token_id() {
  
  return _impl_.second_token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeCreateContract::release_second_token_id() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeCreateContract.second_token_id)
  return _impl_.second_token_id_.Release();
}
inline void ExchangeCreateContract::set_allocated_second_token_id(std::string* second_token_id) {
  if (second_token_id != nullptr) {
    
  } else {
    
  }
  _impl_.second_token_id_.SetAllocated(second_token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.second_token_id_.IsDefault()) {
    _impl_.second_token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeCreateContract.second_token_id)
}

// int64 second_token_balance = 5;
inline void ExchangeCreateContract::clear_second_token_balance() {
  _impl_.second_token_balance_ = int64_t{0};
}
inline int64_t ExchangeCreateContract::_internal_second_token_balance() const {
  return _impl_.second_token_balance_;
}
inline int64_t ExchangeCreateContract::second_token_balance() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeCreateContract.second_token_balance)
  return _internal_second_token_balance();
}
inline void ExchangeCreateContract::_internal_set_second_token_balance(int64_t value) {
  
  _impl_.second_token_balance_ = value;
}
inline void ExchangeCreateContract::set_second_token_balance(int64_t value) {
  _internal_set_second_token_balance(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeCreateContract.second_token_balance)
}

// -------------------------------------------------------------------

// ExchangeInjectContract

// bytes owner_address = 1;
inline void ExchangeInjectContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ExchangeInjectContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeInjectContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeInjectContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeInjectContract.owner_address)
}
inline std::string* ExchangeInjectContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeInjectContract.owner_address)
  return _s;
}
inline const std::string& ExchangeInjectContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ExchangeInjectContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeInjectContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeInjectContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeInjectContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ExchangeInjectContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeInjectContract.owner_address)
}

// int64 exchange_id = 2;
inline void ExchangeInjectContract::clear_exchange_id() {
  _impl_.exchange_id_ = int64_t{0};
}
inline int64_t ExchangeInjectContract::_internal_exchange_id() const {
  return _impl_.exchange_id_;
}
inline int64_t ExchangeInjectContract::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeInjectContract.exchange_id)
  return _internal_exchange_id();
}
inline void ExchangeInjectContract::_internal_set_exchange_id(int64_t value) {
  
  _impl_.exchange_id_ = value;
}
inline void ExchangeInjectContract::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeInjectContract.exchange_id)
}

// bytes token_id = 3;
inline void ExchangeInjectContract::clear_token_id() {
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& ExchangeInjectContract::token_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeInjectContract.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeInjectContract::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeInjectContract.token_id)
}
inline std::string* ExchangeInjectContract::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeInjectContract.token_id)
  return _s;
}
inline const std::string& ExchangeInjectContract::_internal_token_id() const {
  return _impl_.token_id_.Get();
}
inline void ExchangeInjectContract::_internal_set_token_id(const std::string& value) {
  
  _impl_.token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeInjectContract::_internal_mutable_token_id() {
  
  return _impl_.token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeInjectContract::release_token_id() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeInjectContract.token_id)
  return _impl_.token_id_.Release();
}
inline void ExchangeInjectContract::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  _impl_.token_id_.SetAllocated(token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_id_.IsDefault()) {
    _impl_.token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeInjectContract.token_id)
}

// int64 quant = 4;
inline void ExchangeInjectContract::clear_quant() {
  _impl_.quant_ = int64_t{0};
}
inline int64_t ExchangeInjectContract::_internal_quant() const {
  return _impl_.quant_;
}
inline int64_t ExchangeInjectContract::quant() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeInjectContract.quant)
  return _internal_quant();
}
inline void ExchangeInjectContract::_internal_set_quant(int64_t value) {
  
  _impl_.quant_ = value;
}
inline void ExchangeInjectContract::set_quant(int64_t value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeInjectContract.quant)
}

// -------------------------------------------------------------------

// ExchangeWithdrawContract

// bytes owner_address = 1;
inline void ExchangeWithdrawContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ExchangeWithdrawContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeWithdrawContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeWithdrawContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeWithdrawContract.owner_address)
}
inline std::string* ExchangeWithdrawContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeWithdrawContract.owner_address)
  return _s;
}
inline const std::string& ExchangeWithdrawContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ExchangeWithdrawContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeWithdrawContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeWithdrawContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeWithdrawContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ExchangeWithdrawContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeWithdrawContract.owner_address)
}

// int64 exchange_id = 2;
inline void ExchangeWithdrawContract::clear_exchange_id() {
  _impl_.exchange_id_ = int64_t{0};
}
inline int64_t ExchangeWithdrawContract::_internal_exchange_id() const {
  return _impl_.exchange_id_;
}
inline int64_t ExchangeWithdrawContract::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeWithdrawContract.exchange_id)
  return _internal_exchange_id();
}
inline void ExchangeWithdrawContract::_internal_set_exchange_id(int64_t value) {
  
  _impl_.exchange_id_ = value;
}
inline void ExchangeWithdrawContract::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeWithdrawContract.exchange_id)
}

// bytes token_id = 3;
inline void ExchangeWithdrawContract::clear_token_id() {
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& ExchangeWithdrawContract::token_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeWithdrawContract.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeWithdrawContract::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeWithdrawContract.token_id)
}
inline std::string* ExchangeWithdrawContract::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeWithdrawContract.token_id)
  return _s;
}
inline const std::string& ExchangeWithdrawContract::_internal_token_id() const {
  return _impl_.token_id_.Get();
}
inline void ExchangeWithdrawContract::_internal_set_token_id(const std::string& value) {
  
  _impl_.token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeWithdrawContract::_internal_mutable_token_id() {
  
  return _impl_.token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeWithdrawContract::release_token_id() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeWithdrawContract.token_id)
  return _impl_.token_id_.Release();
}
inline void ExchangeWithdrawContract::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  _impl_.token_id_.SetAllocated(token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_id_.IsDefault()) {
    _impl_.token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeWithdrawContract.token_id)
}

// int64 quant = 4;
inline void ExchangeWithdrawContract::clear_quant() {
  _impl_.quant_ = int64_t{0};
}
inline int64_t ExchangeWithdrawContract::_internal_quant() const {
  return _impl_.quant_;
}
inline int64_t ExchangeWithdrawContract::quant() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeWithdrawContract.quant)
  return _internal_quant();
}
inline void ExchangeWithdrawContract::_internal_set_quant(int64_t value) {
  
  _impl_.quant_ = value;
}
inline void ExchangeWithdrawContract::set_quant(int64_t value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeWithdrawContract.quant)
}

// -------------------------------------------------------------------

// ExchangeTransactionContract

// bytes owner_address = 1;
inline void ExchangeTransactionContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ExchangeTransactionContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeTransactionContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeTransactionContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeTransactionContract.owner_address)
}
inline std::string* ExchangeTransactionContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeTransactionContract.owner_address)
  return _s;
}
inline const std::string& ExchangeTransactionContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ExchangeTransactionContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeTransactionContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeTransactionContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeTransactionContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ExchangeTransactionContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeTransactionContract.owner_address)
}

// int64 exchange_id = 2;
inline void ExchangeTransactionContract::clear_exchange_id() {
  _impl_.exchange_id_ = int64_t{0};
}
inline int64_t ExchangeTransactionContract::_internal_exchange_id() const {
  return _impl_.exchange_id_;
}
inline int64_t ExchangeTransactionContract::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeTransactionContract.exchange_id)
  return _internal_exchange_id();
}
inline void ExchangeTransactionContract::_internal_set_exchange_id(int64_t value) {
  
  _impl_.exchange_id_ = value;
}
inline void ExchangeTransactionContract::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeTransactionContract.exchange_id)
}

// bytes token_id = 3;
inline void ExchangeTransactionContract::clear_token_id() {
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& ExchangeTransactionContract::token_id() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeTransactionContract.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeTransactionContract::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExchangeTransactionContract.token_id)
}
inline std::string* ExchangeTransactionContract::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeTransactionContract.token_id)
  return _s;
}
inline const std::string& ExchangeTransactionContract::_internal_token_id() const {
  return _impl_.token_id_.Get();
}
inline void ExchangeTransactionContract::_internal_set_token_id(const std::string& value) {
  
  _impl_.token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeTransactionContract::_internal_mutable_token_id() {
  
  return _impl_.token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangeTransactionContract::release_token_id() {
  // @@protoc_insertion_point(field_release:protocol.ExchangeTransactionContract.token_id)
  return _impl_.token_id_.Release();
}
inline void ExchangeTransactionContract::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  _impl_.token_id_.SetAllocated(token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_id_.IsDefault()) {
    _impl_.token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ExchangeTransactionContract.token_id)
}

// int64 quant = 4;
inline void ExchangeTransactionContract::clear_quant() {
  _impl_.quant_ = int64_t{0};
}
inline int64_t ExchangeTransactionContract::_internal_quant() const {
  return _impl_.quant_;
}
inline int64_t ExchangeTransactionContract::quant() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeTransactionContract.quant)
  return _internal_quant();
}
inline void ExchangeTransactionContract::_internal_set_quant(int64_t value) {
  
  _impl_.quant_ = value;
}
inline void ExchangeTransactionContract::set_quant(int64_t value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeTransactionContract.quant)
}

// int64 expected = 5;
inline void ExchangeTransactionContract::clear_expected() {
  _impl_.expected_ = int64_t{0};
}
inline int64_t ExchangeTransactionContract::_internal_expected() const {
  return _impl_.expected_;
}
inline int64_t ExchangeTransactionContract::expected() const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeTransactionContract.expected)
  return _internal_expected();
}
inline void ExchangeTransactionContract::_internal_set_expected(int64_t value) {
  
  _impl_.expected_ = value;
}
inline void ExchangeTransactionContract::set_expected(int64_t value) {
  _internal_set_expected(value);
  // @@protoc_insertion_point(field_set:protocol.ExchangeTransactionContract.expected)
}

// -------------------------------------------------------------------

// MarketSellAssetContract

// bytes owner_address = 1;
inline void MarketSellAssetContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& MarketSellAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.MarketSellAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketSellAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketSellAssetContract.owner_address)
}
inline std::string* MarketSellAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.MarketSellAssetContract.owner_address)
  return _s;
}
inline const std::string& MarketSellAssetContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void MarketSellAssetContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.MarketSellAssetContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void MarketSellAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketSellAssetContract.owner_address)
}

// bytes sell_token_id = 2;
inline void MarketSellAssetContract::clear_sell_token_id() {
  _impl_.sell_token_id_.ClearToEmpty();
}
inline const std::string& MarketSellAssetContract::sell_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketSellAssetContract.sell_token_id)
  return _internal_sell_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketSellAssetContract::set_sell_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sell_token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketSellAssetContract.sell_token_id)
}
inline std::string* MarketSellAssetContract::mutable_sell_token_id() {
  std::string* _s = _internal_mutable_sell_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketSellAssetContract.sell_token_id)
  return _s;
}
inline const std::string& MarketSellAssetContract::_internal_sell_token_id() const {
  return _impl_.sell_token_id_.Get();
}
inline void MarketSellAssetContract::_internal_set_sell_token_id(const std::string& value) {
  
  _impl_.sell_token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::_internal_mutable_sell_token_id() {
  
  return _impl_.sell_token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::release_sell_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketSellAssetContract.sell_token_id)
  return _impl_.sell_token_id_.Release();
}
inline void MarketSellAssetContract::set_allocated_sell_token_id(std::string* sell_token_id) {
  if (sell_token_id != nullptr) {
    
  } else {
    
  }
  _impl_.sell_token_id_.SetAllocated(sell_token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sell_token_id_.IsDefault()) {
    _impl_.sell_token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketSellAssetContract.sell_token_id)
}

// int64 sell_token_quantity = 3;
inline void MarketSellAssetContract::clear_sell_token_quantity() {
  _impl_.sell_token_quantity_ = int64_t{0};
}
inline int64_t MarketSellAssetContract::_internal_sell_token_quantity() const {
  return _impl_.sell_token_quantity_;
}
inline int64_t MarketSellAssetContract::sell_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketSellAssetContract.sell_token_quantity)
  return _internal_sell_token_quantity();
}
inline void MarketSellAssetContract::_internal_set_sell_token_quantity(int64_t value) {
  
  _impl_.sell_token_quantity_ = value;
}
inline void MarketSellAssetContract::set_sell_token_quantity(int64_t value) {
  _internal_set_sell_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketSellAssetContract.sell_token_quantity)
}

// bytes buy_token_id = 4;
inline void MarketSellAssetContract::clear_buy_token_id() {
  _impl_.buy_token_id_.ClearToEmpty();
}
inline const std::string& MarketSellAssetContract::buy_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketSellAssetContract.buy_token_id)
  return _internal_buy_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketSellAssetContract::set_buy_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.buy_token_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketSellAssetContract.buy_token_id)
}
inline std::string* MarketSellAssetContract::mutable_buy_token_id() {
  std::string* _s = _internal_mutable_buy_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketSellAssetContract.buy_token_id)
  return _s;
}
inline const std::string& MarketSellAssetContract::_internal_buy_token_id() const {
  return _impl_.buy_token_id_.Get();
}
inline void MarketSellAssetContract::_internal_set_buy_token_id(const std::string& value) {
  
  _impl_.buy_token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::_internal_mutable_buy_token_id() {
  
  return _impl_.buy_token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketSellAssetContract::release_buy_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketSellAssetContract.buy_token_id)
  return _impl_.buy_token_id_.Release();
}
inline void MarketSellAssetContract::set_allocated_buy_token_id(std::string* buy_token_id) {
  if (buy_token_id != nullptr) {
    
  } else {
    
  }
  _impl_.buy_token_id_.SetAllocated(buy_token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buy_token_id_.IsDefault()) {
    _impl_.buy_token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketSellAssetContract.buy_token_id)
}

// int64 buy_token_quantity = 5;
inline void MarketSellAssetContract::clear_buy_token_quantity() {
  _impl_.buy_token_quantity_ = int64_t{0};
}
inline int64_t MarketSellAssetContract::_internal_buy_token_quantity() const {
  return _impl_.buy_token_quantity_;
}
inline int64_t MarketSellAssetContract::buy_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketSellAssetContract.buy_token_quantity)
  return _internal_buy_token_quantity();
}
inline void MarketSellAssetContract::_internal_set_buy_token_quantity(int64_t value) {
  
  _impl_.buy_token_quantity_ = value;
}
inline void MarketSellAssetContract::set_buy_token_quantity(int64_t value) {
  _internal_set_buy_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketSellAssetContract.buy_token_quantity)
}

// -------------------------------------------------------------------

// MarketCancelOrderContract

// bytes owner_address = 1;
inline void MarketCancelOrderContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& MarketCancelOrderContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.MarketCancelOrderContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketCancelOrderContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketCancelOrderContract.owner_address)
}
inline std::string* MarketCancelOrderContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.MarketCancelOrderContract.owner_address)
  return _s;
}
inline const std::string& MarketCancelOrderContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void MarketCancelOrderContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketCancelOrderContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketCancelOrderContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.MarketCancelOrderContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void MarketCancelOrderContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketCancelOrderContract.owner_address)
}

// bytes order_id = 2;
inline void MarketCancelOrderContract::clear_order_id() {
  _impl_.order_id_.ClearToEmpty();
}
inline const std::string& MarketCancelOrderContract::order_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketCancelOrderContract.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketCancelOrderContract::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketCancelOrderContract.order_id)
}
inline std::string* MarketCancelOrderContract::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketCancelOrderContract.order_id)
  return _s;
}
inline const std::string& MarketCancelOrderContract::_internal_order_id() const {
  return _impl_.order_id_.Get();
}
inline void MarketCancelOrderContract::_internal_set_order_id(const std::string& value) {
  
  _impl_.order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketCancelOrderContract::_internal_mutable_order_id() {
  
  return _impl_.order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketCancelOrderContract::release_order_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketCancelOrderContract.order_id)
  return _impl_.order_id_.Release();
}
inline void MarketCancelOrderContract::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  _impl_.order_id_.SetAllocated(order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketCancelOrderContract.order_id)
}

// -------------------------------------------------------------------

// ProposalApproveContract

// bytes owner_address = 1;
inline void ProposalApproveContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ProposalApproveContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalApproveContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalApproveContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ProposalApproveContract.owner_address)
}
inline std::string* ProposalApproveContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ProposalApproveContract.owner_address)
  return _s;
}
inline const std::string& ProposalApproveContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ProposalApproveContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalApproveContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalApproveContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ProposalApproveContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ProposalApproveContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ProposalApproveContract.owner_address)
}

// int64 proposal_id = 2;
inline void ProposalApproveContract::clear_proposal_id() {
  _impl_.proposal_id_ = int64_t{0};
}
inline int64_t ProposalApproveContract::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline int64_t ProposalApproveContract::proposal_id() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalApproveContract.proposal_id)
  return _internal_proposal_id();
}
inline void ProposalApproveContract::_internal_set_proposal_id(int64_t value) {
  
  _impl_.proposal_id_ = value;
}
inline void ProposalApproveContract::set_proposal_id(int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:protocol.ProposalApproveContract.proposal_id)
}

// bool is_add_approval = 3;
inline void ProposalApproveContract::clear_is_add_approval() {
  _impl_.is_add_approval_ = false;
}
inline bool ProposalApproveContract::_internal_is_add_approval() const {
  return _impl_.is_add_approval_;
}
inline bool ProposalApproveContract::is_add_approval() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalApproveContract.is_add_approval)
  return _internal_is_add_approval();
}
inline void ProposalApproveContract::_internal_set_is_add_approval(bool value) {
  
  _impl_.is_add_approval_ = value;
}
inline void ProposalApproveContract::set_is_add_approval(bool value) {
  _internal_set_is_add_approval(value);
  // @@protoc_insertion_point(field_set:protocol.ProposalApproveContract.is_add_approval)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProposalCreateContract

// bytes owner_address = 1;
inline void ProposalCreateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ProposalCreateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalCreateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalCreateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ProposalCreateContract.owner_address)
}
inline std::string* ProposalCreateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ProposalCreateContract.owner_address)
  return _s;
}
inline const std::string& ProposalCreateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ProposalCreateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalCreateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalCreateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ProposalCreateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ProposalCreateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ProposalCreateContract.owner_address)
}

// map<int64, int64> parameters = 2;
inline int ProposalCreateContract::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ProposalCreateContract::parameters_size() const {
  return _internal_parameters_size();
}
inline void ProposalCreateContract::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
ProposalCreateContract::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
ProposalCreateContract::parameters() const {
  // @@protoc_insertion_point(field_map:protocol.ProposalCreateContract.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
ProposalCreateContract::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
ProposalCreateContract::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:protocol.ProposalCreateContract.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ProposalDeleteContract

// bytes owner_address = 1;
inline void ProposalDeleteContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ProposalDeleteContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalDeleteContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProposalDeleteContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ProposalDeleteContract.owner_address)
}
inline std::string* ProposalDeleteContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ProposalDeleteContract.owner_address)
  return _s;
}
inline const std::string& ProposalDeleteContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ProposalDeleteContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProposalDeleteContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProposalDeleteContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ProposalDeleteContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ProposalDeleteContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ProposalDeleteContract.owner_address)
}

// int64 proposal_id = 2;
inline void ProposalDeleteContract::clear_proposal_id() {
  _impl_.proposal_id_ = int64_t{0};
}
inline int64_t ProposalDeleteContract::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline int64_t ProposalDeleteContract::proposal_id() const {
  // @@protoc_insertion_point(field_get:protocol.ProposalDeleteContract.proposal_id)
  return _internal_proposal_id();
}
inline void ProposalDeleteContract::_internal_set_proposal_id(int64_t value) {
  
  _impl_.proposal_id_ = value;
}
inline void ProposalDeleteContract::set_proposal_id(int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:protocol.ProposalDeleteContract.proposal_id)
}

// -------------------------------------------------------------------

// AuthenticationPath

// repeated bool value = 1;
inline int AuthenticationPath::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int AuthenticationPath::value_size() const {
  return _internal_value_size();
}
inline void AuthenticationPath::clear_value() {
  _impl_.value_.Clear();
}
inline bool AuthenticationPath::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline bool AuthenticationPath::value(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AuthenticationPath.value)
  return _internal_value(index);
}
inline void AuthenticationPath::set_value(int index, bool value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.AuthenticationPath.value)
}
inline void AuthenticationPath::_internal_add_value(bool value) {
  _impl_.value_.Add(value);
}
inline void AuthenticationPath::add_value(bool value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:protocol.AuthenticationPath.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
AuthenticationPath::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
AuthenticationPath::value() const {
  // @@protoc_insertion_point(field_list:protocol.AuthenticationPath.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
AuthenticationPath::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
AuthenticationPath::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AuthenticationPath.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// MerklePath

// repeated .protocol.AuthenticationPath authentication_paths = 1;
inline int MerklePath::_internal_authentication_paths_size() const {
  return _impl_.authentication_paths_.size();
}
inline int MerklePath::authentication_paths_size() const {
  return _internal_authentication_paths_size();
}
inline void MerklePath::clear_authentication_paths() {
  _impl_.authentication_paths_.Clear();
}
inline ::protocol::AuthenticationPath* MerklePath::mutable_authentication_paths(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MerklePath.authentication_paths)
  return _impl_.authentication_paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AuthenticationPath >*
MerklePath::mutable_authentication_paths() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MerklePath.authentication_paths)
  return &_impl_.authentication_paths_;
}
inline const ::protocol::AuthenticationPath& MerklePath::_internal_authentication_paths(int index) const {
  return _impl_.authentication_paths_.Get(index);
}
inline const ::protocol::AuthenticationPath& MerklePath::authentication_paths(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MerklePath.authentication_paths)
  return _internal_authentication_paths(index);
}
inline ::protocol::AuthenticationPath* MerklePath::_internal_add_authentication_paths() {
  return _impl_.authentication_paths_.Add();
}
inline ::protocol::AuthenticationPath* MerklePath::add_authentication_paths() {
  ::protocol::AuthenticationPath* _add = _internal_add_authentication_paths();
  // @@protoc_insertion_point(field_add:protocol.MerklePath.authentication_paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AuthenticationPath >&
MerklePath::authentication_paths() const {
  // @@protoc_insertion_point(field_list:protocol.MerklePath.authentication_paths)
  return _impl_.authentication_paths_;
}

// repeated bool index = 2;
inline int MerklePath::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int MerklePath::index_size() const {
  return _internal_index_size();
}
inline void MerklePath::clear_index() {
  _impl_.index_.Clear();
}
inline bool MerklePath::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline bool MerklePath::index(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MerklePath.index)
  return _internal_index(index);
}
inline void MerklePath::set_index(int index, bool value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.MerklePath.index)
}
inline void MerklePath::_internal_add_index(bool value) {
  _impl_.index_.Add(value);
}
inline void MerklePath::add_index(bool value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:protocol.MerklePath.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
MerklePath::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
MerklePath::index() const {
  // @@protoc_insertion_point(field_list:protocol.MerklePath.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
MerklePath::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
MerklePath::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MerklePath.index)
  return _internal_mutable_index();
}

// bytes rt = 3;
inline void MerklePath::clear_rt() {
  _impl_.rt_.ClearToEmpty();
}
inline const std::string& MerklePath::rt() const {
  // @@protoc_insertion_point(field_get:protocol.MerklePath.rt)
  return _internal_rt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MerklePath::set_rt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MerklePath.rt)
}
inline std::string* MerklePath::mutable_rt() {
  std::string* _s = _internal_mutable_rt();
  // @@protoc_insertion_point(field_mutable:protocol.MerklePath.rt)
  return _s;
}
inline const std::string& MerklePath::_internal_rt() const {
  return _impl_.rt_.Get();
}
inline void MerklePath::_internal_set_rt(const std::string& value) {
  
  _impl_.rt_.Set(value, GetArenaForAllocation());
}
inline std::string* MerklePath::_internal_mutable_rt() {
  
  return _impl_.rt_.Mutable(GetArenaForAllocation());
}
inline std::string* MerklePath::release_rt() {
  // @@protoc_insertion_point(field_release:protocol.MerklePath.rt)
  return _impl_.rt_.Release();
}
inline void MerklePath::set_allocated_rt(std::string* rt) {
  if (rt != nullptr) {
    
  } else {
    
  }
  _impl_.rt_.SetAllocated(rt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rt_.IsDefault()) {
    _impl_.rt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MerklePath.rt)
}

// -------------------------------------------------------------------

// OutputPoint

// bytes hash = 1;
inline void OutputPoint::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& OutputPoint::hash() const {
  // @@protoc_insertion_point(field_get:protocol.OutputPoint.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputPoint::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.OutputPoint.hash)
}
inline std::string* OutputPoint::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.OutputPoint.hash)
  return _s;
}
inline const std::string& OutputPoint::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void OutputPoint::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputPoint::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputPoint::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.OutputPoint.hash)
  return _impl_.hash_.Release();
}
inline void OutputPoint::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.OutputPoint.hash)
}

// int32 index = 2;
inline void OutputPoint::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t OutputPoint::_internal_index() const {
  return _impl_.index_;
}
inline int32_t OutputPoint::index() const {
  // @@protoc_insertion_point(field_get:protocol.OutputPoint.index)
  return _internal_index();
}
inline void OutputPoint::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void OutputPoint::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.OutputPoint.index)
}

// -------------------------------------------------------------------

// OutputPointInfo

// repeated .protocol.OutputPoint out_points = 1;
inline int OutputPointInfo::_internal_out_points_size() const {
  return _impl_.out_points_.size();
}
inline int OutputPointInfo::out_points_size() const {
  return _internal_out_points_size();
}
inline void OutputPointInfo::clear_out_points() {
  _impl_.out_points_.Clear();
}
inline ::protocol::OutputPoint* OutputPointInfo::mutable_out_points(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OutputPointInfo.out_points)
  return _impl_.out_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::OutputPoint >*
OutputPointInfo::mutable_out_points() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OutputPointInfo.out_points)
  return &_impl_.out_points_;
}
inline const ::protocol::OutputPoint& OutputPointInfo::_internal_out_points(int index) const {
  return _impl_.out_points_.Get(index);
}
inline const ::protocol::OutputPoint& OutputPointInfo::out_points(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OutputPointInfo.out_points)
  return _internal_out_points(index);
}
inline ::protocol::OutputPoint* OutputPointInfo::_internal_add_out_points() {
  return _impl_.out_points_.Add();
}
inline ::protocol::OutputPoint* OutputPointInfo::add_out_points() {
  ::protocol::OutputPoint* _add = _internal_add_out_points();
  // @@protoc_insertion_point(field_add:protocol.OutputPointInfo.out_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::OutputPoint >&
OutputPointInfo::out_points() const {
  // @@protoc_insertion_point(field_list:protocol.OutputPointInfo.out_points)
  return _impl_.out_points_;
}

// int32 block_num = 2;
inline void OutputPointInfo::clear_block_num() {
  _impl_.block_num_ = 0;
}
inline int32_t OutputPointInfo::_internal_block_num() const {
  return _impl_.block_num_;
}
inline int32_t OutputPointInfo::block_num() const {
  // @@protoc_insertion_point(field_get:protocol.OutputPointInfo.block_num)
  return _internal_block_num();
}
inline void OutputPointInfo::_internal_set_block_num(int32_t value) {
  
  _impl_.block_num_ = value;
}
inline void OutputPointInfo::set_block_num(int32_t value) {
  _internal_set_block_num(value);
  // @@protoc_insertion_point(field_set:protocol.OutputPointInfo.block_num)
}

// -------------------------------------------------------------------

// PedersenHash

// bytes content = 1;
inline void PedersenHash::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PedersenHash::content() const {
  // @@protoc_insertion_point(field_get:protocol.PedersenHash.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PedersenHash::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PedersenHash.content)
}
inline std::string* PedersenHash::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:protocol.PedersenHash.content)
  return _s;
}
inline const std::string& PedersenHash::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PedersenHash::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PedersenHash::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PedersenHash::release_content() {
  // @@protoc_insertion_point(field_release:protocol.PedersenHash.content)
  return _impl_.content_.Release();
}
inline void PedersenHash::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.PedersenHash.content)
}

// -------------------------------------------------------------------

// IncrementalMerkleTree

// .protocol.PedersenHash left = 1;
inline bool IncrementalMerkleTree::_internal_has_left() const {
  return this != internal_default_instance() && _impl_.left_ != nullptr;
}
inline bool IncrementalMerkleTree::has_left() const {
  return _internal_has_left();
}
inline void IncrementalMerkleTree::clear_left() {
  if (GetArenaForAllocation() == nullptr && _impl_.left_ != nullptr) {
    delete _impl_.left_;
  }
  _impl_.left_ = nullptr;
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::_internal_left() const {
  const ::protocol::PedersenHash* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::PedersenHash&>(
      ::protocol::_PedersenHash_default_instance_);
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::left() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleTree.left)
  return _internal_left();
}
inline void IncrementalMerkleTree::unsafe_arena_set_allocated_left(
    ::protocol::PedersenHash* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncrementalMerkleTree.left)
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::release_left() {
  
  ::protocol::PedersenHash* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleTree.left)
  
  ::protocol::PedersenHash* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::_internal_mutable_left() {
  
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::PedersenHash>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::mutable_left() {
  ::protocol::PedersenHash* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleTree.left)
  return _msg;
}
inline void IncrementalMerkleTree::set_allocated_left(::protocol::PedersenHash* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleTree.left)
}

// .protocol.PedersenHash right = 2;
inline bool IncrementalMerkleTree::_internal_has_right() const {
  return this != internal_default_instance() && _impl_.right_ != nullptr;
}
inline bool IncrementalMerkleTree::has_right() const {
  return _internal_has_right();
}
inline void IncrementalMerkleTree::clear_right() {
  if (GetArenaForAllocation() == nullptr && _impl_.right_ != nullptr) {
    delete _impl_.right_;
  }
  _impl_.right_ = nullptr;
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::_internal_right() const {
  const ::protocol::PedersenHash* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::PedersenHash&>(
      ::protocol::_PedersenHash_default_instance_);
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::right() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleTree.right)
  return _internal_right();
}
inline void IncrementalMerkleTree::unsafe_arena_set_allocated_right(
    ::protocol::PedersenHash* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncrementalMerkleTree.right)
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::release_right() {
  
  ::protocol::PedersenHash* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleTree.right)
  
  ::protocol::PedersenHash* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::_internal_mutable_right() {
  
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::PedersenHash>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::mutable_right() {
  ::protocol::PedersenHash* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleTree.right)
  return _msg;
}
inline void IncrementalMerkleTree::set_allocated_right(::protocol::PedersenHash* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleTree.right)
}

// repeated .protocol.PedersenHash parents = 3;
inline int IncrementalMerkleTree::_internal_parents_size() const {
  return _impl_.parents_.size();
}
inline int IncrementalMerkleTree::parents_size() const {
  return _internal_parents_size();
}
inline void IncrementalMerkleTree::clear_parents() {
  _impl_.parents_.Clear();
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::mutable_parents(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleTree.parents)
  return _impl_.parents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >*
IncrementalMerkleTree::mutable_parents() {
  // @@protoc_insertion_point(field_mutable_list:protocol.IncrementalMerkleTree.parents)
  return &_impl_.parents_;
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::_internal_parents(int index) const {
  return _impl_.parents_.Get(index);
}
inline const ::protocol::PedersenHash& IncrementalMerkleTree::parents(int index) const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleTree.parents)
  return _internal_parents(index);
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::_internal_add_parents() {
  return _impl_.parents_.Add();
}
inline ::protocol::PedersenHash* IncrementalMerkleTree::add_parents() {
  ::protocol::PedersenHash* _add = _internal_add_parents();
  // @@protoc_insertion_point(field_add:protocol.IncrementalMerkleTree.parents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >&
IncrementalMerkleTree::parents() const {
  // @@protoc_insertion_point(field_list:protocol.IncrementalMerkleTree.parents)
  return _impl_.parents_;
}

// -------------------------------------------------------------------

// IncrementalMerkleVoucher

// .protocol.IncrementalMerkleTree tree = 1;
inline bool IncrementalMerkleVoucher::_internal_has_tree() const {
  return this != internal_default_instance() && _impl_.tree_ != nullptr;
}
inline bool IncrementalMerkleVoucher::has_tree() const {
  return _internal_has_tree();
}
inline void IncrementalMerkleVoucher::clear_tree() {
  if (GetArenaForAllocation() == nullptr && _impl_.tree_ != nullptr) {
    delete _impl_.tree_;
  }
  _impl_.tree_ = nullptr;
}
inline const ::protocol::IncrementalMerkleTree& IncrementalMerkleVoucher::_internal_tree() const {
  const ::protocol::IncrementalMerkleTree* p = _impl_.tree_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncrementalMerkleTree&>(
      ::protocol::_IncrementalMerkleTree_default_instance_);
}
inline const ::protocol::IncrementalMerkleTree& IncrementalMerkleVoucher::tree() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.tree)
  return _internal_tree();
}
inline void IncrementalMerkleVoucher::unsafe_arena_set_allocated_tree(
    ::protocol::IncrementalMerkleTree* tree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_);
  }
  _impl_.tree_ = tree;
  if (tree) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncrementalMerkleVoucher.tree)
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::release_tree() {
  
  ::protocol::IncrementalMerkleTree* temp = _impl_.tree_;
  _impl_.tree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::unsafe_arena_release_tree() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleVoucher.tree)
  
  ::protocol::IncrementalMerkleTree* temp = _impl_.tree_;
  _impl_.tree_ = nullptr;
  return temp;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::_internal_mutable_tree() {
  
  if (_impl_.tree_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncrementalMerkleTree>(GetArenaForAllocation());
    _impl_.tree_ = p;
  }
  return _impl_.tree_;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::mutable_tree() {
  ::protocol::IncrementalMerkleTree* _msg = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucher.tree)
  return _msg;
}
inline void IncrementalMerkleVoucher::set_allocated_tree(::protocol::IncrementalMerkleTree* tree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tree_;
  }
  if (tree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tree);
    if (message_arena != submessage_arena) {
      tree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tree_ = tree;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleVoucher.tree)
}

// repeated .protocol.PedersenHash filled = 2;
inline int IncrementalMerkleVoucher::_internal_filled_size() const {
  return _impl_.filled_.size();
}
inline int IncrementalMerkleVoucher::filled_size() const {
  return _internal_filled_size();
}
inline void IncrementalMerkleVoucher::clear_filled() {
  _impl_.filled_.Clear();
}
inline ::protocol::PedersenHash* IncrementalMerkleVoucher::mutable_filled(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucher.filled)
  return _impl_.filled_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >*
IncrementalMerkleVoucher::mutable_filled() {
  // @@protoc_insertion_point(field_mutable_list:protocol.IncrementalMerkleVoucher.filled)
  return &_impl_.filled_;
}
inline const ::protocol::PedersenHash& IncrementalMerkleVoucher::_internal_filled(int index) const {
  return _impl_.filled_.Get(index);
}
inline const ::protocol::PedersenHash& IncrementalMerkleVoucher::filled(int index) const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.filled)
  return _internal_filled(index);
}
inline ::protocol::PedersenHash* IncrementalMerkleVoucher::_internal_add_filled() {
  return _impl_.filled_.Add();
}
inline ::protocol::PedersenHash* IncrementalMerkleVoucher::add_filled() {
  ::protocol::PedersenHash* _add = _internal_add_filled();
  // @@protoc_insertion_point(field_add:protocol.IncrementalMerkleVoucher.filled)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::PedersenHash >&
IncrementalMerkleVoucher::filled() const {
  // @@protoc_insertion_point(field_list:protocol.IncrementalMerkleVoucher.filled)
  return _impl_.filled_;
}

// .protocol.IncrementalMerkleTree cursor = 3;
inline bool IncrementalMerkleVoucher::_internal_has_cursor() const {
  return this != internal_default_instance() && _impl_.cursor_ != nullptr;
}
inline bool IncrementalMerkleVoucher::has_cursor() const {
  return _internal_has_cursor();
}
inline void IncrementalMerkleVoucher::clear_cursor() {
  if (GetArenaForAllocation() == nullptr && _impl_.cursor_ != nullptr) {
    delete _impl_.cursor_;
  }
  _impl_.cursor_ = nullptr;
}
inline const ::protocol::IncrementalMerkleTree& IncrementalMerkleVoucher::_internal_cursor() const {
  const ::protocol::IncrementalMerkleTree* p = _impl_.cursor_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncrementalMerkleTree&>(
      ::protocol::_IncrementalMerkleTree_default_instance_);
}
inline const ::protocol::IncrementalMerkleTree& IncrementalMerkleVoucher::cursor() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.cursor)
  return _internal_cursor();
}
inline void IncrementalMerkleVoucher::unsafe_arena_set_allocated_cursor(
    ::protocol::IncrementalMerkleTree* cursor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_);
  }
  _impl_.cursor_ = cursor;
  if (cursor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncrementalMerkleVoucher.cursor)
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::release_cursor() {
  
  ::protocol::IncrementalMerkleTree* temp = _impl_.cursor_;
  _impl_.cursor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::unsafe_arena_release_cursor() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleVoucher.cursor)
  
  ::protocol::IncrementalMerkleTree* temp = _impl_.cursor_;
  _impl_.cursor_ = nullptr;
  return temp;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::_internal_mutable_cursor() {
  
  if (_impl_.cursor_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncrementalMerkleTree>(GetArenaForAllocation());
    _impl_.cursor_ = p;
  }
  return _impl_.cursor_;
}
inline ::protocol::IncrementalMerkleTree* IncrementalMerkleVoucher::mutable_cursor() {
  ::protocol::IncrementalMerkleTree* _msg = _internal_mutable_cursor();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucher.cursor)
  return _msg;
}
inline void IncrementalMerkleVoucher::set_allocated_cursor(::protocol::IncrementalMerkleTree* cursor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cursor_;
  }
  if (cursor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cursor);
    if (message_arena != submessage_arena) {
      cursor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cursor_ = cursor;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleVoucher.cursor)
}

// int64 cursor_depth = 4;
inline void IncrementalMerkleVoucher::clear_cursor_depth() {
  _impl_.cursor_depth_ = int64_t{0};
}
inline int64_t IncrementalMerkleVoucher::_internal_cursor_depth() const {
  return _impl_.cursor_depth_;
}
inline int64_t IncrementalMerkleVoucher::cursor_depth() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.cursor_depth)
  return _internal_cursor_depth();
}
inline void IncrementalMerkleVoucher::_internal_set_cursor_depth(int64_t value) {
  
  _impl_.cursor_depth_ = value;
}
inline void IncrementalMerkleVoucher::set_cursor_depth(int64_t value) {
  _internal_set_cursor_depth(value);
  // @@protoc_insertion_point(field_set:protocol.IncrementalMerkleVoucher.cursor_depth)
}

// bytes rt = 5;
inline void IncrementalMerkleVoucher::clear_rt() {
  _impl_.rt_.ClearToEmpty();
}
inline const std::string& IncrementalMerkleVoucher::rt() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.rt)
  return _internal_rt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncrementalMerkleVoucher::set_rt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IncrementalMerkleVoucher.rt)
}
inline std::string* IncrementalMerkleVoucher::mutable_rt() {
  std::string* _s = _internal_mutable_rt();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucher.rt)
  return _s;
}
inline const std::string& IncrementalMerkleVoucher::_internal_rt() const {
  return _impl_.rt_.Get();
}
inline void IncrementalMerkleVoucher::_internal_set_rt(const std::string& value) {
  
  _impl_.rt_.Set(value, GetArenaForAllocation());
}
inline std::string* IncrementalMerkleVoucher::_internal_mutable_rt() {
  
  return _impl_.rt_.Mutable(GetArenaForAllocation());
}
inline std::string* IncrementalMerkleVoucher::release_rt() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleVoucher.rt)
  return _impl_.rt_.Release();
}
inline void IncrementalMerkleVoucher::set_allocated_rt(std::string* rt) {
  if (rt != nullptr) {
    
  } else {
    
  }
  _impl_.rt_.SetAllocated(rt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rt_.IsDefault()) {
    _impl_.rt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleVoucher.rt)
}

// .protocol.OutputPoint output_point = 10;
inline bool IncrementalMerkleVoucher::_internal_has_output_point() const {
  return this != internal_default_instance() && _impl_.output_point_ != nullptr;
}
inline bool IncrementalMerkleVoucher::has_output_point() const {
  return _internal_has_output_point();
}
inline void IncrementalMerkleVoucher::clear_output_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_point_ != nullptr) {
    delete _impl_.output_point_;
  }
  _impl_.output_point_ = nullptr;
}
inline const ::protocol::OutputPoint& IncrementalMerkleVoucher::_internal_output_point() const {
  const ::protocol::OutputPoint* p = _impl_.output_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::OutputPoint&>(
      ::protocol::_OutputPoint_default_instance_);
}
inline const ::protocol::OutputPoint& IncrementalMerkleVoucher::output_point() const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucher.output_point)
  return _internal_output_point();
}
inline void IncrementalMerkleVoucher::unsafe_arena_set_allocated_output_point(
    ::protocol::OutputPoint* output_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_point_);
  }
  _impl_.output_point_ = output_point;
  if (output_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncrementalMerkleVoucher.output_point)
}
inline ::protocol::OutputPoint* IncrementalMerkleVoucher::release_output_point() {
  
  ::protocol::OutputPoint* temp = _impl_.output_point_;
  _impl_.output_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::OutputPoint* IncrementalMerkleVoucher::unsafe_arena_release_output_point() {
  // @@protoc_insertion_point(field_release:protocol.IncrementalMerkleVoucher.output_point)
  
  ::protocol::OutputPoint* temp = _impl_.output_point_;
  _impl_.output_point_ = nullptr;
  return temp;
}
inline ::protocol::OutputPoint* IncrementalMerkleVoucher::_internal_mutable_output_point() {
  
  if (_impl_.output_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::OutputPoint>(GetArenaForAllocation());
    _impl_.output_point_ = p;
  }
  return _impl_.output_point_;
}
inline ::protocol::OutputPoint* IncrementalMerkleVoucher::mutable_output_point() {
  ::protocol::OutputPoint* _msg = _internal_mutable_output_point();
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucher.output_point)
  return _msg;
}
inline void IncrementalMerkleVoucher::set_allocated_output_point(::protocol::OutputPoint* output_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_point_;
  }
  if (output_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_point);
    if (message_arena != submessage_arena) {
      output_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_point_ = output_point;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncrementalMerkleVoucher.output_point)
}

// -------------------------------------------------------------------

// IncrementalMerkleVoucherInfo

// repeated .protocol.IncrementalMerkleVoucher vouchers = 1;
inline int IncrementalMerkleVoucherInfo::_internal_vouchers_size() const {
  return _impl_.vouchers_.size();
}
inline int IncrementalMerkleVoucherInfo::vouchers_size() const {
  return _internal_vouchers_size();
}
inline void IncrementalMerkleVoucherInfo::clear_vouchers() {
  _impl_.vouchers_.Clear();
}
inline ::protocol::IncrementalMerkleVoucher* IncrementalMerkleVoucherInfo::mutable_vouchers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucherInfo.vouchers)
  return _impl_.vouchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::IncrementalMerkleVoucher >*
IncrementalMerkleVoucherInfo::mutable_vouchers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.IncrementalMerkleVoucherInfo.vouchers)
  return &_impl_.vouchers_;
}
inline const ::protocol::IncrementalMerkleVoucher& IncrementalMerkleVoucherInfo::_internal_vouchers(int index) const {
  return _impl_.vouchers_.Get(index);
}
inline const ::protocol::IncrementalMerkleVoucher& IncrementalMerkleVoucherInfo::vouchers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucherInfo.vouchers)
  return _internal_vouchers(index);
}
inline ::protocol::IncrementalMerkleVoucher* IncrementalMerkleVoucherInfo::_internal_add_vouchers() {
  return _impl_.vouchers_.Add();
}
inline ::protocol::IncrementalMerkleVoucher* IncrementalMerkleVoucherInfo::add_vouchers() {
  ::protocol::IncrementalMerkleVoucher* _add = _internal_add_vouchers();
  // @@protoc_insertion_point(field_add:protocol.IncrementalMerkleVoucherInfo.vouchers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::IncrementalMerkleVoucher >&
IncrementalMerkleVoucherInfo::vouchers() const {
  // @@protoc_insertion_point(field_list:protocol.IncrementalMerkleVoucherInfo.vouchers)
  return _impl_.vouchers_;
}

// repeated bytes paths = 2;
inline int IncrementalMerkleVoucherInfo::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int IncrementalMerkleVoucherInfo::paths_size() const {
  return _internal_paths_size();
}
inline void IncrementalMerkleVoucherInfo::clear_paths() {
  _impl_.paths_.Clear();
}
inline std::string* IncrementalMerkleVoucherInfo::add_paths() {
  std::string* _s = _internal_add_paths();
  // @@protoc_insertion_point(field_add_mutable:protocol.IncrementalMerkleVoucherInfo.paths)
  return _s;
}
inline const std::string& IncrementalMerkleVoucherInfo::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const std::string& IncrementalMerkleVoucherInfo::paths(int index) const {
  // @@protoc_insertion_point(field_get:protocol.IncrementalMerkleVoucherInfo.paths)
  return _internal_paths(index);
}
inline std::string* IncrementalMerkleVoucherInfo::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.IncrementalMerkleVoucherInfo.paths)
  return _impl_.paths_.Mutable(index);
}
inline void IncrementalMerkleVoucherInfo::set_paths(int index, const std::string& value) {
  _impl_.paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::set_paths(int index, std::string&& value) {
  _impl_.paths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::set_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::set_paths(int index, const void* value, size_t size) {
  _impl_.paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline std::string* IncrementalMerkleVoucherInfo::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline void IncrementalMerkleVoucherInfo::add_paths(const std::string& value) {
  _impl_.paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::add_paths(std::string&& value) {
  _impl_.paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::add_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline void IncrementalMerkleVoucherInfo::add_paths(const void* value, size_t size) {
  _impl_.paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.IncrementalMerkleVoucherInfo.paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IncrementalMerkleVoucherInfo::paths() const {
  // @@protoc_insertion_point(field_list:protocol.IncrementalMerkleVoucherInfo.paths)
  return _impl_.paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IncrementalMerkleVoucherInfo::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:protocol.IncrementalMerkleVoucherInfo.paths)
  return &_impl_.paths_;
}

// -------------------------------------------------------------------

// SpendDescription

// bytes value_commitment = 1;
inline void SpendDescription::clear_value_commitment() {
  _impl_.value_commitment_.ClearToEmpty();
}
inline const std::string& SpendDescription::value_commitment() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.value_commitment)
  return _internal_value_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_value_commitment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_commitment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.value_commitment)
}
inline std::string* SpendDescription::mutable_value_commitment() {
  std::string* _s = _internal_mutable_value_commitment();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.value_commitment)
  return _s;
}
inline const std::string& SpendDescription::_internal_value_commitment() const {
  return _impl_.value_commitment_.Get();
}
inline void SpendDescription::_internal_set_value_commitment(const std::string& value) {
  
  _impl_.value_commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_value_commitment() {
  
  return _impl_.value_commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_value_commitment() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.value_commitment)
  return _impl_.value_commitment_.Release();
}
inline void SpendDescription::set_allocated_value_commitment(std::string* value_commitment) {
  if (value_commitment != nullptr) {
    
  } else {
    
  }
  _impl_.value_commitment_.SetAllocated(value_commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_commitment_.IsDefault()) {
    _impl_.value_commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.value_commitment)
}

// bytes anchor = 2;
inline void SpendDescription::clear_anchor() {
  _impl_.anchor_.ClearToEmpty();
}
inline const std::string& SpendDescription::anchor() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.anchor)
  return _internal_anchor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_anchor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.anchor_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.anchor)
}
inline std::string* SpendDescription::mutable_anchor() {
  std::string* _s = _internal_mutable_anchor();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.anchor)
  return _s;
}
inline const std::string& SpendDescription::_internal_anchor() const {
  return _impl_.anchor_.Get();
}
inline void SpendDescription::_internal_set_anchor(const std::string& value) {
  
  _impl_.anchor_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_anchor() {
  
  return _impl_.anchor_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_anchor() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.anchor)
  return _impl_.anchor_.Release();
}
inline void SpendDescription::set_allocated_anchor(std::string* anchor) {
  if (anchor != nullptr) {
    
  } else {
    
  }
  _impl_.anchor_.SetAllocated(anchor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.anchor_.IsDefault()) {
    _impl_.anchor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.anchor)
}

// bytes nullifier = 3;
inline void SpendDescription::clear_nullifier() {
  _impl_.nullifier_.ClearToEmpty();
}
inline const std::string& SpendDescription::nullifier() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.nullifier)
  return _internal_nullifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_nullifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nullifier_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.nullifier)
}
inline std::string* SpendDescription::mutable_nullifier() {
  std::string* _s = _internal_mutable_nullifier();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.nullifier)
  return _s;
}
inline const std::string& SpendDescription::_internal_nullifier() const {
  return _impl_.nullifier_.Get();
}
inline void SpendDescription::_internal_set_nullifier(const std::string& value) {
  
  _impl_.nullifier_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_nullifier() {
  
  return _impl_.nullifier_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_nullifier() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.nullifier)
  return _impl_.nullifier_.Release();
}
inline void SpendDescription::set_allocated_nullifier(std::string* nullifier) {
  if (nullifier != nullptr) {
    
  } else {
    
  }
  _impl_.nullifier_.SetAllocated(nullifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nullifier_.IsDefault()) {
    _impl_.nullifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.nullifier)
}

// bytes rk = 4;
inline void SpendDescription::clear_rk() {
  _impl_.rk_.ClearToEmpty();
}
inline const std::string& SpendDescription::rk() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.rk)
  return _internal_rk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_rk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.rk)
}
inline std::string* SpendDescription::mutable_rk() {
  std::string* _s = _internal_mutable_rk();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.rk)
  return _s;
}
inline const std::string& SpendDescription::_internal_rk() const {
  return _impl_.rk_.Get();
}
inline void SpendDescription::_internal_set_rk(const std::string& value) {
  
  _impl_.rk_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_rk() {
  
  return _impl_.rk_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_rk() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.rk)
  return _impl_.rk_.Release();
}
inline void SpendDescription::set_allocated_rk(std::string* rk) {
  if (rk != nullptr) {
    
  } else {
    
  }
  _impl_.rk_.SetAllocated(rk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rk_.IsDefault()) {
    _impl_.rk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.rk)
}

// bytes zkproof = 5;
inline void SpendDescription::clear_zkproof() {
  _impl_.zkproof_.ClearToEmpty();
}
inline const std::string& SpendDescription::zkproof() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.zkproof)
  return _internal_zkproof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_zkproof(ArgT0&& arg0, ArgT... args) {
 
 _impl_.zkproof_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.zkproof)
}
inline std::string* SpendDescription::mutable_zkproof() {
  std::string* _s = _internal_mutable_zkproof();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.zkproof)
  return _s;
}
inline const std::string& SpendDescription::_internal_zkproof() const {
  return _impl_.zkproof_.Get();
}
inline void SpendDescription::_internal_set_zkproof(const std::string& value) {
  
  _impl_.zkproof_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_zkproof() {
  
  return _impl_.zkproof_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_zkproof() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.zkproof)
  return _impl_.zkproof_.Release();
}
inline void SpendDescription::set_allocated_zkproof(std::string* zkproof) {
  if (zkproof != nullptr) {
    
  } else {
    
  }
  _impl_.zkproof_.SetAllocated(zkproof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zkproof_.IsDefault()) {
    _impl_.zkproof_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.zkproof)
}

// bytes spend_authority_signature = 6;
inline void SpendDescription::clear_spend_authority_signature() {
  _impl_.spend_authority_signature_.ClearToEmpty();
}
inline const std::string& SpendDescription::spend_authority_signature() const {
  // @@protoc_insertion_point(field_get:protocol.SpendDescription.spend_authority_signature)
  return _internal_spend_authority_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendDescription::set_spend_authority_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spend_authority_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendDescription.spend_authority_signature)
}
inline std::string* SpendDescription::mutable_spend_authority_signature() {
  std::string* _s = _internal_mutable_spend_authority_signature();
  // @@protoc_insertion_point(field_mutable:protocol.SpendDescription.spend_authority_signature)
  return _s;
}
inline const std::string& SpendDescription::_internal_spend_authority_signature() const {
  return _impl_.spend_authority_signature_.Get();
}
inline void SpendDescription::_internal_set_spend_authority_signature(const std::string& value) {
  
  _impl_.spend_authority_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SpendDescription::_internal_mutable_spend_authority_signature() {
  
  return _impl_.spend_authority_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SpendDescription::release_spend_authority_signature() {
  // @@protoc_insertion_point(field_release:protocol.SpendDescription.spend_authority_signature)
  return _impl_.spend_authority_signature_.Release();
}
inline void SpendDescription::set_allocated_spend_authority_signature(std::string* spend_authority_signature) {
  if (spend_authority_signature != nullptr) {
    
  } else {
    
  }
  _impl_.spend_authority_signature_.SetAllocated(spend_authority_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_authority_signature_.IsDefault()) {
    _impl_.spend_authority_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendDescription.spend_authority_signature)
}

// -------------------------------------------------------------------

// ReceiveDescription

// bytes value_commitment = 1;
inline void ReceiveDescription::clear_value_commitment() {
  _impl_.value_commitment_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::value_commitment() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.value_commitment)
  return _internal_value_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_value_commitment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_commitment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.value_commitment)
}
inline std::string* ReceiveDescription::mutable_value_commitment() {
  std::string* _s = _internal_mutable_value_commitment();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.value_commitment)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_value_commitment() const {
  return _impl_.value_commitment_.Get();
}
inline void ReceiveDescription::_internal_set_value_commitment(const std::string& value) {
  
  _impl_.value_commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_value_commitment() {
  
  return _impl_.value_commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_value_commitment() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.value_commitment)
  return _impl_.value_commitment_.Release();
}
inline void ReceiveDescription::set_allocated_value_commitment(std::string* value_commitment) {
  if (value_commitment != nullptr) {
    
  } else {
    
  }
  _impl_.value_commitment_.SetAllocated(value_commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_commitment_.IsDefault()) {
    _impl_.value_commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.value_commitment)
}

// bytes note_commitment = 2;
inline void ReceiveDescription::clear_note_commitment() {
  _impl_.note_commitment_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::note_commitment() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.note_commitment)
  return _internal_note_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_note_commitment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_commitment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.note_commitment)
}
inline std::string* ReceiveDescription::mutable_note_commitment() {
  std::string* _s = _internal_mutable_note_commitment();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.note_commitment)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_note_commitment() const {
  return _impl_.note_commitment_.Get();
}
inline void ReceiveDescription::_internal_set_note_commitment(const std::string& value) {
  
  _impl_.note_commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_note_commitment() {
  
  return _impl_.note_commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_note_commitment() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.note_commitment)
  return _impl_.note_commitment_.Release();
}
inline void ReceiveDescription::set_allocated_note_commitment(std::string* note_commitment) {
  if (note_commitment != nullptr) {
    
  } else {
    
  }
  _impl_.note_commitment_.SetAllocated(note_commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_commitment_.IsDefault()) {
    _impl_.note_commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.note_commitment)
}

// bytes epk = 3;
inline void ReceiveDescription::clear_epk() {
  _impl_.epk_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::epk() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.epk)
  return _internal_epk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_epk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.epk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.epk)
}
inline std::string* ReceiveDescription::mutable_epk() {
  std::string* _s = _internal_mutable_epk();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.epk)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_epk() const {
  return _impl_.epk_.Get();
}
inline void ReceiveDescription::_internal_set_epk(const std::string& value) {
  
  _impl_.epk_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_epk() {
  
  return _impl_.epk_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_epk() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.epk)
  return _impl_.epk_.Release();
}
inline void ReceiveDescription::set_allocated_epk(std::string* epk) {
  if (epk != nullptr) {
    
  } else {
    
  }
  _impl_.epk_.SetAllocated(epk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.epk_.IsDefault()) {
    _impl_.epk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.epk)
}

// bytes c_enc = 4;
inline void ReceiveDescription::clear_c_enc() {
  _impl_.c_enc_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::c_enc() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.c_enc)
  return _internal_c_enc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_c_enc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.c_enc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.c_enc)
}
inline std::string* ReceiveDescription::mutable_c_enc() {
  std::string* _s = _internal_mutable_c_enc();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.c_enc)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_c_enc() const {
  return _impl_.c_enc_.Get();
}
inline void ReceiveDescription::_internal_set_c_enc(const std::string& value) {
  
  _impl_.c_enc_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_c_enc() {
  
  return _impl_.c_enc_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_c_enc() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.c_enc)
  return _impl_.c_enc_.Release();
}
inline void ReceiveDescription::set_allocated_c_enc(std::string* c_enc) {
  if (c_enc != nullptr) {
    
  } else {
    
  }
  _impl_.c_enc_.SetAllocated(c_enc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.c_enc_.IsDefault()) {
    _impl_.c_enc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.c_enc)
}

// bytes c_out = 5;
inline void ReceiveDescription::clear_c_out() {
  _impl_.c_out_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::c_out() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.c_out)
  return _internal_c_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_c_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.c_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.c_out)
}
inline std::string* ReceiveDescription::mutable_c_out() {
  std::string* _s = _internal_mutable_c_out();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.c_out)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_c_out() const {
  return _impl_.c_out_.Get();
}
inline void ReceiveDescription::_internal_set_c_out(const std::string& value) {
  
  _impl_.c_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_c_out() {
  
  return _impl_.c_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_c_out() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.c_out)
  return _impl_.c_out_.Release();
}
inline void ReceiveDescription::set_allocated_c_out(std::string* c_out) {
  if (c_out != nullptr) {
    
  } else {
    
  }
  _impl_.c_out_.SetAllocated(c_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.c_out_.IsDefault()) {
    _impl_.c_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.c_out)
}

// bytes zkproof = 6;
inline void ReceiveDescription::clear_zkproof() {
  _impl_.zkproof_.ClearToEmpty();
}
inline const std::string& ReceiveDescription::zkproof() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveDescription.zkproof)
  return _internal_zkproof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveDescription::set_zkproof(ArgT0&& arg0, ArgT... args) {
 
 _impl_.zkproof_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ReceiveDescription.zkproof)
}
inline std::string* ReceiveDescription::mutable_zkproof() {
  std::string* _s = _internal_mutable_zkproof();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveDescription.zkproof)
  return _s;
}
inline const std::string& ReceiveDescription::_internal_zkproof() const {
  return _impl_.zkproof_.Get();
}
inline void ReceiveDescription::_internal_set_zkproof(const std::string& value) {
  
  _impl_.zkproof_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveDescription::_internal_mutable_zkproof() {
  
  return _impl_.zkproof_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveDescription::release_zkproof() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveDescription.zkproof)
  return _impl_.zkproof_.Release();
}
inline void ReceiveDescription::set_allocated_zkproof(std::string* zkproof) {
  if (zkproof != nullptr) {
    
  } else {
    
  }
  _impl_.zkproof_.SetAllocated(zkproof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zkproof_.IsDefault()) {
    _impl_.zkproof_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveDescription.zkproof)
}

// -------------------------------------------------------------------

// ShieldedTransferContract

// bytes transparent_from_address = 1;
inline void ShieldedTransferContract::clear_transparent_from_address() {
  _impl_.transparent_from_address_.ClearToEmpty();
}
inline const std::string& ShieldedTransferContract::transparent_from_address() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.transparent_from_address)
  return _internal_transparent_from_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTransferContract::set_transparent_from_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transparent_from_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTransferContract.transparent_from_address)
}
inline std::string* ShieldedTransferContract::mutable_transparent_from_address() {
  std::string* _s = _internal_mutable_transparent_from_address();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTransferContract.transparent_from_address)
  return _s;
}
inline const std::string& ShieldedTransferContract::_internal_transparent_from_address() const {
  return _impl_.transparent_from_address_.Get();
}
inline void ShieldedTransferContract::_internal_set_transparent_from_address(const std::string& value) {
  
  _impl_.transparent_from_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::_internal_mutable_transparent_from_address() {
  
  return _impl_.transparent_from_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::release_transparent_from_address() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTransferContract.transparent_from_address)
  return _impl_.transparent_from_address_.Release();
}
inline void ShieldedTransferContract::set_allocated_transparent_from_address(std::string* transparent_from_address) {
  if (transparent_from_address != nullptr) {
    
  } else {
    
  }
  _impl_.transparent_from_address_.SetAllocated(transparent_from_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transparent_from_address_.IsDefault()) {
    _impl_.transparent_from_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTransferContract.transparent_from_address)
}

// int64 from_amount = 2;
inline void ShieldedTransferContract::clear_from_amount() {
  _impl_.from_amount_ = int64_t{0};
}
inline int64_t ShieldedTransferContract::_internal_from_amount() const {
  return _impl_.from_amount_;
}
inline int64_t ShieldedTransferContract::from_amount() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.from_amount)
  return _internal_from_amount();
}
inline void ShieldedTransferContract::_internal_set_from_amount(int64_t value) {
  
  _impl_.from_amount_ = value;
}
inline void ShieldedTransferContract::set_from_amount(int64_t value) {
  _internal_set_from_amount(value);
  // @@protoc_insertion_point(field_set:protocol.ShieldedTransferContract.from_amount)
}

// repeated .protocol.SpendDescription spend_description = 3;
inline int ShieldedTransferContract::_internal_spend_description_size() const {
  return _impl_.spend_description_.size();
}
inline int ShieldedTransferContract::spend_description_size() const {
  return _internal_spend_description_size();
}
inline void ShieldedTransferContract::clear_spend_description() {
  _impl_.spend_description_.Clear();
}
inline ::protocol::SpendDescription* ShieldedTransferContract::mutable_spend_description(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTransferContract.spend_description)
  return _impl_.spend_description_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >*
ShieldedTransferContract::mutable_spend_description() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ShieldedTransferContract.spend_description)
  return &_impl_.spend_description_;
}
inline const ::protocol::SpendDescription& ShieldedTransferContract::_internal_spend_description(int index) const {
  return _impl_.spend_description_.Get(index);
}
inline const ::protocol::SpendDescription& ShieldedTransferContract::spend_description(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.spend_description)
  return _internal_spend_description(index);
}
inline ::protocol::SpendDescription* ShieldedTransferContract::_internal_add_spend_description() {
  return _impl_.spend_description_.Add();
}
inline ::protocol::SpendDescription* ShieldedTransferContract::add_spend_description() {
  ::protocol::SpendDescription* _add = _internal_add_spend_description();
  // @@protoc_insertion_point(field_add:protocol.ShieldedTransferContract.spend_description)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >&
ShieldedTransferContract::spend_description() const {
  // @@protoc_insertion_point(field_list:protocol.ShieldedTransferContract.spend_description)
  return _impl_.spend_description_;
}

// repeated .protocol.ReceiveDescription receive_description = 4;
inline int ShieldedTransferContract::_internal_receive_description_size() const {
  return _impl_.receive_description_.size();
}
inline int ShieldedTransferContract::receive_description_size() const {
  return _internal_receive_description_size();
}
inline void ShieldedTransferContract::clear_receive_description() {
  _impl_.receive_description_.Clear();
}
inline ::protocol::ReceiveDescription* ShieldedTransferContract::mutable_receive_description(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTransferContract.receive_description)
  return _impl_.receive_description_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >*
ShieldedTransferContract::mutable_receive_description() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ShieldedTransferContract.receive_description)
  return &_impl_.receive_description_;
}
inline const ::protocol::ReceiveDescription& ShieldedTransferContract::_internal_receive_description(int index) const {
  return _impl_.receive_description_.Get(index);
}
inline const ::protocol::ReceiveDescription& ShieldedTransferContract::receive_description(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.receive_description)
  return _internal_receive_description(index);
}
inline ::protocol::ReceiveDescription* ShieldedTransferContract::_internal_add_receive_description() {
  return _impl_.receive_description_.Add();
}
inline ::protocol::ReceiveDescription* ShieldedTransferContract::add_receive_description() {
  ::protocol::ReceiveDescription* _add = _internal_add_receive_description();
  // @@protoc_insertion_point(field_add:protocol.ShieldedTransferContract.receive_description)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >&
ShieldedTransferContract::receive_description() const {
  // @@protoc_insertion_point(field_list:protocol.ShieldedTransferContract.receive_description)
  return _impl_.receive_description_;
}

// bytes binding_signature = 5;
inline void ShieldedTransferContract::clear_binding_signature() {
  _impl_.binding_signature_.ClearToEmpty();
}
inline const std::string& ShieldedTransferContract::binding_signature() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.binding_signature)
  return _internal_binding_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTransferContract::set_binding_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binding_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTransferContract.binding_signature)
}
inline std::string* ShieldedTransferContract::mutable_binding_signature() {
  std::string* _s = _internal_mutable_binding_signature();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTransferContract.binding_signature)
  return _s;
}
inline const std::string& ShieldedTransferContract::_internal_binding_signature() const {
  return _impl_.binding_signature_.Get();
}
inline void ShieldedTransferContract::_internal_set_binding_signature(const std::string& value) {
  
  _impl_.binding_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::_internal_mutable_binding_signature() {
  
  return _impl_.binding_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::release_binding_signature() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTransferContract.binding_signature)
  return _impl_.binding_signature_.Release();
}
inline void ShieldedTransferContract::set_allocated_binding_signature(std::string* binding_signature) {
  if (binding_signature != nullptr) {
    
  } else {
    
  }
  _impl_.binding_signature_.SetAllocated(binding_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binding_signature_.IsDefault()) {
    _impl_.binding_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTransferContract.binding_signature)
}

// bytes transparent_to_address = 6;
inline void ShieldedTransferContract::clear_transparent_to_address() {
  _impl_.transparent_to_address_.ClearToEmpty();
}
inline const std::string& ShieldedTransferContract::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTransferContract::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transparent_to_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTransferContract.transparent_to_address)
}
inline std::string* ShieldedTransferContract::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTransferContract.transparent_to_address)
  return _s;
}
inline const std::string& ShieldedTransferContract::_internal_transparent_to_address() const {
  return _impl_.transparent_to_address_.Get();
}
inline void ShieldedTransferContract::_internal_set_transparent_to_address(const std::string& value) {
  
  _impl_.transparent_to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::_internal_mutable_transparent_to_address() {
  
  return _impl_.transparent_to_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ShieldedTransferContract::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTransferContract.transparent_to_address)
  return _impl_.transparent_to_address_.Release();
}
inline void ShieldedTransferContract::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  _impl_.transparent_to_address_.SetAllocated(transparent_to_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transparent_to_address_.IsDefault()) {
    _impl_.transparent_to_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTransferContract.transparent_to_address)
}

// int64 to_amount = 7;
inline void ShieldedTransferContract::clear_to_amount() {
  _impl_.to_amount_ = int64_t{0};
}
inline int64_t ShieldedTransferContract::_internal_to_amount() const {
  return _impl_.to_amount_;
}
inline int64_t ShieldedTransferContract::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTransferContract.to_amount)
  return _internal_to_amount();
}
inline void ShieldedTransferContract::_internal_set_to_amount(int64_t value) {
  
  _impl_.to_amount_ = value;
}
inline void ShieldedTransferContract::set_to_amount(int64_t value) {
  _internal_set_to_amount(value);
  // @@protoc_insertion_point(field_set:protocol.ShieldedTransferContract.to_amount)
}

// -------------------------------------------------------------------

// SmartContract_ABI_Entry_Param

// bool indexed = 1;
inline void SmartContract_ABI_Entry_Param::clear_indexed() {
  _impl_.indexed_ = false;
}
inline bool SmartContract_ABI_Entry_Param::_internal_indexed() const {
  return _impl_.indexed_;
}
inline bool SmartContract_ABI_Entry_Param::indexed() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.Param.indexed)
  return _internal_indexed();
}
inline void SmartContract_ABI_Entry_Param::_internal_set_indexed(bool value) {
  
  _impl_.indexed_ = value;
}
inline void SmartContract_ABI_Entry_Param::set_indexed(bool value) {
  _internal_set_indexed(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.Param.indexed)
}

// string name = 2;
inline void SmartContract_ABI_Entry_Param::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SmartContract_ABI_Entry_Param::name() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.Param.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract_ABI_Entry_Param::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.Param.name)
}
inline std::string* SmartContract_ABI_Entry_Param::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.Entry.Param.name)
  return _s;
}
inline const std::string& SmartContract_ABI_Entry_Param::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SmartContract_ABI_Entry_Param::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry_Param::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry_Param::release_name() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.ABI.Entry.Param.name)
  return _impl_.name_.Release();
}
inline void SmartContract_ABI_Entry_Param::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.ABI.Entry.Param.name)
}

// string type = 3;
inline void SmartContract_ABI_Entry_Param::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& SmartContract_ABI_Entry_Param::type() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.Param.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract_ABI_Entry_Param::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.Param.type)
}
inline std::string* SmartContract_ABI_Entry_Param::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.Entry.Param.type)
  return _s;
}
inline const std::string& SmartContract_ABI_Entry_Param::_internal_type() const {
  return _impl_.type_.Get();
}
inline void SmartContract_ABI_Entry_Param::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry_Param::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry_Param::release_type() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.ABI.Entry.Param.type)
  return _impl_.type_.Release();
}
inline void SmartContract_ABI_Entry_Param::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.ABI.Entry.Param.type)
}

// -------------------------------------------------------------------

// SmartContract_ABI_Entry

// bool anonymous = 1;
inline void SmartContract_ABI_Entry::clear_anonymous() {
  _impl_.anonymous_ = false;
}
inline bool SmartContract_ABI_Entry::_internal_anonymous() const {
  return _impl_.anonymous_;
}
inline bool SmartContract_ABI_Entry::anonymous() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.anonymous)
  return _internal_anonymous();
}
inline void SmartContract_ABI_Entry::_internal_set_anonymous(bool value) {
  
  _impl_.anonymous_ = value;
}
inline void SmartContract_ABI_Entry::set_anonymous(bool value) {
  _internal_set_anonymous(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.anonymous)
}

// bool constant = 2;
inline void SmartContract_ABI_Entry::clear_constant() {
  _impl_.constant_ = false;
}
inline bool SmartContract_ABI_Entry::_internal_constant() const {
  return _impl_.constant_;
}
inline bool SmartContract_ABI_Entry::constant() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.constant)
  return _internal_constant();
}
inline void SmartContract_ABI_Entry::_internal_set_constant(bool value) {
  
  _impl_.constant_ = value;
}
inline void SmartContract_ABI_Entry::set_constant(bool value) {
  _internal_set_constant(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.constant)
}

// string name = 3;
inline void SmartContract_ABI_Entry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SmartContract_ABI_Entry::name() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract_ABI_Entry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.name)
}
inline std::string* SmartContract_ABI_Entry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.Entry.name)
  return _s;
}
inline const std::string& SmartContract_ABI_Entry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SmartContract_ABI_Entry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract_ABI_Entry::release_name() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.ABI.Entry.name)
  return _impl_.name_.Release();
}
inline void SmartContract_ABI_Entry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.ABI.Entry.name)
}

// repeated .protocol.SmartContract.ABI.Entry.Param inputs = 4;
inline int SmartContract_ABI_Entry::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int SmartContract_ABI_Entry::inputs_size() const {
  return _internal_inputs_size();
}
inline void SmartContract_ABI_Entry::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.Entry.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >*
SmartContract_ABI_Entry::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SmartContract.ABI.Entry.inputs)
  return &_impl_.inputs_;
}
inline const ::protocol::SmartContract_ABI_Entry_Param& SmartContract_ABI_Entry::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::protocol::SmartContract_ABI_Entry_Param& SmartContract_ABI_Entry::inputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.inputs)
  return _internal_inputs(index);
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::add_inputs() {
  ::protocol::SmartContract_ABI_Entry_Param* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:protocol.SmartContract.ABI.Entry.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >&
SmartContract_ABI_Entry::inputs() const {
  // @@protoc_insertion_point(field_list:protocol.SmartContract.ABI.Entry.inputs)
  return _impl_.inputs_;
}

// repeated .protocol.SmartContract.ABI.Entry.Param outputs = 5;
inline int SmartContract_ABI_Entry::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int SmartContract_ABI_Entry::outputs_size() const {
  return _internal_outputs_size();
}
inline void SmartContract_ABI_Entry::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.Entry.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >*
SmartContract_ABI_Entry::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SmartContract.ABI.Entry.outputs)
  return &_impl_.outputs_;
}
inline const ::protocol::SmartContract_ABI_Entry_Param& SmartContract_ABI_Entry::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::protocol::SmartContract_ABI_Entry_Param& SmartContract_ABI_Entry::outputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.outputs)
  return _internal_outputs(index);
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::protocol::SmartContract_ABI_Entry_Param* SmartContract_ABI_Entry::add_outputs() {
  ::protocol::SmartContract_ABI_Entry_Param* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:protocol.SmartContract.ABI.Entry.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry_Param >&
SmartContract_ABI_Entry::outputs() const {
  // @@protoc_insertion_point(field_list:protocol.SmartContract.ABI.Entry.outputs)
  return _impl_.outputs_;
}

// .protocol.SmartContract.ABI.Entry.EntryType type = 6;
inline void SmartContract_ABI_Entry::clear_type() {
  _impl_.type_ = 0;
}
inline ::protocol::SmartContract_ABI_Entry_EntryType SmartContract_ABI_Entry::_internal_type() const {
  return static_cast< ::protocol::SmartContract_ABI_Entry_EntryType >(_impl_.type_);
}
inline ::protocol::SmartContract_ABI_Entry_EntryType SmartContract_ABI_Entry::type() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.type)
  return _internal_type();
}
inline void SmartContract_ABI_Entry::_internal_set_type(::protocol::SmartContract_ABI_Entry_EntryType value) {
  
  _impl_.type_ = value;
}
inline void SmartContract_ABI_Entry::set_type(::protocol::SmartContract_ABI_Entry_EntryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.type)
}

// bool payable = 7;
inline void SmartContract_ABI_Entry::clear_payable() {
  _impl_.payable_ = false;
}
inline bool SmartContract_ABI_Entry::_internal_payable() const {
  return _impl_.payable_;
}
inline bool SmartContract_ABI_Entry::payable() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.payable)
  return _internal_payable();
}
inline void SmartContract_ABI_Entry::_internal_set_payable(bool value) {
  
  _impl_.payable_ = value;
}
inline void SmartContract_ABI_Entry::set_payable(bool value) {
  _internal_set_payable(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.payable)
}

// .protocol.SmartContract.ABI.Entry.StateMutabilityType stateMutability = 8;
inline void SmartContract_ABI_Entry::clear_statemutability() {
  _impl_.statemutability_ = 0;
}
inline ::protocol::SmartContract_ABI_Entry_StateMutabilityType SmartContract_ABI_Entry::_internal_statemutability() const {
  return static_cast< ::protocol::SmartContract_ABI_Entry_StateMutabilityType >(_impl_.statemutability_);
}
inline ::protocol::SmartContract_ABI_Entry_StateMutabilityType SmartContract_ABI_Entry::statemutability() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.Entry.stateMutability)
  return _internal_statemutability();
}
inline void SmartContract_ABI_Entry::_internal_set_statemutability(::protocol::SmartContract_ABI_Entry_StateMutabilityType value) {
  
  _impl_.statemutability_ = value;
}
inline void SmartContract_ABI_Entry::set_statemutability(::protocol::SmartContract_ABI_Entry_StateMutabilityType value) {
  _internal_set_statemutability(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.ABI.Entry.stateMutability)
}

// -------------------------------------------------------------------

// SmartContract_ABI

// repeated .protocol.SmartContract.ABI.Entry entrys = 1;
inline int SmartContract_ABI::_internal_entrys_size() const {
  return _impl_.entrys_.size();
}
inline int SmartContract_ABI::entrys_size() const {
  return _internal_entrys_size();
}
inline void SmartContract_ABI::clear_entrys() {
  _impl_.entrys_.Clear();
}
inline ::protocol::SmartContract_ABI_Entry* SmartContract_ABI::mutable_entrys(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.ABI.entrys)
  return _impl_.entrys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry >*
SmartContract_ABI::mutable_entrys() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SmartContract.ABI.entrys)
  return &_impl_.entrys_;
}
inline const ::protocol::SmartContract_ABI_Entry& SmartContract_ABI::_internal_entrys(int index) const {
  return _impl_.entrys_.Get(index);
}
inline const ::protocol::SmartContract_ABI_Entry& SmartContract_ABI::entrys(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.ABI.entrys)
  return _internal_entrys(index);
}
inline ::protocol::SmartContract_ABI_Entry* SmartContract_ABI::_internal_add_entrys() {
  return _impl_.entrys_.Add();
}
inline ::protocol::SmartContract_ABI_Entry* SmartContract_ABI::add_entrys() {
  ::protocol::SmartContract_ABI_Entry* _add = _internal_add_entrys();
  // @@protoc_insertion_point(field_add:protocol.SmartContract.ABI.entrys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SmartContract_ABI_Entry >&
SmartContract_ABI::entrys() const {
  // @@protoc_insertion_point(field_list:protocol.SmartContract.ABI.entrys)
  return _impl_.entrys_;
}

// -------------------------------------------------------------------

// SmartContract

// bytes origin_address = 1;
inline void SmartContract::clear_origin_address() {
  _impl_.origin_address_.ClearToEmpty();
}
inline const std::string& SmartContract::origin_address() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.origin_address)
  return _internal_origin_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_origin_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.origin_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.origin_address)
}
inline std::string* SmartContract::mutable_origin_address() {
  std::string* _s = _internal_mutable_origin_address();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.origin_address)
  return _s;
}
inline const std::string& SmartContract::_internal_origin_address() const {
  return _impl_.origin_address_.Get();
}
inline void SmartContract::_internal_set_origin_address(const std::string& value) {
  
  _impl_.origin_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_origin_address() {
  
  return _impl_.origin_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_origin_address() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.origin_address)
  return _impl_.origin_address_.Release();
}
inline void SmartContract::set_allocated_origin_address(std::string* origin_address) {
  if (origin_address != nullptr) {
    
  } else {
    
  }
  _impl_.origin_address_.SetAllocated(origin_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.origin_address_.IsDefault()) {
    _impl_.origin_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.origin_address)
}

// bytes contract_address = 2;
inline void SmartContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& SmartContract::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.contract_address)
}
inline std::string* SmartContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.contract_address)
  return _s;
}
inline const std::string& SmartContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void SmartContract::_internal_set_contract_address(const std::string& value) {
  
  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_contract_address() {
  
  return _impl_.contract_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void SmartContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  _impl_.contract_address_.SetAllocated(contract_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_address_.IsDefault()) {
    _impl_.contract_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.contract_address)
}

// .protocol.SmartContract.ABI abi = 3;
inline bool SmartContract::_internal_has_abi() const {
  return this != internal_default_instance() && _impl_.abi_ != nullptr;
}
inline bool SmartContract::has_abi() const {
  return _internal_has_abi();
}
inline void SmartContract::clear_abi() {
  if (GetArenaForAllocation() == nullptr && _impl_.abi_ != nullptr) {
    delete _impl_.abi_;
  }
  _impl_.abi_ = nullptr;
}
inline const ::protocol::SmartContract_ABI& SmartContract::_internal_abi() const {
  const ::protocol::SmartContract_ABI* p = _impl_.abi_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::SmartContract_ABI&>(
      ::protocol::_SmartContract_ABI_default_instance_);
}
inline const ::protocol::SmartContract_ABI& SmartContract::abi() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.abi)
  return _internal_abi();
}
inline void SmartContract::unsafe_arena_set_allocated_abi(
    ::protocol::SmartContract_ABI* abi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.abi_);
  }
  _impl_.abi_ = abi;
  if (abi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SmartContract.abi)
}
inline ::protocol::SmartContract_ABI* SmartContract::release_abi() {
  
  ::protocol::SmartContract_ABI* temp = _impl_.abi_;
  _impl_.abi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::SmartContract_ABI* SmartContract::unsafe_arena_release_abi() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.abi)
  
  ::protocol::SmartContract_ABI* temp = _impl_.abi_;
  _impl_.abi_ = nullptr;
  return temp;
}
inline ::protocol::SmartContract_ABI* SmartContract::_internal_mutable_abi() {
  
  if (_impl_.abi_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::SmartContract_ABI>(GetArenaForAllocation());
    _impl_.abi_ = p;
  }
  return _impl_.abi_;
}
inline ::protocol::SmartContract_ABI* SmartContract::mutable_abi() {
  ::protocol::SmartContract_ABI* _msg = _internal_mutable_abi();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.abi)
  return _msg;
}
inline void SmartContract::set_allocated_abi(::protocol::SmartContract_ABI* abi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.abi_;
  }
  if (abi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(abi);
    if (message_arena != submessage_arena) {
      abi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.abi_ = abi;
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.abi)
}

// bytes bytecode = 4;
inline void SmartContract::clear_bytecode() {
  _impl_.bytecode_.ClearToEmpty();
}
inline const std::string& SmartContract::bytecode() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.bytecode)
  return _internal_bytecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_bytecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bytecode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.bytecode)
}
inline std::string* SmartContract::mutable_bytecode() {
  std::string* _s = _internal_mutable_bytecode();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.bytecode)
  return _s;
}
inline const std::string& SmartContract::_internal_bytecode() const {
  return _impl_.bytecode_.Get();
}
inline void SmartContract::_internal_set_bytecode(const std::string& value) {
  
  _impl_.bytecode_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_bytecode() {
  
  return _impl_.bytecode_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_bytecode() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.bytecode)
  return _impl_.bytecode_.Release();
}
inline void SmartContract::set_allocated_bytecode(std::string* bytecode) {
  if (bytecode != nullptr) {
    
  } else {
    
  }
  _impl_.bytecode_.SetAllocated(bytecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bytecode_.IsDefault()) {
    _impl_.bytecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.bytecode)
}

// int64 call_value = 5;
inline void SmartContract::clear_call_value() {
  _impl_.call_value_ = int64_t{0};
}
inline int64_t SmartContract::_internal_call_value() const {
  return _impl_.call_value_;
}
inline int64_t SmartContract::call_value() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.call_value)
  return _internal_call_value();
}
inline void SmartContract::_internal_set_call_value(int64_t value) {
  
  _impl_.call_value_ = value;
}
inline void SmartContract::set_call_value(int64_t value) {
  _internal_set_call_value(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.call_value)
}

// int64 consume_user_resource_percent = 6;
inline void SmartContract::clear_consume_user_resource_percent() {
  _impl_.consume_user_resource_percent_ = int64_t{0};
}
inline int64_t SmartContract::_internal_consume_user_resource_percent() const {
  return _impl_.consume_user_resource_percent_;
}
inline int64_t SmartContract::consume_user_resource_percent() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.consume_user_resource_percent)
  return _internal_consume_user_resource_percent();
}
inline void SmartContract::_internal_set_consume_user_resource_percent(int64_t value) {
  
  _impl_.consume_user_resource_percent_ = value;
}
inline void SmartContract::set_consume_user_resource_percent(int64_t value) {
  _internal_set_consume_user_resource_percent(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.consume_user_resource_percent)
}

// string name = 7;
inline void SmartContract::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SmartContract::name() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.name)
}
inline std::string* SmartContract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.name)
  return _s;
}
inline const std::string& SmartContract::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SmartContract::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_name() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.name)
  return _impl_.name_.Release();
}
inline void SmartContract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.name)
}

// int64 origin_energy_limit = 8;
inline void SmartContract::clear_origin_energy_limit() {
  _impl_.origin_energy_limit_ = int64_t{0};
}
inline int64_t SmartContract::_internal_origin_energy_limit() const {
  return _impl_.origin_energy_limit_;
}
inline int64_t SmartContract::origin_energy_limit() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.origin_energy_limit)
  return _internal_origin_energy_limit();
}
inline void SmartContract::_internal_set_origin_energy_limit(int64_t value) {
  
  _impl_.origin_energy_limit_ = value;
}
inline void SmartContract::set_origin_energy_limit(int64_t value) {
  _internal_set_origin_energy_limit(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.origin_energy_limit)
}

// bytes code_hash = 9;
inline void SmartContract::clear_code_hash() {
  _impl_.code_hash_.ClearToEmpty();
}
inline const std::string& SmartContract::code_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.code_hash)
  return _internal_code_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_code_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.code_hash)
}
inline std::string* SmartContract::mutable_code_hash() {
  std::string* _s = _internal_mutable_code_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.code_hash)
  return _s;
}
inline const std::string& SmartContract::_internal_code_hash() const {
  return _impl_.code_hash_.Get();
}
inline void SmartContract::_internal_set_code_hash(const std::string& value) {
  
  _impl_.code_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_code_hash() {
  
  return _impl_.code_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_code_hash() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.code_hash)
  return _impl_.code_hash_.Release();
}
inline void SmartContract::set_allocated_code_hash(std::string* code_hash) {
  if (code_hash != nullptr) {
    
  } else {
    
  }
  _impl_.code_hash_.SetAllocated(code_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_hash_.IsDefault()) {
    _impl_.code_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.code_hash)
}

// bytes trx_hash = 10;
inline void SmartContract::clear_trx_hash() {
  _impl_.trx_hash_.ClearToEmpty();
}
inline const std::string& SmartContract::trx_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.trx_hash)
  return _internal_trx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContract::set_trx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContract.trx_hash)
}
inline std::string* SmartContract::mutable_trx_hash() {
  std::string* _s = _internal_mutable_trx_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContract.trx_hash)
  return _s;
}
inline const std::string& SmartContract::_internal_trx_hash() const {
  return _impl_.trx_hash_.Get();
}
inline void SmartContract::_internal_set_trx_hash(const std::string& value) {
  
  _impl_.trx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContract::_internal_mutable_trx_hash() {
  
  return _impl_.trx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContract::release_trx_hash() {
  // @@protoc_insertion_point(field_release:protocol.SmartContract.trx_hash)
  return _impl_.trx_hash_.Release();
}
inline void SmartContract::set_allocated_trx_hash(std::string* trx_hash) {
  if (trx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.trx_hash_.SetAllocated(trx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trx_hash_.IsDefault()) {
    _impl_.trx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContract.trx_hash)
}

// int32 version = 11;
inline void SmartContract::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t SmartContract::_internal_version() const {
  return _impl_.version_;
}
inline int32_t SmartContract::version() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContract.version)
  return _internal_version();
}
inline void SmartContract::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void SmartContract::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.SmartContract.version)
}

// -------------------------------------------------------------------

// ContractState

// int64 energy_usage = 1;
inline void ContractState::clear_energy_usage() {
  _impl_.energy_usage_ = int64_t{0};
}
inline int64_t ContractState::_internal_energy_usage() const {
  return _impl_.energy_usage_;
}
inline int64_t ContractState::energy_usage() const {
  // @@protoc_insertion_point(field_get:protocol.ContractState.energy_usage)
  return _internal_energy_usage();
}
inline void ContractState::_internal_set_energy_usage(int64_t value) {
  
  _impl_.energy_usage_ = value;
}
inline void ContractState::set_energy_usage(int64_t value) {
  _internal_set_energy_usage(value);
  // @@protoc_insertion_point(field_set:protocol.ContractState.energy_usage)
}

// int64 energy_factor = 2;
inline void ContractState::clear_energy_factor() {
  _impl_.energy_factor_ = int64_t{0};
}
inline int64_t ContractState::_internal_energy_factor() const {
  return _impl_.energy_factor_;
}
inline int64_t ContractState::energy_factor() const {
  // @@protoc_insertion_point(field_get:protocol.ContractState.energy_factor)
  return _internal_energy_factor();
}
inline void ContractState::_internal_set_energy_factor(int64_t value) {
  
  _impl_.energy_factor_ = value;
}
inline void ContractState::set_energy_factor(int64_t value) {
  _internal_set_energy_factor(value);
  // @@protoc_insertion_point(field_set:protocol.ContractState.energy_factor)
}

// int64 update_cycle = 3;
inline void ContractState::clear_update_cycle() {
  _impl_.update_cycle_ = int64_t{0};
}
inline int64_t ContractState::_internal_update_cycle() const {
  return _impl_.update_cycle_;
}
inline int64_t ContractState::update_cycle() const {
  // @@protoc_insertion_point(field_get:protocol.ContractState.update_cycle)
  return _internal_update_cycle();
}
inline void ContractState::_internal_set_update_cycle(int64_t value) {
  
  _impl_.update_cycle_ = value;
}
inline void ContractState::set_update_cycle(int64_t value) {
  _internal_set_update_cycle(value);
  // @@protoc_insertion_point(field_set:protocol.ContractState.update_cycle)
}

// -------------------------------------------------------------------

// CreateSmartContract

// bytes owner_address = 1;
inline void CreateSmartContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& CreateSmartContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSmartContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSmartContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.CreateSmartContract.owner_address)
}
inline std::string* CreateSmartContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.CreateSmartContract.owner_address)
  return _s;
}
inline const std::string& CreateSmartContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void CreateSmartContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSmartContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSmartContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.CreateSmartContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void CreateSmartContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSmartContract.owner_address)
}

// .protocol.SmartContract new_contract = 2;
inline bool CreateSmartContract::_internal_has_new_contract() const {
  return this != internal_default_instance() && _impl_.new_contract_ != nullptr;
}
inline bool CreateSmartContract::has_new_contract() const {
  return _internal_has_new_contract();
}
inline void CreateSmartContract::clear_new_contract() {
  if (GetArenaForAllocation() == nullptr && _impl_.new_contract_ != nullptr) {
    delete _impl_.new_contract_;
  }
  _impl_.new_contract_ = nullptr;
}
inline const ::protocol::SmartContract& CreateSmartContract::_internal_new_contract() const {
  const ::protocol::SmartContract* p = _impl_.new_contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::SmartContract&>(
      ::protocol::_SmartContract_default_instance_);
}
inline const ::protocol::SmartContract& CreateSmartContract::new_contract() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSmartContract.new_contract)
  return _internal_new_contract();
}
inline void CreateSmartContract::unsafe_arena_set_allocated_new_contract(
    ::protocol::SmartContract* new_contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_contract_);
  }
  _impl_.new_contract_ = new_contract;
  if (new_contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CreateSmartContract.new_contract)
}
inline ::protocol::SmartContract* CreateSmartContract::release_new_contract() {
  
  ::protocol::SmartContract* temp = _impl_.new_contract_;
  _impl_.new_contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::SmartContract* CreateSmartContract::unsafe_arena_release_new_contract() {
  // @@protoc_insertion_point(field_release:protocol.CreateSmartContract.new_contract)
  
  ::protocol::SmartContract* temp = _impl_.new_contract_;
  _impl_.new_contract_ = nullptr;
  return temp;
}
inline ::protocol::SmartContract* CreateSmartContract::_internal_mutable_new_contract() {
  
  if (_impl_.new_contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::SmartContract>(GetArenaForAllocation());
    _impl_.new_contract_ = p;
  }
  return _impl_.new_contract_;
}
inline ::protocol::SmartContract* CreateSmartContract::mutable_new_contract() {
  ::protocol::SmartContract* _msg = _internal_mutable_new_contract();
  // @@protoc_insertion_point(field_mutable:protocol.CreateSmartContract.new_contract)
  return _msg;
}
inline void CreateSmartContract::set_allocated_new_contract(::protocol::SmartContract* new_contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_contract_;
  }
  if (new_contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_contract);
    if (message_arena != submessage_arena) {
      new_contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_contract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_contract_ = new_contract;
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSmartContract.new_contract)
}

// int64 call_token_value = 3;
inline void CreateSmartContract::clear_call_token_value() {
  _impl_.call_token_value_ = int64_t{0};
}
inline int64_t CreateSmartContract::_internal_call_token_value() const {
  return _impl_.call_token_value_;
}
inline int64_t CreateSmartContract::call_token_value() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSmartContract.call_token_value)
  return _internal_call_token_value();
}
inline void CreateSmartContract::_internal_set_call_token_value(int64_t value) {
  
  _impl_.call_token_value_ = value;
}
inline void CreateSmartContract::set_call_token_value(int64_t value) {
  _internal_set_call_token_value(value);
  // @@protoc_insertion_point(field_set:protocol.CreateSmartContract.call_token_value)
}

// int64 token_id = 4;
inline void CreateSmartContract::clear_token_id() {
  _impl_.token_id_ = int64_t{0};
}
inline int64_t CreateSmartContract::_internal_token_id() const {
  return _impl_.token_id_;
}
inline int64_t CreateSmartContract::token_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSmartContract.token_id)
  return _internal_token_id();
}
inline void CreateSmartContract::_internal_set_token_id(int64_t value) {
  
  _impl_.token_id_ = value;
}
inline void CreateSmartContract::set_token_id(int64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:protocol.CreateSmartContract.token_id)
}

// -------------------------------------------------------------------

// TriggerSmartContract

// bytes owner_address = 1;
inline void TriggerSmartContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.owner_address)
}
inline std::string* TriggerSmartContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.TriggerSmartContract.owner_address)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void TriggerSmartContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TriggerSmartContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void TriggerSmartContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TriggerSmartContract.owner_address)
}

// bytes contract_address = 2;
inline void TriggerSmartContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.contract_address)
}
inline std::string* TriggerSmartContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.TriggerSmartContract.contract_address)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void TriggerSmartContract::_internal_set_contract_address(const std::string& value) {
  
  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_contract_address() {
  
  return _impl_.contract_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.TriggerSmartContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void TriggerSmartContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  _impl_.contract_address_.SetAllocated(contract_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_address_.IsDefault()) {
    _impl_.contract_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TriggerSmartContract.contract_address)
}

// int64 call_value = 3;
inline void TriggerSmartContract::clear_call_value() {
  _impl_.call_value_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_call_value() const {
  return _impl_.call_value_;
}
inline int64_t TriggerSmartContract::call_value() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.call_value)
  return _internal_call_value();
}
inline void TriggerSmartContract::_internal_set_call_value(int64_t value) {
  
  _impl_.call_value_ = value;
}
inline void TriggerSmartContract::set_call_value(int64_t value) {
  _internal_set_call_value(value);
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.call_value)
}

// bytes data = 4;
inline void TriggerSmartContract::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TriggerSmartContract::data() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerSmartContract::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.data)
}
inline std::string* TriggerSmartContract::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.TriggerSmartContract.data)
  return _s;
}
inline const std::string& TriggerSmartContract::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TriggerSmartContract::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerSmartContract::release_data() {
  // @@protoc_insertion_point(field_release:protocol.TriggerSmartContract.data)
  return _impl_.data_.Release();
}
inline void TriggerSmartContract::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TriggerSmartContract.data)
}

// int64 call_token_value = 5;
inline void TriggerSmartContract::clear_call_token_value() {
  _impl_.call_token_value_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_call_token_value() const {
  return _impl_.call_token_value_;
}
inline int64_t TriggerSmartContract::call_token_value() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.call_token_value)
  return _internal_call_token_value();
}
inline void TriggerSmartContract::_internal_set_call_token_value(int64_t value) {
  
  _impl_.call_token_value_ = value;
}
inline void TriggerSmartContract::set_call_token_value(int64_t value) {
  _internal_set_call_token_value(value);
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.call_token_value)
}

// int64 token_id = 6;
inline void TriggerSmartContract::clear_token_id() {
  _impl_.token_id_ = int64_t{0};
}
inline int64_t TriggerSmartContract::_internal_token_id() const {
  return _impl_.token_id_;
}
inline int64_t TriggerSmartContract::token_id() const {
  // @@protoc_insertion_point(field_get:protocol.TriggerSmartContract.token_id)
  return _internal_token_id();
}
inline void TriggerSmartContract::_internal_set_token_id(int64_t value) {
  
  _impl_.token_id_ = value;
}
inline void TriggerSmartContract::set_token_id(int64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:protocol.TriggerSmartContract.token_id)
}

// -------------------------------------------------------------------

// ClearABIContract

// bytes owner_address = 1;
inline void ClearABIContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& ClearABIContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.ClearABIContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearABIContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ClearABIContract.owner_address)
}
inline std::string* ClearABIContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.ClearABIContract.owner_address)
  return _s;
}
inline const std::string& ClearABIContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void ClearABIContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearABIContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearABIContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.ClearABIContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void ClearABIContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ClearABIContract.owner_address)
}

// bytes contract_address = 2;
inline void ClearABIContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& ClearABIContract::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.ClearABIContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearABIContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ClearABIContract.contract_address)
}
inline std::string* ClearABIContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.ClearABIContract.contract_address)
  return _s;
}
inline const std::string& ClearABIContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void ClearABIContract::_internal_set_contract_address(const std::string& value) {
  
  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearABIContract::_internal_mutable_contract_address() {
  
  return _impl_.contract_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearABIContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.ClearABIContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void ClearABIContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  _impl_.contract_address_.SetAllocated(contract_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_address_.IsDefault()) {
    _impl_.contract_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ClearABIContract.contract_address)
}

// -------------------------------------------------------------------

// UpdateSettingContract

// bytes owner_address = 1;
inline void UpdateSettingContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UpdateSettingContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateSettingContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSettingContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateSettingContract.owner_address)
}
inline std::string* UpdateSettingContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateSettingContract.owner_address)
  return _s;
}
inline const std::string& UpdateSettingContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UpdateSettingContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSettingContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSettingContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateSettingContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UpdateSettingContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateSettingContract.owner_address)
}

// bytes contract_address = 2;
inline void UpdateSettingContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& UpdateSettingContract::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateSettingContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSettingContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateSettingContract.contract_address)
}
inline std::string* UpdateSettingContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateSettingContract.contract_address)
  return _s;
}
inline const std::string& UpdateSettingContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void UpdateSettingContract::_internal_set_contract_address(const std::string& value) {
  
  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSettingContract::_internal_mutable_contract_address() {
  
  return _impl_.contract_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSettingContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateSettingContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void UpdateSettingContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  _impl_.contract_address_.SetAllocated(contract_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_address_.IsDefault()) {
    _impl_.contract_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateSettingContract.contract_address)
}

// int64 consume_user_resource_percent = 3;
inline void UpdateSettingContract::clear_consume_user_resource_percent() {
  _impl_.consume_user_resource_percent_ = int64_t{0};
}
inline int64_t UpdateSettingContract::_internal_consume_user_resource_percent() const {
  return _impl_.consume_user_resource_percent_;
}
inline int64_t UpdateSettingContract::consume_user_resource_percent() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateSettingContract.consume_user_resource_percent)
  return _internal_consume_user_resource_percent();
}
inline void UpdateSettingContract::_internal_set_consume_user_resource_percent(int64_t value) {
  
  _impl_.consume_user_resource_percent_ = value;
}
inline void UpdateSettingContract::set_consume_user_resource_percent(int64_t value) {
  _internal_set_consume_user_resource_percent(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateSettingContract.consume_user_resource_percent)
}

// -------------------------------------------------------------------

// UpdateEnergyLimitContract

// bytes owner_address = 1;
inline void UpdateEnergyLimitContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UpdateEnergyLimitContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateEnergyLimitContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnergyLimitContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateEnergyLimitContract.owner_address)
}
inline std::string* UpdateEnergyLimitContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateEnergyLimitContract.owner_address)
  return _s;
}
inline const std::string& UpdateEnergyLimitContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UpdateEnergyLimitContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateEnergyLimitContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateEnergyLimitContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateEnergyLimitContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UpdateEnergyLimitContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateEnergyLimitContract.owner_address)
}

// bytes contract_address = 2;
inline void UpdateEnergyLimitContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& UpdateEnergyLimitContract::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateEnergyLimitContract.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnergyLimitContract::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateEnergyLimitContract.contract_address)
}
inline std::string* UpdateEnergyLimitContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateEnergyLimitContract.contract_address)
  return _s;
}
inline const std::string& UpdateEnergyLimitContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void UpdateEnergyLimitContract::_internal_set_contract_address(const std::string& value) {
  
  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateEnergyLimitContract::_internal_mutable_contract_address() {
  
  return _impl_.contract_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateEnergyLimitContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateEnergyLimitContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void UpdateEnergyLimitContract::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  _impl_.contract_address_.SetAllocated(contract_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_address_.IsDefault()) {
    _impl_.contract_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateEnergyLimitContract.contract_address)
}

// int64 origin_energy_limit = 3;
inline void UpdateEnergyLimitContract::clear_origin_energy_limit() {
  _impl_.origin_energy_limit_ = int64_t{0};
}
inline int64_t UpdateEnergyLimitContract::_internal_origin_energy_limit() const {
  return _impl_.origin_energy_limit_;
}
inline int64_t UpdateEnergyLimitContract::origin_energy_limit() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateEnergyLimitContract.origin_energy_limit)
  return _internal_origin_energy_limit();
}
inline void UpdateEnergyLimitContract::_internal_set_origin_energy_limit(int64_t value) {
  
  _impl_.origin_energy_limit_ = value;
}
inline void UpdateEnergyLimitContract::set_origin_energy_limit(int64_t value) {
  _internal_set_origin_energy_limit(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateEnergyLimitContract.origin_energy_limit)
}

// -------------------------------------------------------------------

// SmartContractDataWrapper

// .protocol.SmartContract smart_contract = 1;
inline bool SmartContractDataWrapper::_internal_has_smart_contract() const {
  return this != internal_default_instance() && _impl_.smart_contract_ != nullptr;
}
inline bool SmartContractDataWrapper::has_smart_contract() const {
  return _internal_has_smart_contract();
}
inline void SmartContractDataWrapper::clear_smart_contract() {
  if (GetArenaForAllocation() == nullptr && _impl_.smart_contract_ != nullptr) {
    delete _impl_.smart_contract_;
  }
  _impl_.smart_contract_ = nullptr;
}
inline const ::protocol::SmartContract& SmartContractDataWrapper::_internal_smart_contract() const {
  const ::protocol::SmartContract* p = _impl_.smart_contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::SmartContract&>(
      ::protocol::_SmartContract_default_instance_);
}
inline const ::protocol::SmartContract& SmartContractDataWrapper::smart_contract() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContractDataWrapper.smart_contract)
  return _internal_smart_contract();
}
inline void SmartContractDataWrapper::unsafe_arena_set_allocated_smart_contract(
    ::protocol::SmartContract* smart_contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.smart_contract_);
  }
  _impl_.smart_contract_ = smart_contract;
  if (smart_contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SmartContractDataWrapper.smart_contract)
}
inline ::protocol::SmartContract* SmartContractDataWrapper::release_smart_contract() {
  
  ::protocol::SmartContract* temp = _impl_.smart_contract_;
  _impl_.smart_contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::SmartContract* SmartContractDataWrapper::unsafe_arena_release_smart_contract() {
  // @@protoc_insertion_point(field_release:protocol.SmartContractDataWrapper.smart_contract)
  
  ::protocol::SmartContract* temp = _impl_.smart_contract_;
  _impl_.smart_contract_ = nullptr;
  return temp;
}
inline ::protocol::SmartContract* SmartContractDataWrapper::_internal_mutable_smart_contract() {
  
  if (_impl_.smart_contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::SmartContract>(GetArenaForAllocation());
    _impl_.smart_contract_ = p;
  }
  return _impl_.smart_contract_;
}
inline ::protocol::SmartContract* SmartContractDataWrapper::mutable_smart_contract() {
  ::protocol::SmartContract* _msg = _internal_mutable_smart_contract();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContractDataWrapper.smart_contract)
  return _msg;
}
inline void SmartContractDataWrapper::set_allocated_smart_contract(::protocol::SmartContract* smart_contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.smart_contract_;
  }
  if (smart_contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smart_contract);
    if (message_arena != submessage_arena) {
      smart_contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smart_contract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.smart_contract_ = smart_contract;
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContractDataWrapper.smart_contract)
}

// bytes runtimecode = 2;
inline void SmartContractDataWrapper::clear_runtimecode() {
  _impl_.runtimecode_.ClearToEmpty();
}
inline const std::string& SmartContractDataWrapper::runtimecode() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContractDataWrapper.runtimecode)
  return _internal_runtimecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartContractDataWrapper::set_runtimecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.runtimecode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SmartContractDataWrapper.runtimecode)
}
inline std::string* SmartContractDataWrapper::mutable_runtimecode() {
  std::string* _s = _internal_mutable_runtimecode();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContractDataWrapper.runtimecode)
  return _s;
}
inline const std::string& SmartContractDataWrapper::_internal_runtimecode() const {
  return _impl_.runtimecode_.Get();
}
inline void SmartContractDataWrapper::_internal_set_runtimecode(const std::string& value) {
  
  _impl_.runtimecode_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartContractDataWrapper::_internal_mutable_runtimecode() {
  
  return _impl_.runtimecode_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartContractDataWrapper::release_runtimecode() {
  // @@protoc_insertion_point(field_release:protocol.SmartContractDataWrapper.runtimecode)
  return _impl_.runtimecode_.Release();
}
inline void SmartContractDataWrapper::set_allocated_runtimecode(std::string* runtimecode) {
  if (runtimecode != nullptr) {
    
  } else {
    
  }
  _impl_.runtimecode_.SetAllocated(runtimecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.runtimecode_.IsDefault()) {
    _impl_.runtimecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContractDataWrapper.runtimecode)
}

// .protocol.ContractState contract_state = 3;
inline bool SmartContractDataWrapper::_internal_has_contract_state() const {
  return this != internal_default_instance() && _impl_.contract_state_ != nullptr;
}
inline bool SmartContractDataWrapper::has_contract_state() const {
  return _internal_has_contract_state();
}
inline void SmartContractDataWrapper::clear_contract_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.contract_state_ != nullptr) {
    delete _impl_.contract_state_;
  }
  _impl_.contract_state_ = nullptr;
}
inline const ::protocol::ContractState& SmartContractDataWrapper::_internal_contract_state() const {
  const ::protocol::ContractState* p = _impl_.contract_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::ContractState&>(
      ::protocol::_ContractState_default_instance_);
}
inline const ::protocol::ContractState& SmartContractDataWrapper::contract_state() const {
  // @@protoc_insertion_point(field_get:protocol.SmartContractDataWrapper.contract_state)
  return _internal_contract_state();
}
inline void SmartContractDataWrapper::unsafe_arena_set_allocated_contract_state(
    ::protocol::ContractState* contract_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_state_);
  }
  _impl_.contract_state_ = contract_state;
  if (contract_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SmartContractDataWrapper.contract_state)
}
inline ::protocol::ContractState* SmartContractDataWrapper::release_contract_state() {
  
  ::protocol::ContractState* temp = _impl_.contract_state_;
  _impl_.contract_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::ContractState* SmartContractDataWrapper::unsafe_arena_release_contract_state() {
  // @@protoc_insertion_point(field_release:protocol.SmartContractDataWrapper.contract_state)
  
  ::protocol::ContractState* temp = _impl_.contract_state_;
  _impl_.contract_state_ = nullptr;
  return temp;
}
inline ::protocol::ContractState* SmartContractDataWrapper::_internal_mutable_contract_state() {
  
  if (_impl_.contract_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::ContractState>(GetArenaForAllocation());
    _impl_.contract_state_ = p;
  }
  return _impl_.contract_state_;
}
inline ::protocol::ContractState* SmartContractDataWrapper::mutable_contract_state() {
  ::protocol::ContractState* _msg = _internal_mutable_contract_state();
  // @@protoc_insertion_point(field_mutable:protocol.SmartContractDataWrapper.contract_state)
  return _msg;
}
inline void SmartContractDataWrapper::set_allocated_contract_state(::protocol::ContractState* contract_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_state_;
  }
  if (contract_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract_state);
    if (message_arena != submessage_arena) {
      contract_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contract_state_ = contract_state;
  // @@protoc_insertion_point(field_set_allocated:protocol.SmartContractDataWrapper.contract_state)
}

// -------------------------------------------------------------------

// BuyStorageBytesContract

// bytes owner_address = 1;
inline void BuyStorageBytesContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& BuyStorageBytesContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.BuyStorageBytesContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyStorageBytesContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BuyStorageBytesContract.owner_address)
}
inline std::string* BuyStorageBytesContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.BuyStorageBytesContract.owner_address)
  return _s;
}
inline const std::string& BuyStorageBytesContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void BuyStorageBytesContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BuyStorageBytesContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* BuyStorageBytesContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.BuyStorageBytesContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void BuyStorageBytesContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BuyStorageBytesContract.owner_address)
}

// int64 bytes = 2;
inline void BuyStorageBytesContract::clear_bytes() {
  _impl_.bytes_ = int64_t{0};
}
inline int64_t BuyStorageBytesContract::_internal_bytes() const {
  return _impl_.bytes_;
}
inline int64_t BuyStorageBytesContract::bytes() const {
  // @@protoc_insertion_point(field_get:protocol.BuyStorageBytesContract.bytes)
  return _internal_bytes();
}
inline void BuyStorageBytesContract::_internal_set_bytes(int64_t value) {
  
  _impl_.bytes_ = value;
}
inline void BuyStorageBytesContract::set_bytes(int64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:protocol.BuyStorageBytesContract.bytes)
}

// -------------------------------------------------------------------

// BuyStorageContract

// bytes owner_address = 1;
inline void BuyStorageContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& BuyStorageContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.BuyStorageContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyStorageContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BuyStorageContract.owner_address)
}
inline std::string* BuyStorageContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.BuyStorageContract.owner_address)
  return _s;
}
inline const std::string& BuyStorageContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void BuyStorageContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BuyStorageContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* BuyStorageContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.BuyStorageContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void BuyStorageContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BuyStorageContract.owner_address)
}

// int64 quant = 2;
inline void BuyStorageContract::clear_quant() {
  _impl_.quant_ = int64_t{0};
}
inline int64_t BuyStorageContract::_internal_quant() const {
  return _impl_.quant_;
}
inline int64_t BuyStorageContract::quant() const {
  // @@protoc_insertion_point(field_get:protocol.BuyStorageContract.quant)
  return _internal_quant();
}
inline void BuyStorageContract::_internal_set_quant(int64_t value) {
  
  _impl_.quant_ = value;
}
inline void BuyStorageContract::set_quant(int64_t value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:protocol.BuyStorageContract.quant)
}

// -------------------------------------------------------------------

// SellStorageContract

// bytes owner_address = 1;
inline void SellStorageContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& SellStorageContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.SellStorageContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellStorageContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SellStorageContract.owner_address)
}
inline std::string* SellStorageContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.SellStorageContract.owner_address)
  return _s;
}
inline const std::string& SellStorageContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void SellStorageContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SellStorageContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SellStorageContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.SellStorageContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void SellStorageContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.SellStorageContract.owner_address)
}

// int64 storage_bytes = 2;
inline void SellStorageContract::clear_storage_bytes() {
  _impl_.storage_bytes_ = int64_t{0};
}
inline int64_t SellStorageContract::_internal_storage_bytes() const {
  return _impl_.storage_bytes_;
}
inline int64_t SellStorageContract::storage_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.SellStorageContract.storage_bytes)
  return _internal_storage_bytes();
}
inline void SellStorageContract::_internal_set_storage_bytes(int64_t value) {
  
  _impl_.storage_bytes_ = value;
}
inline void SellStorageContract::set_storage_bytes(int64_t value) {
  _internal_set_storage_bytes(value);
  // @@protoc_insertion_point(field_set:protocol.SellStorageContract.storage_bytes)
}

// -------------------------------------------------------------------

// UpdateBrokerageContract

// bytes owner_address = 1;
inline void UpdateBrokerageContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& UpdateBrokerageContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateBrokerageContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateBrokerageContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.UpdateBrokerageContract.owner_address)
}
inline std::string* UpdateBrokerageContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.UpdateBrokerageContract.owner_address)
  return _s;
}
inline const std::string& UpdateBrokerageContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void UpdateBrokerageContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateBrokerageContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateBrokerageContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.UpdateBrokerageContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void UpdateBrokerageContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.UpdateBrokerageContract.owner_address)
}

// int32 brokerage = 2;
inline void UpdateBrokerageContract::clear_brokerage() {
  _impl_.brokerage_ = 0;
}
inline int32_t UpdateBrokerageContract::_internal_brokerage() const {
  return _impl_.brokerage_;
}
inline int32_t UpdateBrokerageContract::brokerage() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateBrokerageContract.brokerage)
  return _internal_brokerage();
}
inline void UpdateBrokerageContract::_internal_set_brokerage(int32_t value) {
  
  _impl_.brokerage_ = value;
}
inline void UpdateBrokerageContract::set_brokerage(int32_t value) {
  _internal_set_brokerage(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateBrokerageContract.brokerage)
}

// -------------------------------------------------------------------

// VoteAssetContract

// bytes owner_address = 1;
inline void VoteAssetContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& VoteAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.VoteAssetContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteAssetContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.VoteAssetContract.owner_address)
}
inline std::string* VoteAssetContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.VoteAssetContract.owner_address)
  return _s;
}
inline const std::string& VoteAssetContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void VoteAssetContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* VoteAssetContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* VoteAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.VoteAssetContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void VoteAssetContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.VoteAssetContract.owner_address)
}

// repeated bytes vote_address = 2;
inline int VoteAssetContract::_internal_vote_address_size() const {
  return _impl_.vote_address_.size();
}
inline int VoteAssetContract::vote_address_size() const {
  return _internal_vote_address_size();
}
inline void VoteAssetContract::clear_vote_address() {
  _impl_.vote_address_.Clear();
}
inline std::string* VoteAssetContract::add_vote_address() {
  std::string* _s = _internal_add_vote_address();
  // @@protoc_insertion_point(field_add_mutable:protocol.VoteAssetContract.vote_address)
  return _s;
}
inline const std::string& VoteAssetContract::_internal_vote_address(int index) const {
  return _impl_.vote_address_.Get(index);
}
inline const std::string& VoteAssetContract::vote_address(int index) const {
  // @@protoc_insertion_point(field_get:protocol.VoteAssetContract.vote_address)
  return _internal_vote_address(index);
}
inline std::string* VoteAssetContract::mutable_vote_address(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.VoteAssetContract.vote_address)
  return _impl_.vote_address_.Mutable(index);
}
inline void VoteAssetContract::set_vote_address(int index, const std::string& value) {
  _impl_.vote_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, std::string&& value) {
  _impl_.vote_address_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vote_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::set_vote_address(int index, const void* value, size_t size) {
  _impl_.vote_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.VoteAssetContract.vote_address)
}
inline std::string* VoteAssetContract::_internal_add_vote_address() {
  return _impl_.vote_address_.Add();
}
inline void VoteAssetContract::add_vote_address(const std::string& value) {
  _impl_.vote_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(std::string&& value) {
  _impl_.vote_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vote_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.VoteAssetContract.vote_address)
}
inline void VoteAssetContract::add_vote_address(const void* value, size_t size) {
  _impl_.vote_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.VoteAssetContract.vote_address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VoteAssetContract::vote_address() const {
  // @@protoc_insertion_point(field_list:protocol.VoteAssetContract.vote_address)
  return _impl_.vote_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VoteAssetContract::mutable_vote_address() {
  // @@protoc_insertion_point(field_mutable_list:protocol.VoteAssetContract.vote_address)
  return &_impl_.vote_address_;
}

// bool support = 3;
inline void VoteAssetContract::clear_support() {
  _impl_.support_ = false;
}
inline bool VoteAssetContract::_internal_support() const {
  return _impl_.support_;
}
inline bool VoteAssetContract::support() const {
  // @@protoc_insertion_point(field_get:protocol.VoteAssetContract.support)
  return _internal_support();
}
inline void VoteAssetContract::_internal_set_support(bool value) {
  
  _impl_.support_ = value;
}
inline void VoteAssetContract::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:protocol.VoteAssetContract.support)
}

// int32 count = 5;
inline void VoteAssetContract::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t VoteAssetContract::_internal_count() const {
  return _impl_.count_;
}
inline int32_t VoteAssetContract::count() const {
  // @@protoc_insertion_point(field_get:protocol.VoteAssetContract.count)
  return _internal_count();
}
inline void VoteAssetContract::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void VoteAssetContract::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.VoteAssetContract.count)
}

// -------------------------------------------------------------------

// WitnessCreateContract

// bytes owner_address = 1;
inline void WitnessCreateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& WitnessCreateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.WitnessCreateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WitnessCreateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WitnessCreateContract.owner_address)
}
inline std::string* WitnessCreateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.WitnessCreateContract.owner_address)
  return _s;
}
inline const std::string& WitnessCreateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void WitnessCreateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WitnessCreateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* WitnessCreateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.WitnessCreateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void WitnessCreateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WitnessCreateContract.owner_address)
}

// bytes url = 2;
inline void WitnessCreateContract::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& WitnessCreateContract::url() const {
  // @@protoc_insertion_point(field_get:protocol.WitnessCreateContract.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WitnessCreateContract::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WitnessCreateContract.url)
}
inline std::string* WitnessCreateContract::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:protocol.WitnessCreateContract.url)
  return _s;
}
inline const std::string& WitnessCreateContract::_internal_url() const {
  return _impl_.url_.Get();
}
inline void WitnessCreateContract::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WitnessCreateContract::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WitnessCreateContract::release_url() {
  // @@protoc_insertion_point(field_release:protocol.WitnessCreateContract.url)
  return _impl_.url_.Release();
}
inline void WitnessCreateContract::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WitnessCreateContract.url)
}

// -------------------------------------------------------------------

// WitnessUpdateContract

// bytes owner_address = 1;
inline void WitnessUpdateContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& WitnessUpdateContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.WitnessUpdateContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WitnessUpdateContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WitnessUpdateContract.owner_address)
}
inline std::string* WitnessUpdateContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.WitnessUpdateContract.owner_address)
  return _s;
}
inline const std::string& WitnessUpdateContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void WitnessUpdateContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WitnessUpdateContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* WitnessUpdateContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.WitnessUpdateContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void WitnessUpdateContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WitnessUpdateContract.owner_address)
}

// bytes update_url = 12;
inline void WitnessUpdateContract::clear_update_url() {
  _impl_.update_url_.ClearToEmpty();
}
inline const std::string& WitnessUpdateContract::update_url() const {
  // @@protoc_insertion_point(field_get:protocol.WitnessUpdateContract.update_url)
  return _internal_update_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WitnessUpdateContract::set_update_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.update_url_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.WitnessUpdateContract.update_url)
}
inline std::string* WitnessUpdateContract::mutable_update_url() {
  std::string* _s = _internal_mutable_update_url();
  // @@protoc_insertion_point(field_mutable:protocol.WitnessUpdateContract.update_url)
  return _s;
}
inline const std::string& WitnessUpdateContract::_internal_update_url() const {
  return _impl_.update_url_.Get();
}
inline void WitnessUpdateContract::_internal_set_update_url(const std::string& value) {
  
  _impl_.update_url_.Set(value, GetArenaForAllocation());
}
inline std::string* WitnessUpdateContract::_internal_mutable_update_url() {
  
  return _impl_.update_url_.Mutable(GetArenaForAllocation());
}
inline std::string* WitnessUpdateContract::release_update_url() {
  // @@protoc_insertion_point(field_release:protocol.WitnessUpdateContract.update_url)
  return _impl_.update_url_.Release();
}
inline void WitnessUpdateContract::set_allocated_update_url(std::string* update_url) {
  if (update_url != nullptr) {
    
  } else {
    
  }
  _impl_.update_url_.SetAllocated(update_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_url_.IsDefault()) {
    _impl_.update_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.WitnessUpdateContract.update_url)
}

// -------------------------------------------------------------------

// VoteWitnessContract_Vote

// bytes vote_address = 1;
inline void VoteWitnessContract_Vote::clear_vote_address() {
  _impl_.vote_address_.ClearToEmpty();
}
inline const std::string& VoteWitnessContract_Vote::vote_address() const {
  // @@protoc_insertion_point(field_get:protocol.VoteWitnessContract.Vote.vote_address)
  return _internal_vote_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteWitnessContract_Vote::set_vote_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vote_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.VoteWitnessContract.Vote.vote_address)
}
inline std::string* VoteWitnessContract_Vote::mutable_vote_address() {
  std::string* _s = _internal_mutable_vote_address();
  // @@protoc_insertion_point(field_mutable:protocol.VoteWitnessContract.Vote.vote_address)
  return _s;
}
inline const std::string& VoteWitnessContract_Vote::_internal_vote_address() const {
  return _impl_.vote_address_.Get();
}
inline void VoteWitnessContract_Vote::_internal_set_vote_address(const std::string& value) {
  
  _impl_.vote_address_.Set(value, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract_Vote::_internal_mutable_vote_address() {
  
  return _impl_.vote_address_.Mutable(GetArenaForAllocation());
}
inline std::string* VoteWitnessContract_Vote::release_vote_address() {
  // @@protoc_insertion_point(field_release:protocol.VoteWitnessContract.Vote.vote_address)
  return _impl_.vote_address_.Release();
}
inline void VoteWitnessContract_Vote::set_allocated_vote_address(std::string* vote_address) {
  if (vote_address != nullptr) {
    
  } else {
    
  }
  _impl_.vote_address_.SetAllocated(vote_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vote_address_.IsDefault()) {
    _impl_.vote_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.VoteWitnessContract.Vote.vote_address)
}

// int64 vote_count = 2;
inline void VoteWitnessContract_Vote::clear_vote_count() {
  _impl_.vote_count_ = int64_t{0};
}
inline int64_t VoteWitnessContract_Vote::_internal_vote_count() const {
  return _impl_.vote_count_;
}
inline int64_t VoteWitnessContract_Vote::vote_count() const {
  // @@protoc_insertion_point(field_get:protocol.VoteWitnessContract.Vote.vote_count)
  return _internal_vote_count();
}
inline void VoteWitnessContract_Vote::_internal_set_vote_count(int64_t value) {
  
  _impl_.vote_count_ = value;
}
inline void VoteWitnessContract_Vote::set_vote_count(int64_t value) {
  _internal_set_vote_count(value);
  // @@protoc_insertion_point(field_set:protocol.VoteWitnessContract.Vote.vote_count)
}

// -------------------------------------------------------------------

// VoteWitnessContract

// bytes owner_address = 1;
inline void VoteWitnessContract::clear_owner_address() {
  _impl_.owner_address_.ClearToEmpty();
}
inline const std::string& VoteWitnessContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.VoteWitnessContract.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteWitnessContract::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.VoteWitnessContract.owner_address)
}
inline std::string* VoteWitnessContract::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.VoteWitnessContract.owner_address)
  return _s;
}
inline const std::string& VoteWitnessContract::_internal_owner_address() const {
  return _impl_.owner_address_.Get();
}
inline void VoteWitnessContract::_internal_set_owner_address(const std::string& value) {
  
  _impl_.owner_address_.Set(value, GetArenaForAllocation());
}
inline std::string* VoteWitnessContract::_internal_mutable_owner_address() {
  
  return _impl_.owner_address_.Mutable(GetArenaForAllocation());
}
inline std::string* VoteWitnessContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.VoteWitnessContract.owner_address)
  return _impl_.owner_address_.Release();
}
inline void VoteWitnessContract::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  _impl_.owner_address_.SetAllocated(owner_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_address_.IsDefault()) {
    _impl_.owner_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.VoteWitnessContract.owner_address)
}

// repeated .protocol.VoteWitnessContract.Vote votes = 2;
inline int VoteWitnessContract::_internal_votes_size() const {
  return _impl_.votes_.size();
}
inline int VoteWitnessContract::votes_size() const {
  return _internal_votes_size();
}
inline void VoteWitnessContract::clear_votes() {
  _impl_.votes_.Clear();
}
inline ::protocol::VoteWitnessContract_Vote* VoteWitnessContract::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.VoteWitnessContract.votes)
  return _impl_.votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::VoteWitnessContract_Vote >*
VoteWitnessContract::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.VoteWitnessContract.votes)
  return &_impl_.votes_;
}
inline const ::protocol::VoteWitnessContract_Vote& VoteWitnessContract::_internal_votes(int index) const {
  return _impl_.votes_.Get(index);
}
inline const ::protocol::VoteWitnessContract_Vote& VoteWitnessContract::votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.VoteWitnessContract.votes)
  return _internal_votes(index);
}
inline ::protocol::VoteWitnessContract_Vote* VoteWitnessContract::_internal_add_votes() {
  return _impl_.votes_.Add();
}
inline ::protocol::VoteWitnessContract_Vote* VoteWitnessContract::add_votes() {
  ::protocol::VoteWitnessContract_Vote* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:protocol.VoteWitnessContract.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::VoteWitnessContract_Vote >&
VoteWitnessContract::votes() const {
  // @@protoc_insertion_point(field_list:protocol.VoteWitnessContract.votes)
  return _impl_.votes_;
}

// bool support = 3;
inline void VoteWitnessContract::clear_support() {
  _impl_.support_ = false;
}
inline bool VoteWitnessContract::_internal_support() const {
  return _impl_.support_;
}
inline bool VoteWitnessContract::support() const {
  // @@protoc_insertion_point(field_get:protocol.VoteWitnessContract.support)
  return _internal_support();
}
inline void VoteWitnessContract::_internal_set_support(bool value) {
  
  _impl_.support_ = value;
}
inline void VoteWitnessContract::set_support(bool value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:protocol.VoteWitnessContract.support)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::Permission_PermissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Permission_PermissionType>() {
  return ::protocol::Permission_PermissionType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Contract_ContractType>() {
  return ::protocol::Transaction_Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Result_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Result_code>() {
  return ::protocol::Transaction_Result_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Result_contractResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Result_contractResult>() {
  return ::protocol::Transaction_Result_contractResult_descriptor();
}
template <> struct is_proto_enum< ::protocol::SmartContract_ABI_Entry_EntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::SmartContract_ABI_Entry_EntryType>() {
  return ::protocol::SmartContract_ABI_Entry_EntryType_descriptor();
}
template <> struct is_proto_enum< ::protocol::SmartContract_ABI_Entry_StateMutabilityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::SmartContract_ABI_Entry_StateMutabilityType>() {
  return ::protocol::SmartContract_ABI_Entry_StateMutabilityType_descriptor();
}
template <> struct is_proto_enum< ::protocol::ResourceCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ResourceCode>() {
  return ::protocol::ResourceCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::AccountType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::AccountType>() {
  return ::protocol::AccountType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TronInternal_2eproto
